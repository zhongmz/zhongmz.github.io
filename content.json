{"meta":{"title":"Xxgzbd's Blog","subtitle":"","description":"记录","author":"钟美智","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-09-23T05:28:32.000Z","updated":"2020-03-23T14:05:25.637Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2019-09-23T05:35:25.000Z","updated":"2020-03-23T11:42:22.673Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"练习","slug":"微机系统/习题","date":"2020-07-17T13:49:19.000Z","updated":"2020-07-17T05:19:35.430Z","comments":true,"path":"2020/07/17/ 微机系统/习题/","link":"","permalink":"http://yoursite.com/2020/07/17/ 微机系统/习题/","excerpt":"","text":"1","categories":[{"name":"接口技术","slug":"接口技术","permalink":"http://yoursite.com/categories/接口技术/"}],"tags":[]},{"title":"微型计算机接口技术课后习题","slug":"微机系统/微型计算机原理与接口技术课后习题","date":"2020-07-17T06:49:19.000Z","updated":"2020-07-17T06:36:28.119Z","comments":true,"path":"2020/07/17/ 微机系统/微型计算机原理与接口技术课后习题/","link":"","permalink":"http://yoursite.com/2020/07/17/ 微机系统/微型计算机原理与接口技术课后习题/","excerpt":"","text":"0x01 Pentium保护模式存储管理1.1简述虚拟存储器的含义，试在存储层次，功能，结构，信息传送单位，操作过程等方面对比虚拟存储器和Cache存储器。 虚拟存储器是由主存储器，辅助存储器，辅助硬件和操作系统管理软件组成的一种存储体系。 其目的是为了增加存储器的容量，速度接近于主存储器，单位造价接近辅助存储器 1.2简要说明虚拟存储器的工作原理 应用程序访问虚拟存储器时，给出逻辑地址。然后进行内部地址变换得到物理地址，若要访问的信息在主存中，则访问主存储器，得到信息；若访问的信息不再主存中，则根据逻辑地址进行外部地址变换得到辅存地址；同时检查主存是否有空闲区，若无则根据替换算法将主存中某个块送到辅存，再把辅存地址中的信息块送到主存；若有，则直接送入主存。 1.3虚拟存储器指的是主存-辅存存储层次，它给用户提供了一个比实际空间大得多的空间。 物理 虚拟 1.4说明3类地址空间的含义。 虚拟地址空间，是程序员用来编写程序的地址空间，其对应的地址称为虚地址或逻辑地址。 主存地址空间，是实存地址空间，是存储，运行程序的空间，其相应的地址称为主存物理地址或实地址。 辅存地址空间，是磁盘存储器的地址空间，是用来存放程序的空间，器地址称为辅存地址或磁盘地址。 1.5段描述符按段的性质分为哪几类？ 分为3类，程序段描述符，系统段描述符，门描述符。 1.6Pentium的实地址方式和保护模式由__寄存器的PE位来选择。 CR0 1.7段描述符高速缓冲寄存器有什么作用？ 段描述符高速缓冲寄存器即段寄存器。其作用如下。 CS，存放正在运行的程序代码的段基址 DS，存放数据段的段基址 SS，存放当前堆栈段的段基址 ES，存放附加的数据段的段基址 1.8说明向保护模式转换的方法及转换前的准备工作 初始化IDT，使其包含至少32种中断类型有效的中断门描述符 初始化GDT，使其第0项为一个空描述符，并且至少包含一个数据段描述符，一个代码段描述符，一个堆栈段描述符。（为什么？orz :question: 1.9Pentium微处理器的虚拟地址有多少位？虚拟地址的2个组成部分分别叫什么名字？ 46位 段选择符；段内偏移量 1.10Pentium微处理器的保护机制有哪些措施？ 任务间存储空间的保护 段属性和界限的保护 特权级保护 1.11Pentium微处理器是怎样将虚拟地址转换成物理地址的？ 在实地址模式下，虚拟地址的形式为[段地址]:[偏移地址]，物理地址是这样形成：段寄存器内容左移4位加上偏移地址。 在保护模式下，虚拟地址的形式为[段选择符]:[偏移地址]，物理地址是这样形成：段选择符在段寄存器中，但是并不直接表示段基址，通过段选择符部分的13位索引字段确定段描述符再段描述符表的位置，取出段描述符中的32位段基址与偏移量相加得到线性地址，若不启用分页则线性地址作为物理地址。 1.12试说明Pentium微处理器段的转换过程 我们不妨以访问数据段的访问过程来说明段的转换过程，其他段类似 现在有一个虚地址，由段选择符和段内偏移构成 将16位的段选择符送入DS 根据段选择符中TI的值决定选择再局部描述符表LDT还是选择再全局描述符表GDT来寻找段描述符；由于二者类似，不妨假设选择LDT。 段选择符中的INDEX字段乘8后加上LDTR中的基地址得到LDT中的数据段描述符的地址。 将对应的段描述符的内容送入DS段寄存器的不可见部分，其中包括32位基地址，20位段限，12位属性。 将DS段寄存器32位基地址与虚地址中的段内偏移向加得到线性地址。 1.13试说明数据段描述符与代码段描述符的异同点。 段描述符的格式相同，都属于程序段描述符 TYPE类型字段不同，D/B字段表示含义不同 1.14IDTR,GDTR,LDTR分别代表什么寄存器，其内容是什么信息？有什么作用？ 中断描述符表寄存器；全局描述符表寄存器；局部描述符表寄存器 IDTR保存着32位基址和16位界限； GDTR保存着GDT的32位基地址和16位界限；LDTR保存着16位选择符，32位基地址，20位界限，12位属性组成。 作用 IDTR：32位基址表示IDT起始位置，16位界限表示IDT的描述符项数 GDTR：32位基址表示GDT起始位置，16位界限表示GDT的描述符项数 LDTR：32位基址标识LDT在内存中的起始物理地址，20位界限表示LDT的长度，而16位段选择符是指向GDT中LDT描述符的选择符，需要从GDT中读取段描述符，并且装入LDTR中程序不可见部分。才能找到LDT 1.15Pentium可进行段页式存储器管理。Pentium的段描述符为8字节，包括了段基址，段长和属性等信息（段基址32位，段长20位），其中有一个G位用于定义段长单位，G=0定义段长以字节为单位，G=1定义段长以页面为单位，针对Pentium，分析回答以下问题： 一个页面包含多少个字节？其页面数据容量是否可变？若可以改变，则简要说明改变的方法。 当G=0时，该段的最大数据容量是多少个字节？ 当G=1时，该段的最大数据容量时多少个字节？ 0x03 中断3.1什么叫中断？在微机系统中为什么要使用中断？ CPU在正常执行当前程序，由某一事件引起CPU暂时停止当前任务，转去执行请求CPU暂停的服务程序，该服务程序执行完后又返回继续执行被暂停的程序，这一过程叫中断 主要作用 实现主机与I/O设备的并行工作 利用中断进行实时处理 利用中断方式进行人机对话 故障处理 多处理机系统中各处理机之间协调作用 3.2什么叫中断源？中断嵌套的含义是什么？ 凡是能够提出中断请求的设备或异常故障均被称为中断源 在执行中断服务程序的过程中又发生新的中断 3.3Pentium微处理机内部有哪几类中断源？简要说明各类的特点是什么？ 分为四类中断 可屏蔽中断INTR 非屏蔽中断NMI 软件中断（执行INTO,INT3,INT n,BOUND指令引起的中断） 异常 INTR通常是由Intel 8259A中断控制器驱动，向INTR引脚发中断请求，通过数据总线向CPU发中断类型码 NMI通常用来通知CPU发生重大故障的事件，比如电源掉电。不受IF中断允许标志的影响，优先级非常高。上升沿触发信号 软件中断 人为设置在程序中 类型码包含在指令中，所以不执行中断响应总线周期 除BOUND指令外，中断返回地址为下一条指令 异常是在CPU执行一条指令过程中出现的错误或者检测的异常情况产生的 3.4在Pentium微处理机中中断和异常有何异同？ 中断是用来处理CPU以外的异常事件 异常时用来处理执行指令期间由CPU本身检测出来的某些异常事情作出的响应 3.5通常CPU响应外部中断的条件有哪些？ 有中断请求 中断标志位IF=1 3.6简述CPU响应中断后，中断处理的过程，用流程图表示 3.7什么情况下需要有中断判优机构？程序查询式和中断向量式2种中断源识别与判优方案各有什么特点？ 系统遇到多个中断源同时请求中断的情况下，需要有中断判优机构。 程序查询式是软件查询，较为灵活，但是中断源多时，转至中断服务程序时间长 中断向量式是硬件优先级排队电路确定优先级，速度块，但是优先级固定不变。 3.8什么叫中断向量？试说明Pentium微处理机可屏蔽硬件中断是怎样获得中断向量，从而进入中断程序的。 中断向量是中断服务程序的入口地址。 根据8259A送道数据总线的中断类型码*4取得中断向量，把中断向量的前2个字节装入IP，后2个字节装入CS，这样CPU执行的下一条指令就是中断服务程序的第一条指令，也就是说，CPU进入了中断服务程序。 3.9中断描述符表的作用是什么？其内保存的是什么信息？ 中断描述符表保存门描述符 门描述符中保存的信息有段选择符，32位偏移，还有属性用来在GDT或LDT中找到中断服务程序的基地址。 3.108259A芯片是一种什么类型的芯片？试着说明8259芯片的主要功能。 是一种中断管理芯片，简称PIC 主要作用 管理8级优先权中断源 对任何级别中断源可单独屏蔽 向CPU发送可编程的标识码，即中断类型码 可与Pentium的CPU直接连接，不需要外加电路 多种工作方式 38INTR与NMI的区别 CPU在响应NMI时，不从外部设备读取中断类型码，因为NMI的中断类型码固定为2","categories":[{"name":"接口技术","slug":"接口技术","permalink":"http://yoursite.com/categories/接口技术/"}],"tags":[]},{"title":"OS习题","slug":"操作系统/OS习题","date":"2020-07-14T01:56:52.000Z","updated":"2020-07-16T08:55:03.238Z","comments":true,"path":"2020/07/14/ 操作系统/OS习题/","link":"","permalink":"http://yoursite.com/2020/07/14/ 操作系统/OS习题/","excerpt":"","text":"0x011什么是操作系统？操作系统有哪些特点？ 操作系统是位于硬件层之上，所有其他系统软件层之下的一个系统软件，通过它管理系统中的各种软件和资源，使它们能被充分利用，方便用户使用计算机系统。 特点 并发性 共享性 异步性 虚拟性 2硬件将处理器划分为两种，即管态和目态，这样做会给操作系统的设计带来什么好处？ 防止用户侵入系统，起到保护系统的作用 3何为特权指令？试举例说明。如果允许用户进程执行特权指令，会带来什么后果？举例说明 特权指令：只能在管态下才能执行的指令称为特权指令 允许用户进程执行特权指令，则可能会导致停机，影响其他程序允许，甚至整个系统 4中断向量在计算机中的存储位置是由硬件决定的，还是由软件决定的？ 是由硬件决定的 5中断向量的内容是由操作系统决定的还是由用户程序决定的？ 是由操作系统决定的 6 为什么？？中断向量内的处理器状态字应当标明为管态还是目态？为什么？ 应标明为管态 处理机状态由目态转为管态的唯一途径是中断，因此会产生中断向量，此时需要把中断向量的处理器状态字标明为管态。 7系统如何由目态转换为管态？如何由管态转换为目态？ 唯一途径是中断 修改程序状态字PSW 8中断与程序并发之间的关系是什么？ 中断时程序并发的前提条件，若没有中断，操作系统则不能获得系统控制权，无法对处理器重新分配。 9根据用途说明“栈”和“堆”的差别？ 栈用来实现中断嵌套和子程序调用的参数，返回断点，局部变量，返回值 堆是为动态变量分配存储空间 10何谓系统栈？何谓用户栈？系统栈有何用途？用户栈有何用途？ 系统栈在逻辑上属于操作系统空间，是系统空间中的一个区域。 用户栈属于用户空间，是内存中用户空间的一个区域。 系统栈用途：一是保存操作系统子程序间相互调用的返回点，参数，局部变量，返回值；二是中断响应时保存中断现场 用户栈用途：一是保存用户函数调用时的返回点，参数，局部变量，返回值。 11为何无法确定用户堆栈段的长度？ 用户堆栈段的长度取决于 进程子程序嵌套深度 子程序的参数和局部变量的数量和类型 动态变量的数量和类型 这些在进程运行前无法确定，导致堆栈段的长度无法预先确定。 12为何堆栈段的动态扩充可能导致进程空间的变迁？ 堆栈段的扩充意味着存储区域的增加，并要求与原来存储区域连续。若原存储处可扩展区域被其他进程所占用，可能需要将整个进程空间搬迁到另外一个区域，从而导致了进程空间的变迁。 13何谓并行？何谓并发？在单处理器系统中，下述并行和并发信息哪些可能发生，哪些不会发生？ 进程与进程之间的并行 进程与进程之间的并发 处理器与设备之间的并行 处理器与通道之间的并行 通道与通道之间的并行 设备与设备之间的并行 并行指的时在微观上的同时，在绝对的同一时刻由多个进程同时向前推进 并发不需要微观上的同时，只需要从宏观上看多个程序都在向前推进 不可能发生：(1) 14何谓作业？它包括哪几个部分？各个部分的用途时什么？ 用户要求计算机系统为其完成的计算任务的集合称为作业 作业包括 程序 作业说明书 数据 程序是完成某一功能 数据是程序处理对象 作业说明书用来说明作业处理的步骤 15试述批处理操作系统与分时操作系统的区别 批处理操作系统是以脱机操作为标志的操作系统，作业逐批进入系统，逐批离开系统。无用户干扰 分时操作系统是以联机操作为标志的操作系统，适合程序的动态修改。需要与用户交互 16从透明性和资源共享2个方面说明网络操作系统与分布式操作系统的差别。 从透明性来看，网络操作系统用户能感觉到本地HOST与非本地HOST在地理额外i之上的差异；而在分布式系统中，所有HOST构成一个完整的，功能更加强大的计算机系统，掩盖了地理位置上的差异 从资源共享来看，分布式操作系统比网络操作系统更能共享更多的资源，原因在于网络操作系统其HOST上的系统不统一，导致一个计算任务不能由另外一台HOST运行，但是分布式操作系统的HOST操作系统相同。 17为什么构成分布式系统的主机一般都是相同的或兼容的？ 利于进程的动态迁移 18集群系统与分布式系统有何差异？ 集群指的是将几台服务器集中在一起，实现同一业务。 分布式是将不同的1业务分布在不同地方 分布式结构的每一个节点都可以做集群；而集群并不一定就是分布式 19何谓云存储？何谓云计算？ 0x021为何引入多道程序设计？在多道程序系统中，内存中的作业的道数是否越多越好？请说明原因。 因为系统的资源数量多，资源使用者少。为了允许多个程序同时进入系统，即增加资源使用者的数量，提高系统资源利用率。 不是，一个计算机系统的资源是有限的，只能容纳适量的作业；当作业道数不合理增加，导致资源竞争大，系统开销大。 2多道程序设计会带来哪些问题？如何解决？ 处理器资源管理问题，需要实现处理器资源在各个程序之间的分配和调度。 内存资源管理问题，解决：程序使用相对地址，不使用绝对地址，实现程序的重定位，还需要防止程序之间的内存干扰 设备资源管理问题，操作系统需要采取适当的分配策略据此对资源加以管理。 3什么是进程？进程具有哪些主要特性？试比较进程与程序之间的相同点与不同点。 进程是具有一定独立功能的程序关于一个数据集合的一次运行活动 进程的特性 并发性 动态性 独立性 交互性 异步性 结构性 程序是构成进程的组成部分之一 程序是静态的，进程是动态的；程序是永久的，进程是具有生存周期的；一个程序可以对应多个进程，一个进程只能对应一个程序。 4有人说，用户所执行的程序一定是用户自己编写的。这种说法对吗？如果不对，试举例说明之。 不对，比如C编译程序时以用户进程身份进行，但C编译程序不是用户自己编写的。 5什么是进程上下文？进程上下文包括哪些成分？哪些成分对目态程序是可见的？ 在UNIX System V中，将进程的物理实体与支持进程运行的物理环境合称为进程上下文。 包括3个组成部分： 用户级上下文 系统级上下文 寄存器上下文 用户级上下文和部分寄存器上下文对目态程序是可见的。 6进程一般具有哪三个主要状态？举例说明状态转换的原因 运行态；就绪态；等待态 当就绪态进程获得处理器，变为运行态 当运行态进程被剥夺处理器，变为就绪态 当运行\\就绪态进程因为某一事件受阻时，变为等待态 当等待事件发生，变为就绪态 0x03例3-1考虑CPU阵发进程，得到先到先服务算法调度性能指标 甘特图 列表 例3-2最短作业优先算法","categories":[{"name":"OS","slug":"OS","permalink":"http://yoursite.com/categories/OS/"}],"tags":[]},{"title":"SVM","slug":"MachineLearning/SVM","date":"2020-07-08T01:56:52.000Z","updated":"2020-07-08T09:22:54.244Z","comments":true,"path":"2020/07/08/ MachineLearning/SVM/","link":"","permalink":"http://yoursite.com/2020/07/08/ MachineLearning/SVM/","excerpt":"","text":"我们知道 逻辑回归激励函数 h_{\\theta}(x)=\\frac{1}{1+e^{-\\theta^{T}x}} 本质上，支持向量机的代价函数与逻辑回归的代价函数无差别，但是为了使得后面计算更直观些，我们不妨稍微调整一下支持向量机的代价函数。 回顾逻辑回归代价函数 -(ylog(h_{\\theta}(x))+(1-y)log(1-h_{\\theta}(x))) 而支持向量机代价函数 C\\sum_{i=1}^{m}[y^{(i)}cost_1(\\theta^{T}x^{(i)})+(1-y^{i})cost_0(\\theta^{T}x^{(i)})]+\\frac{1}{2}\\sum_{i=1}^{n}\\theta^2_j\\\\ 其中,cost_0(z)=-log(1-\\frac{1}{1+e^{-z}}),cost_1(z)=log\\frac{1}{1+e^{-z}}其中，C可以理解为$\\frac{1}{\\lambda}$ 而SVM也被人们称之为大间距分类器。 即，使得间距最大。 核函数 Kernels设存在2个特征，我们设其假设函数为 \\theta_0+\\theta_1x_1+\\theta_2x_2+\\theta_3x_1x_2+\\theta_4x_1^2+...再进行一些优化 \\theta_0+\\theta_1f_1+\\theta_2f_2+\\theta_3f_3+\\theta_4f_4+...高斯核函数 根据$x$的各个特征选取landmarks example:\\\\ f_1=similarity(x,l^{(1)})=e^{-\\frac{||x-l^{(1)}||^2}{2\\sigma^2}}那么 f_1称为核函数不妨再重新回顾下过程 Given (x^{(1)},y^{(1)}),(x^{(2)},y^{(2)})...(x^{(m)},y^{(m)})\\\\ Choose l^{(1)}=x^{(1)},l^{(2)}=x^{(2)},...l^{(m)}=x^{(m)} Get $f_i$ f_1=similarity(x,l^{(1)})\\\\ ... 对于$x_{(i)}$ f^{(i)}_1\\\\ f^{(i)}_2\\\\ f^{(i)}_3\\\\ ...\\\\ f^{(i)}_m\\\\ min C\\sum_{i=1}^{m}[y^{(i)}cost_1(\\theta^{T}f^{(i)})+(1-y^{i})cost_0(\\theta^{T}f^{(i)})]+\\frac{1}{2}\\sum_{i=1}^{n}\\theta^2_j\\\\ 其中,cost_0(z)=-log(1-\\frac{1}{1+e^{-z}}),cost_1(z)=log\\frac{1}{1+e^{-z}} 对于参数 C Large C: Lower bias, high variance Small C: Higher bias, low variance $\\sigma^2$ Large $\\sigma^2$: Higher bias lower variance Small $\\sigma^2$: Lower bias higher variance","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/categories/Machine-Learning/"}],"tags":[]},{"title":"计数方法","slug":"Math/计数方法","date":"2020-06-08T13:49:01.000Z","updated":"2020-06-13T06:12:07.471Z","comments":true,"path":"2020/06/08/ Math/计数方法/","link":"","permalink":"http://yoursite.com/2020/06/08/ Math/计数方法/","excerpt":"","text":"二项式定理 {(x+y)}^n=\\dbinom{n}{0}x^0y^n+\\dbinom{n}{1}x^1y^{n-1}...+\\dbinom{n}{n-1}x^{n-1}y^1+\\dbinom{n}{n}x^ny^0，其中n\\geq 0 对称关系 递推关系Pascal公式 单峰性 即有：\\dbinom{n}{k}\\\\ (1)\\ \\dbinom{n}{k}=\\dbinom{n}{n-k} \\\\ (2)\\ \\dbinom{n}{k}=\\dbinom{n-1}{k}+\\dbinom{n-1}{k-1}\\\\ (3)\\ \\dbinom{n}{\\frac{n}{2}}为max\\\\牛顿二项式设有$\\dbinom{a}{r}$ 当$a=-n$ \\dbinom{a}{r}=\\dbinom{-n}{r}=(-1)^r\\dbinom{n+r-1}{r} 多项式定理设$n$为正整数，则 (x_1+x_2+...+x_t)=\\sum\\dbinom{n}{n_1n_2...n_t}x_1^{n_1}...x_t^{n_t}\\\\ 其中 \\dbinom{n}{n_1n_2...n_t}=\\frac{n!}{n_1!n_2!...n_t!}并且n_1+n_2...+n_t=n 其展开式在合并同类项后不同项目数目为$\\dbinom{n+t-1}{n}$ 组合恒等式 page 55: 6","categories":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/categories/组合数学/"}],"tags":[]},{"title":"中断","slug":"微机系统/中断","date":"2020-06-06T13:49:19.000Z","updated":"2020-07-09T08:04:46.840Z","comments":true,"path":"2020/06/06/ 微机系统/中断/","link":"","permalink":"http://yoursite.com/2020/06/06/ 微机系统/中断/","excerpt":"","text":"bx,si,di,bp 123456789101112131415161718192021222324252627282930assume cs:codecode segment start: mov ax,cs mov ds,ax mov si,offset sqr mov ax,0 mov es,ax mov di,200h mov cx,offset sqrend-offset sqr cld rep movsb mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21h sqr: mul ax iret sqrend: nop code endsend start","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"OTHERS","slug":"微机系统/notice","date":"2020-06-06T13:49:19.000Z","updated":"2020-07-12T12:54:14.363Z","comments":true,"path":"2020/06/06/ 微机系统/notice/","link":"","permalink":"http://yoursite.com/2020/06/06/ 微机系统/notice/","excerpt":"","text":"换行 12345mov ah,2mov dl,0DHint 21hmov dl,0AHINT 21H","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"汇编实验","slug":"微机系统/汇编实验","date":"2020-06-06T13:49:19.000Z","updated":"2020-07-09T08:03:32.439Z","comments":true,"path":"2020/06/06/ 微机系统/汇编实验/","link":"","permalink":"http://yoursite.com/2020/06/06/ 微机系统/汇编实验/","excerpt":"","text":"0x01从键盘输入一系列以$为结束符的字符串，然后对其中的非数字字符计数，并显示出计数结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174assume cs:codedata1 segment DB &quot;Please input the word !&quot;,0dh,0ah,0 data1 endsdata segment db 10 dup (0)data endsANS segment DB 0dh,0ah,&quot;answer=&quot;,0ANS endsstack segment db 128 dup (0) stack endscode segment start: mov ax,stack mov ss,ax mov sp,128 mov ax,data1 mov ds,ax mov cx,19h mov bx,0 call show_str mov dx,0 s2: ;counter save in dx a1: mov ah,1 int 21h cmp al,&apos;$&apos; jne a2 mov ax,ANS mov ds,ax mov cx,7 mov bx,0 call show_str mov cx,dx jcxz Q2 call show Q1: mov ax,4c00h int 21h Q2: mov dl,&apos;0&apos; mov ah,2 int 21h mov ax,4c00h int 21h a2: cmp al,&apos;1&apos; jb a3 cmp al,&apos;9&apos; ja a3 jmp a1 a3: inc dx jmp a1 ;input: ds,bx ;using bx,cx,dx show_str: push ax push dx push bx push cx mov dh,0 s11: mov DL,[BX] mov cx,dx jcxz zero mov ah,2 int 21h inc bx loop s11 zero: pop cx pop bx pop dx pop ax ret ;------------------------------------------------------------------------- ;input: dx ;output [data to string and show the string] show: push ax push bx push ds push si push dx push cx mov ax,dx mov bx,data mov ds,bx mov si,0 call dtoc mov ax,data mov ds,ax mov bx,0 call show_str pop cx pop dx pop si pop ds pop bx pop ax ret ;-------------------------------------------------------------------------------- ; input ax ; output translate the ax to string and save in the data from offset data:0000h dtoc: push ax push si push di push dx push bx push cx mov di, 0 mov dx, 0 mov bx, 10 devide: mov cx, ax jcxz stop div bx inc di push dx mov dx, 0 jmp devide stop: mov cx, di string: pop bx add bx, 30h mov [si], bl inc si loop string pop cx pop bx pop dx pop di pop si pop ax retcode endsend start 0x02定义一个字变量DAT1，长度为1，把DAT1中的数据按字节单元依次显示到屏幕上，显示方式为 段地址：偏移量 十六进制字节数据. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167assume cs:codedata1 segment DAT1 DW 1234Hdata1 endsdata segment dw 128 dup (0)data endsstack segment dw 128 dup (0) stack ends code segment start: mov ax,stack mov ss,ax mov ax,128 mov sp,ax mov ax,data mov ds,ax mov ax,data1 mov es,ax mov bx,0 mov ax,0 mov si,ax mov ax,4 mov di,ax mov ax,data1 call dtoc16 mov ax,&apos;h&apos; mov ds:[4],ax mov ax,&apos;:&apos; mov ds:[5],ax mov ax,0 mov si,6 call dtoc16 mov al,&apos;h&apos; mov ds:[10],ax mov al,&apos; &apos; mov ds:[11],ax mov si,12 mov di,2 mov al,es:[0] mov ah,0 call dtoc16 mov al,0dh mov ds:[14],al mov al,0ah mov ds:[15],al mov ax,data1 mov di,4 mov si,16 call dtoc16 mov al,&apos;h&apos; mov ds:[20],al mov al,&apos;:&apos; mov ds:[21],al mov ax,1 mov di,4 mov si,22 call dtoc16 mov ds:[26],&apos;h&apos; mov ds:[27],&apos; &apos; tes: mov si,28 mov di,2 mov al,es:[1] mov ah,0 call dtoc16 call show_str mov ax,4c00h int 21h ;input ;ax: as the data to string ;ds: segment address in the memory to save string ;si: the begin of offset address in the memory to save string ;di: how many byte to use dtoc16: push ax push bx push cx push dx mov bx,16 mov cx,4 ;devide16: s: mov dx,0 div bx push dx loop s mov cx,di cmp cx,2 jne string pop ax pop ax string: pop ax add ax,30h mov ds:[si],al inc si loop string pop dx pop cx pop bx pop ax ret show_str: push ax push dx push bx push cx mov dh,0 s11: mov DL,[BX] mov cx,dx jcxz zero mov ah,2 int 21h inc bx loop s11 zero: pop cx pop bx pop dx pop ax ret code endsend start 0x051234567891011121314151617181920212223assume cs:codecode segment mov ax,0B800H mov ds,ax mov bx,0 mov si,0 mov cx,16 mov al,&apos;W&apos; mov ah,01110100B s: mov ds:[bx+si],ax inc ah add bx,160 add si,2 loop s mov ax,4c00h int 21h code ends 0x0612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061assume cs:codestack segment dw 128 dup (0) stack endscode segment start: mov ax,stack mov ss,ax mov sp,128 mov ax,0B800H mov ds,ax mov bx,158+158 mov si,0 mov cx,20 mov al,&apos; &apos; mov ah,01000100B s1: push cx mov bp,bx mov di,si mov cx,2 ;清屏 call Clear_Screen s2: push cx mov cx,9 s3: mov ds:[bp+di],ax add di,2 loop s3 pop cx add bp,158 mov di,si loop s2 mov dl,&apos;O&apos; mov dh,00000100B mov ds:[bp+si],dx mov ds:[bp+si+16],dx pop cx add si,2 loop s1 mov ax,4c00h int 21h Clear_Screen: push ax MOV AX,0003H INT 10H pop ax retcode endsend start","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"寻址法方式","slug":"微机系统/寻址","date":"2020-06-03T13:49:19.000Z","updated":"2020-07-09T08:04:17.734Z","comments":true,"path":"2020/06/03/ 微机系统/寻址/","link":"","permalink":"http://yoursite.com/2020/06/03/ 微机系统/寻址/","excerpt":"","text":"bx,si,di,bp 在8086CPU中，只有4个寄存器再用[…]`来进行内存的寻址。 可以使用4个寄存器单独出现，亦或，bx+si,bx+di,bp+si,bp+di 若使用bp，那么段地址默认为ss 若使用bx，那么段地址默认为ds 数据在哪 CPU内部 内存 端口 数据多长 寄存器指明数据尺寸 若无寄存器，则有word ptr或byte ptr指明，比如 1mov word ptr ds:[0],1 有些指令默认了数据尺寸，比如push只进行字操作。 Example 1 子程序 ret call 现场保存：stack 跳转 jmp jcxz how to show on the screen 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677assume cs:codedata segment db &apos;Welcome to masm!&apos;,0data endsstack segment dw 16 dup (0)stack endscode segment start: mov dh,8 mov dl,3 mov cl,2 mov ax,data mov ds,ax mov ax,stack mov ss,ax mov sp,32 mov si,0 call show_str mov ax,4c00h int 21h show_str: push ax push cx push dx push ds push si mov ah,0 mov al,dh mov dh,160 mul dh mov bx,ax;save the row mov ah,0 mov al,dl mov dl,2 mul dl mov cx,ax;save the column mov di,cx mov ax,0b800h mov es,ax mov si,0 mov al,cl s: mov cx,0 mov cl,ds:[si] jcxz q mov ch,al inc si mov es:[bx+di],cx add di,2 jmp s q: pop si pop ds pop dx pop cx pop ax retcode endsend start Example2 进行不会产生溢出的除法运算 其中cx存余数，dx存高16位商，ax存低16位商 123456789101112131415161718192021222324252627282930313233343536373839assume cs:codestack segment dw 16 dup(0)stack endscode segment start: mov ax,stack mov ss,ax mov sp,32 mov ax,4240h mov dx,000fh mov cx,0ah call divdw mov ax,4c00h int 21h divdw: push bx mov bx,ax mov ax,dx mov dx,0 div cx push ax mov ax,bx div cx mov cx,dx ;保存余数 pop dx;得到高位的商 pop bx ret code endsend start Example3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102assume cs:codestack segment dw 16 dup(0)stack endsdata segment db 10 dup(0)data endscode segment start: mov ax,12666 mov bx,data mov ds,bx mov si,0 call dtoc mov dh,8 mov dl,3 mov cl,2 call show_str mov ax,4c00h int 21h dtoc: push ax push si mov bx,10 s1: mov dx,0 div bx mov cx,ax jcxz q1 add dl,30h mov ds:[si],dl inc si mov ax,cx jmp s1 q1: mov dl,0 mov ds:[si],dl inc si pop si pop ax ret show_str: push ax push cx push dx push ds push si mov ah,0 mov al,dh mov dh,160 mul dh mov bx,ax;save the row mov ah,0 mov al,dl mov dl,2 mul dl mov cx,ax;save the column mov di,cx mov ax,0b800h mov es,ax mov si,0 mov al,cl s: mov cx,0 mov cl,ds:[si] jcxz q mov ch,al inc si mov es:[bx+di],cx add di,2 jmp s q: pop si pop ds pop dx pop cx pop ax ret code endsend start","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"Debug环境设置","slug":"微机系统/汇编_DosBox","date":"2020-05-30T08:56:52.000Z","updated":"2020-07-09T08:02:55.788Z","comments":true,"path":"2020/05/30/ 微机系统/汇编_DosBox/","link":"","permalink":"http://yoursite.com/2020/05/30/ 微机系统/汇编_DosBox/","excerpt":"","text":"0x01 前期准备 安装DOSBox 设置盘符 当出现了-_的闪烁符号时候说明我们成功进入了debug中。 0x02 命令介绍以下所有命令均在debug模式下输入，即-_，并且，每一种命令不会导致控制寄存器指令指针IP的移动。 需要注意的是，Instruction Pointer存放下一次要取出指令的偏移地址（假设您没有直接指定地址） CS:IP指示下一条要取出的指令的实际地址。 IP不能由程序直接存取，由BIU来修改（BIU是什么？？？ 命令 作用 R 观看或修改寄存器的值 H 计算两个16进制数的和与差 D 显示内存区域的内容 E 改变内存单位的内容 F 使用指定值填充内存 M 将指定内存区域的数据复制到指定地址 C 比较两块内存的内容 S 搜索指定串 A 输入汇编命令 G 执行汇编指令 U 对机器代码反汇编 N 设置文件名，将汇编程序进行存盘 W 将文件写入磁盘 L 读入内存 T 执行汇编程序，单步跟踪 P 执行汇编程序，单步跟踪，但不会跟踪子程序或软中断 I 从计算机输入端口读取数据 O 向计算机输出端口输出数据 Q 回到DOS状态 可用Ctrl+S来暂停屏幕输出 以下转载 R命令的使用R命令作用：观看和修改寄存器的值。 在提示符“-”下输入以下命令：R。DEBUG将会显示出当前所有寄存器和标志位的状态。 接下来再输入命令RCX。在提示符“：”后输入100。该命令的作用是将寄存器CX的值设置为100（注意：DEBUG使用的是十六进制，这里的100相当于十进制的256。） 最后再执行R命令，观看修改后的寄存器值。 H命令的使用H命令作用：计算两个十六进制数的和与差。 在提示符“–”下输入以下命令：H 10 1。观看命令执行结果。 运行结果的前一个数是计算出来的和，后一个数是计算出来的差。计算结果均用十六进制形式表示。 D命令的使用D命令作用：显示内存区域的内容。 在提示符“–”下连续执行命令R、D、D。观看命令执行结果。 前面已经介绍过了，命令R的作用是显示当前寄存器的值。而命令D的作用是显示内存区域的内容，最左边是内存的起始地址，中间以十六进制的形式显示内存值，最右边是以ASCII码的形式显示内存值。每行最多显示16个字节的内容。 命令D可以带参数也可省略参数。设DEBUG启动时DS的值为X，当省略参数时，命令D显示内容以X：100为起始，每次显示128个字节的内容。以后再执行不带参数的命令D时，DEBUG将按上次的位置接着显示下去。 带参数时DEBUG能够显示指定地址范围的内容。带参数的方式有三种： 方式一：d [起始位置]。DEBUG从起始位置开始显示128个字节的内容。在提示符“-”下执行命令D 1AF5:100。观看命令执行结果。 方式二：d [起始位置] [结束位置]。DEBUG从起始位置开始一直显示到结束位置。在提示符“-”下执行命令D DS:100 1FF。观看命令执行结果。 方式三：d [起始位置] [L长度]，长度以L参数为标识。DEBUG从起始位置开始显示指定长度的内容。在提示符“-”下执行命令D DS:100 L10。观看命令执行结果。 E命令的使用E命令作用：改变内存单位的内容。 E命令的使用方式为：E [起始位置]。 在提示符“-”下输入以下命令：E 1AF5:100。 DEBUG首先显示[1AF5:0000]的内容00.，这时可以修改该字节的值。如果还要修改后续的内容，可以按空格键继续。当要跳过某个字节时，可以按连续的两个空格跳到后一个字节去。 F命令的使用F命令作用：使用指定的值填充指定内存区域中的地址。 F命令的使用方式为：F [范围] [填充列表]。 在提示符“-”下输入以下命令：F 1AF5:100 L20 1 2 3 4 5。执行命令D 1AF5:100观看命令执行结果。 说明：该命令是用字节序列01、02、03、04、05轮流填充从1AF5:100开始长度为20H的内存区域。 在提示符“-”下输入以下命令：F 1AF5:100 13F 41 42 43 44。 说明：该命令是用字节序列41、42、43、44轮流填充从1AF5:100开始一直到1AF5:13F的内存区域。 M命令的使用M命令作用：将指定内存区域的数据复制到指定的地址去。 M命令的使用方式为：M [范围] [指定地址]。 在提示符“-”下输入以下命令：M 1AF5:100 13F 1AF5:140。执行命令D 1AF5:100观看命令执行结果。 C命令的使用C命令作用：将两块内存的内容进行比较。 C命令的使用方式为：C [范围] [指定地址]，意思就是将指定范围的内存区域与从指定地址开始的相同长度的内存区域逐个字节进行比较，列出不同的内容。 在提示符“-”下输入以下命令：C 1AF5:100 13F 1AF5:140。由于两块内容完全相同，所以命令执行后没有任何显示。 在提示符“-”下输入以下命令：C 1AF5:100 107 1AF5:180，比较的区域长度为8个字节。命令执行后列出比较结果不同的各个字节。 S命令的使用S命令作用：在指定的内存区域中搜索指定的串。 S命令的使用方式为：S [范围] [指定串]。 在提示符“-”下输入以下命令：D 1AF5:100 11F。显示该区域的内存值。 在提示符“-”下输入以下命令：S 1AF5:100 11F 41 42 43 44。搜索该区域是否存在字节串41 42 43 44，并将搜索结果一一列出。 从执行结果可以看出，总共搜索到八处。 A命令的使用A命令作用：输入汇编指令。 以下的程序要在屏幕上显示“ABCD”四个字符。 首先用E命令将“ABCD$”四个字符预先放在内存CS:200处，然后执行A100命令输入汇编程序代码： MOV AX,CS MOV DS,AX MOV DX,200 MOV AH,9 INT 21 INT 20 （说明：前两行汇编指令用于将段寄存器CS的值赋给段寄存器DS。第三到第五行汇编代码的作用是显示以“$”为结尾的字符串。最后一行用于结束程序。 G命令的使用G命令作用：执行汇编指令。 G命令的使用方法是：G [=起始地址] [断点地址]，意思是从起始地址开始执行到断点地址。如果不设置断点，则程序一直运行到中止指令才停止。 在设置完示例九的的内存数据并且输入完示例九的程序后运行这些汇编代码。在DEBUG中执行命令G=100，观看运行结果。 汇编程序运行后在屏幕上显示出“ABCD”四个字符。 接下来在DEBUG中执行G=100 10B，意思是从地址CS：100开始，一直运行到CS：10B停止。观看运行结果。 命令执行后，不但显示出字符串“ABCD”，而且列出当前寄存器和标志位的值。 U命令的使用U命令作用：对机器代码反汇编显示。 U命令的使用方法是：U [范围]。如果范围参数只输入了起始地址，则只对20H个字节的机器代码反汇编。执行命令U100，观看反汇编结果。 执行命令U100 10B，观看反汇编结果。该命令的作用是对从100到10B的机器代码进行反汇编。 N命令的使用N命令作用：设置文件名，为将刚才编写的汇编程序存盘做准备。 以下的DEBUG命令序列作用将刚才的汇编程序存为磁盘的COM可执行程序。 D200 20F U100 10C N E:\\FIRST.COM RCX :110 W 第一和第二条命令的作用是检查一下刚才编写的汇编指令。第三条命令的作用是设置存盘文件名为E:\\FIRST.COM，第四条命令的作用是设置存盘文件大小为110H个字节。最后一条命令是将文件存盘。 文件存盘后执行E:\\FIRST.COM，观看存盘的可执行文件的运行效果。 W命令的使用W命令作用：将文件或者特定扇区写入磁盘。 在示例“N命令的使用”中已经实验了如何使用W命令将文件存盘。 在没有很好地掌握汇编语言和磁盘文件系统前，暂时不要使用W命令写磁盘扇区，否则很容易损坏磁盘文件，甚至破坏整个磁盘的文件系统。 L命令的使用L命令作用：从磁盘中将文件或扇区内容读入内存。 将文件调入内存必须先用DEBUG的N命令设定文件名。以下例子是将E:\\FIRST.COM读入内容。 N FIRST.COM L 观看调入程序的汇编代码可以使用DEBUG的U命令，用U100观看调入的COM文件。 读取磁盘扇区的方式是：L [内存地址] [磁盘驱动器号] [起始扇区] [扇区数]。“内存地址”指定要在其中加载文件或扇区内容的内存位置，如果不指定“内存地址”的话，DEBUG将使用CS寄存器中的当前地址。“磁盘驱动器号”指定包含读取指定扇区的磁盘的驱动器，该值是数值型：0=A，1=B，2=C等。“起始扇区”指定要加载其内容的第一个扇区的十六进制数。“扇区数”指定要加载其内容的连续扇区的十六进制数。 只有要加载特定扇区的内容而不是加载文件时，才能使用[磁盘驱动器号] [起始扇区] [扇区数]参数。 例如：要将C盘第一扇区读取到内存DS:300的位置，相应的DEBUG命令为L DS:300 2 1 1。但是由于Windows操作系统对文件系统的保护，这条命令可能会被操作系统禁止运行。 T命令的使用T命令作用：执行汇编程序，单步跟踪。 T命令的使用方式是T [=地址] [指令数]。如果忽略“地址”的话，T命令从CS:IP处开始运行。“指令数”是要单步执行的指令的数量。 以下示例对E:\\FIRST.COM进行单步跟踪。 N E:\\FIRST.COM L U100 10B R T=100 T 第一、二条命令是装入文件，第三条命令是列出程序反汇编代码，第四条命令是显示当前寄存器值，第五条命令是从CS:100处开始单步跟踪，第六条命令是继续跟踪后续的指令。 P命令的使用P命令作用：执行汇编程序，单步跟踪。与T命令不同的是：P命令不会跟踪进入子程序或软中断。 P命令的使用方式与T命令的使用方式完全相同。 I命令的使用I命令作用：从计算机输入端口读取数据并显示。 I命令的用法是I [端口地址]。例如从3F8号端口读取数据并显示的命令为：I 3F8。这里不对该命令做解释。 O命令的使用O命令作用：向计算机输出端口送出数据。 O命令的用法是O [端口地址] [字节值]。例如向278号端口发出数据20H的命令为：I 278 20。这里不对该命令做解释。 Q命令的使用Q命令的作用是退出DEBUG，回到DOS状态。","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"Loop_程序实例","slug":"微机系统/汇编_Loop_多段","date":"2020-05-30T08:56:52.000Z","updated":"2020-07-09T08:03:18.295Z","comments":true,"path":"2020/05/30/ 微机系统/汇编_Loop_多段/","link":"","permalink":"http://yoursite.com/2020/05/30/ 微机系统/汇编_Loop_多段/","excerpt":"","text":"Loop 计算$2^{11}$ 1234567891011assume cs:codecode segment mov ax,2 mov cx,11 s: add ax,ax loop s mov ax,4c00h int 21h code endsend 其中 s标识了一个地址，这个地址处有一条指令add ax,ax loop s,CPU进行2步操作 (cx)— 判断cx是否为0，若cx不为0，则转到s，反之，顺序执行。 track:当我们使用1字节的数据对1字的寄存器赋值的时候，可以使用另外一个1字的寄存器作为媒介来获得所需要的数据 计算$([0006h])^{11}$ 1234567891011121314151617assume cs:codecode segment mov ax,0ffffh mov ds,ax mov sp,0006h mov ah,0h mov al,[6h] mov cx,3 mov dx,0 s: add dx,al loop s mov ax,4c00h int 21h code endsend 累加ffff:0000~ffff:000A单元中的数据的和，结果存储在dx中 123456789101112131415161718assume cs:codecode segment mov ax,0ffffh mov ds,ax ;初始化把 ds设置好 mov bx,0h ;基址寄存器初始化，为了偏移地址寻址 mov cx,12 ;计数器初始化 mov ah,0 mov dx,0 ;初始化 s: mov al,[bx] add dx,ax inc bx loop s mov ax,4c00h int 21h code endsend 多段程序 若我们需要使用到自己所需要的数据，而这些数据初始信息并非内存，而是实实在在的数据 1assume 其中，我们来讨论下end的作用： 通知编译器程序结束 通知编译器 这段程序的入口在上面地方 我们不妨再来讨论以下可执行文件bin的执行过程 由其他程序将可执行文件加载如内存 设置CS:IP指向程序的第一条指令的位置 程序运行结束，返回到加载者位置。 eg：将数据0123h…0987h逆序存储到原来的位置。 123456789101112131415161718192021222324252627assume cs:codesgcodesg segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 start: mov ax,cs mov ss,ax mov sp,30h mov bx,0 mov cx,8 s:push cs:[bx] add bx,2 loop s mov bx,0 mov cx,8 s0:pop cs:[bx] add bx,2 loop s0 mov ax,4c00h int 21h codesg endsend start 其中，23这个字节数据保存在偏移地址为0的位置。 eg 将文本大写化123456789101112131415161718192021222324assume cs:codesg,ds:datasgdatasg segment db &apos;BaSiC&apos; datasg endscodesg segment start: mov ax,datasg mov ds,ax mov bx,0 mov cx,5 s: mov al,[bx] and al,11011111B mov [bx],al inc bx loop s mov ax,4c00h int 21h codesg endsend start 一个综合练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121assume cs:codesg data segmentdb &apos;1975&apos;, &apos;1976&apos;, &apos;1977&apos;, &apos;1978&apos;, &apos;1979&apos;, &apos;1980&apos;, &apos;1981&apos;, &apos;1982&apos;, &apos;1983&apos;db &apos;1984&apos;, &apos;1985&apos;, &apos;1986&apos;, &apos;1987&apos;, &apos;1988&apos;, &apos;1989&apos;, &apos;1990&apos;, &apos;1991&apos;, &apos;1992&apos;db &apos;1993&apos;, &apos;1994&apos;, &apos;1995&apos; dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226dw 11542, 14430, 15257, 17800data ends table segmentdb 21 dup (&apos;year summ ne ?? &apos;)table endsstack segmentdw 8 dup(0)stack endscodesg segment start: mov ax,data mov es,ax mov ax,table mov ds,ax ;初始化 getyear: mov bx,0 mov bp,0 mov cx,15h s11: mov si,0 mov dx,cx mov cx,4 s12: mov al,es:[bp] mov ds:[bx+si],al inc bp inc si loop s12 mov cx,dx add bx,10h loop s11 getspace: mov bx,0 mov cx,15h space1: mov al,&apos; &apos; mov ds:[bx+4],al add bx,10h loop space1 mov bx,0 mov cx,15h getincome: mov ax,es:[bp] mov ds:[bx+5],ax add bp,2 mov ax,es:[bp] mov ds:[bx+7],ax add bp,2 mov al,&apos; &apos; mov ds:[bx+9],al add bx,10h loop getincome mov bx,0 mov cx,15h getnum: mov ax,es:[bp] mov ds:[bx+0ah],ax add bp,2 mov ax,&apos; &apos; mov ds:[bx+0ch],al add bx,10h loop getnum mov bx,0 mov cx,15h getaverage: mov ax,ds:[bx+5] mov dx,ds:[bx+7] div word ptr ds:[bx+0ah] mov ds:[bx+0dh],ax mov al,&apos; &apos; mov ds:[bx+0fh],al add bx,10h loop getaverage mov ax,4c00h int 21hcodesg endsend start","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"线性代数概知","slug":"MachineLearning/线性代数","date":"2020-05-28T08:56:52.000Z","updated":"2020-06-03T13:43:48.337Z","comments":true,"path":"2020/05/28/ MachineLearning/线性代数/","link":"","permalink":"http://yoursite.com/2020/05/28/ MachineLearning/线性代数/","excerpt":"","text":"矩阵初等变换 倍法变换：某行*非零的数 消法变换：某行*某数加到另外一行 换法变换：交换两行","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/categories/Machine-Learning/"}],"tags":[]},{"title":"","slug":"MachineLearning/图像","date":"2020-05-17T12:53:29.119Z","updated":"2020-06-03T13:43:16.414Z","comments":true,"path":"2020/05/17/ MachineLearning/图像/","link":"","permalink":"http://yoursite.com/2020/05/17/ MachineLearning/图像/","excerpt":"","text":"图像插值方法 最近邻域法 双线性插值法 扫描矩阵的获取 映射矩阵的建立 扫描矩阵{S}=偏心运动矩阵*球面子孔路径矩阵","categories":[],"tags":[]},{"title":"计算方法","slug":"MachineLearning/计算方法","date":"2020-05-16T05:59:03.700Z","updated":"2020-06-03T13:42:55.279Z","comments":true,"path":"2020/05/16/ MachineLearning/计算方法/","link":"","permalink":"http://yoursite.com/2020/05/16/ MachineLearning/计算方法/","excerpt":"","text":"1 误差 误差计算 定义1.3 定理1.1 线性代数方程组的数值解 克莱姆法则 直接法 高斯消元法 迭代法，适用于系数矩阵为大型稀疏矩阵","categories":[{"name":"计算方法","slug":"计算方法","permalink":"http://yoursite.com/categories/计算方法/"}],"tags":[]},{"title":"web技术概知","slug":"Algorithm/Python","date":"2020-05-12T08:56:52.000Z","updated":"2020-05-20T07:02:46.598Z","comments":true,"path":"2020/05/12/ Algorithm/Python/","link":"","permalink":"http://yoursite.com/2020/05/12/ Algorithm/Python/","excerpt":"","text":"基础函数 按引用传递参数 面向对象 类 123456class Person(object): __slots__=('_name','_age','_gender')# #限定Person对象只能绑定_name,_age和_gender def __init__(self,name,age):#构造器 self._name=name self._age=age 网络编程 TCP/IP四层模型，网络接口层，网络层，传输层，应用层 IP为网际协议，服务于网络层。 TCP为传输控制协议 C/S模式和B/S模式，C指的是Client客户端，B指的是Browser浏览器，通过B或者C能对S（服务器）进行访问。C与S的对比？？？？？？？？？？？ 去中心化的网络应用模式 HTTP超文本传输协议，HTTPS超文本传输安全协议 XML 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;message&gt; &lt;from&gt;Alice&lt;/from&gt; &lt;to&gt;Bob&lt;/to&gt; &lt;content&gt;Will you marry me?&lt;/content&gt;&lt;/message&gt; JSON 12345&#123; \"from\": \"Alice\", \"to\": \"Bob\", \"content\": \"Will you marry me?\"&#125; （恐 Socket 什么是Socket? Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 import socket socket.socket(family,type,proto)来创建套接字。其中，family为AF_UNIX或者AF_INET；type为SOCK_STREAM或者SOCK_DGRAM；protocol一般为0 HTTP HTTP是基于客户端/服务端的架构模型 使用URL Uniform Resource Identifiers来传输数据和建立连接","categories":[{"name":"web技术","slug":"web技术","permalink":"http://yoursite.com/categories/web技术/"}],"tags":[]},{"title":"重读C++ Primer","slug":"重读C++ Primer","date":"2020-05-07T14:56:52.000Z","updated":"2020-05-20T06:07:52.336Z","comments":true,"path":"2020/05/07/ 重读C++ Primer/","link":"","permalink":"http://yoursite.com/2020/05/07/ 重读C++ Primer/","excerpt":"","text":"列表初始化vector是如何增长的​ 容器内元素是连续存储的，若容器需要的空间大于现在位置所拥有的空间，那么vector会执行一次内存分配和内存释放操作。而标准库的实现者为了重新分配的次数减少，每次重新分配时都会分配比需求更大的内存空间。 栈内存 静态内存 动态内存 deque是如何增长的 deque是list与vector这两个顺序容器的结合体。 不过在进行中间元素的插入和删除的时候，其效率远远低于list和vector，这也是其使用复杂的迭代器框架所带来的代价。 支持随机访问。 前端插入与删除效率比vector高。 插入与删除不会导致重新分配空间。 使用动态内存的原因 程序不知道自己需要使用多少对象 程序不知道所需对象的准确类型 程序需要在多个对象间共享数据 区分 string *ps1=new string string *ps2=new string() int *pi1=new int int *pi2=new int() 智能指针 shared_ptr&lt;int&gt;p=make_shared&lt;int&gt;(10); auto p=make_shared&lt;int&gt;(10); 引用计数reference count，每拷贝一次shared_ptr，计数器加一。 当reference count变为0时，自动销毁。 不要混用shared_ptr和内置指针 动态数组 动态数组不是数组类型 int *pia=new int[10]; pia[1]=10; cout&lt;&lt;pia[1]&lt;&lt;endl; delete [] pia; unique_ptr支持动态数组，shared_ptr不支持管理动态数组，因为shared_ptr没有动态数组的删除器。 泛型算法初识 123456string sum =accumulate(V.cbegin(),V.cend(),string(\"\"));//正确string sum =accumulate(V.cbegin(),V.cend(),\"\");//错误，const char *上没有定义+运算符 容器适配器 容器，迭代器，函数都有适配器。本质上，一个适配器是一种机制，使得事物的行为看起来像另外一种事物。 默认情况下stack和queue是基于deque实现；而priority_queue则是基于vector实现。","categories":[{"name":"Read","slug":"Read","permalink":"http://yoursite.com/categories/Read/"}],"tags":[]},{"title":"一些指令","slug":"微机系统/指令合集","date":"2020-04-23T08:56:52.000Z","updated":"2020-07-09T08:04:36.903Z","comments":true,"path":"2020/04/23/ 微机系统/指令合集/","link":"","permalink":"http://yoursite.com/2020/04/23/ 微机系统/指令合集/","excerpt":"","text":"控制转义指令 指令 描述 举例 JZ jump if zero JZ AA1 JNZ jump if not zero JNZ AA1 JNC jump if not carry(进位) JNC DST INT n n为中断的类型码 INC increase 1 INC a SHL Shift Logical Left SHL DST 1 中断指令 INT n 其中n为8位无符号数，触发类型码为n的中断 INT 21H 系统功能调用 AH 为功能调用编号 设置入口参数 CPU执行INT 21H 给出出口参数 | AH | 功能 | 入口参数 | 出口参数 || —— | ——————— | —————- | —————- || 01 | 键盘键入并回显 | 无 | AL=输入字符 || 02 | 显示输出 | DL=输出字符 | 无 || 4C | 带返回码终止 | AL=返回码 | 无 | [Debug]https://blog.csdn.net/liuer2004_82/article/details/52638516 DOSBox 动态CPU内核：具备i386指令集合的系统，能利用动态指令转换。 其中i386处理器为32位系统，地址线为32位；采用Cache来解决内存速度瓶颈问题。 注意 ffffh是错误的表示，永远不要第一个数值为字母，应该为0ffffh. 若使用dl来累加，当数值范围1个字节所能表示的范围即8位，CPU不会进位到dh，而是直接抹去。 [bx]，表示bx中存放的偏移地址EA。但是在ax,cx,dx不能进行如是的操作。我们也能从这些寄存器的名字看出。 段前缀：用于显式地指明内存单元的段地址 assume的时候，即使ds:data，那么ds进入code的时候(ds)也不一定未(data)","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"寄存器名称概析","slug":"微机系统/寄存器概析","date":"2020-04-11T14:56:52.000Z","updated":"2020-07-12T12:53:30.351Z","comments":true,"path":"2020/04/11/ 微机系统/寄存器概析/","link":"","permalink":"http://yoursite.com/2020/04/11/ 微机系统/寄存器概析/","excerpt":"","text":"从入门到入土 字长， 主频，CPU的时钟频率，决定计算机运算速度 CISC，Complex Instruction Set Computer RISC，Reduced Instruction Set Computer 发展 8086 AX,Accumulator Register，累加器 BX,Base Register，基址寄存器 CX,Counter Register，计数器 DX,DataRegister，数据寄存器 SP,Stack Pointer，堆栈指针 BP,Base Pointer，基址指针 SI,Source Index，源变址寄存器 DI,Destination Index，目的变址寄存器,其中，SI与DI隐含使用 CS,Code Segment，代码段寄存器 SS,Stack Segment，堆栈段寄存器 DS,Data Segment，数据段寄存器 ES,Extra Segment，附加段寄存器 IP,Instruction Pointer，指令指针，CS:IP在地址加法器中形成物理地址，由BIU修改，不能直接修改 FL,flag，标志寄存器 CF,Carry Flag，进位或错误标志，CF=1,否则CF=0 PF,Parity Flag，低8位结果偶数个1，PF=1，否则PF=0 AF,Auxiliary Carry Flag，D3有进位或借位，AF=1 ZF,Zero Flag，结果为0，ZF=1 SF,Sign Flag，结果为正，SF=0 OF,Overflow Flaw，有符号数算数运算超出表示范围，OF=1 DF,Dirction Flag IF,Interrupt Enable Flag TF,Trap Flag Prntium可由8086的16位寄存器变为32位的寄存器如，AX-&gt;EAX通用寄存器 AX,Accumulator Register，累加器 BX,Base Register，基址寄存器 CX,Counter Register，计数器 DX,DataRegister，数据寄存器 SP,Stack Pointer，堆栈指针 BP,Base Pointer，基址指针 SI,Source Index，源变址寄存器 DI,Destination Index，目的变址寄存器,其中，SI与DI隐含使用 段寄存器段寄存器可用于作为段前缀 CS,Code Segment，代码段寄存器 SS,Stack Segment，堆栈段寄存器 DS,Data Segment，数据段寄存器 ES,Extra Segment，附加段寄存器 FS，附加段寄存器 GS，附加段寄存器 IP,Instruction Pointer，指令指针，CS:IP在地址加法器中形成物理地址，由BIU修改，不能直接修改 FL,FR,flag，标志寄存器 CF,Carry Flag，进位或错误标志，CF=1,否则CF=0 PF,Parity Flag，低8位结果偶数个1，PF=1，否则PF=0 AF,Auxiliary Carry Flag，D3有进位或借位，AF=1 ZF,Zero Flag，结果为0，ZF=1 SF,Sign Flag，结果为正，SF=0 OF,Overflow Flaw，有符号数算数运算超出表示范围，OF=1 DF,Dirction Flag IF,Interrupt Enable Flag TF,Trap Flag 系统级寄存器系统地址寄存器 GDTR,Global Descriptor Table Register，全局描述符表寄存器 IDTR,Interrupt Descriptor Table Register，中断描述符表寄存器 LDTR,Local Descriptor Table Register，局部描述符表寄存器 TR,Task Register，任务状态寄存器 控制寄存器 CR0 CR1 CR2 CR3 CR4 总线周期 工作时序 时钟周期 总线周期 指令周期 总线请求 总线响应 中断响应 中断响应周期 8086时钟状态 寻址 立即数 寄存器 存储器 存储器寻址 Effective Address,EA，有效地址，偏移地址 Pentium保护模式及存储管理 GDT，全局描述符表，系统只有一个 LDT，局部描述符表，每个任务一个 IDT，中断描述符表，保存门描述符，整个系统一个 TSS,Task State Segment，任务状态段，每个任务一个 保护模式分类 任务间存储空间保护 段属性和界限保护 特权级与特权级保护 特权管理 CPL,Current Privilege Level，即代码段描述符中的DPL。 DPL,Descriptor Privilege Level，保存在该段的段描述符的特权级位。 RPL,Request Privilege Level，新装入段寄存器的段选择符的特权级。 高特权级可访问特权级低的数据，低特权级可调用特权级高程序。 段间转移 任务内转移 段内 NEAR，改变IP，检查目标指令位置是否超出段长 段间 FAR，从一个段到另外一个段（跳转？中断？） 同一特权级，直接转移，可使用段描述符实现 不同特权级，间接转移，可使用调用门调用，使用中断门/陷阱门中断 任务间切换 直接，给任务寄存器TR送一个段选择符，然后TR找到TSS描述符，找到对应的段。 间接，给TR送一个段选择符，然后TR找到任务门描述符，找到对应段。 分页 PWT ,P Write Through PCD, P，若P=0，那么为该页在主存中不存在 IN/OUT DMA，Direct Memory Access 外设-&gt;DMA-&gt;CPU","categories":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/categories/汇编/"}],"tags":[]},{"title":"组合数学","slug":"Math/组合数学","date":"2020-04-06T14:56:52.000Z","updated":"2020-06-12T09:23:19.807Z","comments":true,"path":"2020/04/06/ Math/组合数学/","link":"","permalink":"http://yoursite.com/2020/04/06/ Math/组合数学/","excerpt":"","text":"1n阶幻方，其幻和为： \\frac {n*(1+n^2)}{2}存在性：存在除2阶外的任意阶幻方。 计数与分类：奇数阶幻方；4n阶幻方；4n+2阶幻方。 构造方法：见课本 优化问题：略 2鸽巢原理 Ramsey定理 3线排列 圆排列 n元素集合的$r-$圆排列数为 \\frac {1}{r}P(n,r)=\\frac {n!}{r(n-r)!}集合的排列数和组合数 多重集合的排列 M=\\{ \\infty \\cdot a_1,\\infty \\cdot a_2...\\infty \\cdot a_n\\}的r-排列数是n^r\\\\ M=\\{ k_1\\cdot a_1,k_2\\cdot a_2...k_n\\cdot a_n\\}的全排列数为\\frac {(k_1+k_2...+k_n)!}{k_1!k_2!...k_n!}常利用公式(4)和分类法来解题目 多重集合的组合 M=\\{ \\infty \\cdot a_1,\\infty \\cdot a_2...\\infty \\cdot a_n\\}的r-组合数为\\dbinom{n+r-1}{r} M=\\{ \\infty \\cdot a_1,\\infty \\cdot a_2...\\infty \\cdot a_n\\},r \\geq n,则M中每一个元素至少取一个的r-组合数为 \\dbinom{r-1}{n-1}排列的生成 ​ (a) 邻位互换法，要得到${1,2…n}$的全排列，可以先得到${1,2…n-1}$的全排列，然后将n插入到其排列中。 ​ 活动状态：当一个数上方的箭头所指的一侧，相邻的数比该数小，那么该数处于活动状态。 ​ (b) 字典序法 $x_1+x_2…+x_n=r$的非负整数解集个数为：$\\frac{(n+r-1)!}{(n-1)!*r!}=\\dbinom{n+r-1}{r}$ 其中，$x_i\\geq 0$ 二项式定理 {(x+y)}^n=\\dbinom{n}{0}x^0y^n+\\dbinom{n}{1}x^1y^{n-1}...+\\dbinom{n}{n-1}x^{n-1}y^1+\\dbinom{n}{n}x^ny^0，其中n\\geq 0 \\dbinom{n}{k}\\\\ (1)\\ \\dbinom{n}{k}=\\dbinom{n}{n-k} \\\\ (2)\\ \\dbinom{n}{k}=\\dbinom{n-1}{k}+\\dbinom{n-1}{k-1}\\\\ (3)\\ \\dbinom{n}{\\frac{n}{2}}为max\\\\牛顿二项式容斥原理0x01 定义$S中不具有性质P_1,P_2\\dots,P_m的元素个数为$​ |\\overline{A_1}\\cap\\overline{A_2}\\cap\\dots\\cap\\overline{A_m}|\\\\=|S|-\\sum_{ i= 1}^{m}|A_i|+\\sum_{1\\leq i","categories":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/categories/组合数学/"}],"tags":[]},{"title":"Linux","slug":"Linux","date":"2020-04-04T14:56:52.000Z","updated":"2020-06-03T13:42:04.147Z","comments":true,"path":"2020/04/04/ Linux/","link":"","permalink":"http://yoursite.com/2020/04/04/ Linux/","excerpt":"","text":"VICommand$:wq，保存并退出$ $:w,保存$ $:w \\ filename,另存为filename$ $:wq!,保存强制退出$ $gg,使光标到文件头$ $G,使光标移到文件尾$ $nG,使光标移到第n行$ $ab,缩写，unab，取消缩写$ $宏操作符，map，unmap,取消宏\\ page 98$ $u,撤销最近的操作$ 文件$command\\ source\\ target$ 创建文件$mkdir\\ filename,创建目录$ 移除文件 rm filename 移除文件 rm -rf /test 移除非空目录/test 复制文件$cp\\ filename1\\ filename2$ $cp\\ filename\\ list$ $cp\\ -r\\ list1(or\\ filename)\\ list2,若list2不存在则创建$ 移动文件$mv\\ filename\\ list$ $mv\\ filename1\\ filename2,将filename1文件名改为filename2$ 链接文件 寻找文件 $find\\ page125$ 计算字数 $wc\\ filename,显示：行数(-l)，单词数(-w)，字符数(-c)$ 输出重定向，运行用户把进程的输出保存在文件中，然后，用户可以编辑，打印或者作为其他进程的输入。 $command \\ &gt; \\ filename\\ 若有，则覆盖\\command\\ &gt;&gt;\\ filename，若有，则添加到文件结尾$ $cat\\ &gt; filename,创建文件，但输入时无法修改，若有，则覆盖\\cat\\ &gt;&gt;\\ filename,创建文件，但输入时违法修改，若有，则添加到文件结尾$ $cat\\ filename1\\ &gt;\\ filename2\\cat\\ filename1\\ filename2…\\ filenamei\\ &gt;&gt;\\ target$ 显示文件 $head\\ -n\\ filename,显示文件的前n行$ $tail\\ -n\\ filename,显示文件的后n行$ $tail\\ -n +10\\ filename|head -n\\ 10,显示第10-20行$ 查找文件 $find\\ . -name \\ filename,寻找名为filename的文件$ $find\\ . \\ -name\\ filename\\ -exec\\ -cp\\ {}\\ file\\ \\verb|| ;,寻找名为filename的文件并且复制到file文件夹中$ $eg: ls &gt;&gt; a,who &gt;&gt; a,date &gt;&gt; a$ ShellShell 变量 环境变量，即标准变量，由系统管理员定义 局部变量，由用户定义 shell对于所有分配给变量的值按字符对待 kill 用户只能关闭自己的进程，root可以关闭所有进程 终止一个前台进程^C SIGKILL由kill -9发送 SIGINT由^C发送 SIGTERM由kill -15orkill发送 SIGHUP挂起信号，关闭终端时会产生 tee 分离输出 多重输出 tee命令和|一起使用实现分离输出 ls -C | tee file expr 算术运算 123 $expr 1 + 12 $x=`expr $x +1 ` 选项 -a 不覆盖原来内容 -i 不响应中断 ps 查看进程表 ./won表示在全局范围内搜索命令 won表示在PATH中搜索命令 1234cat byeexitchmod u+x bye./bye 全局变量PS1，用于编辑命令行的格式 \\d \\H \\h \\t \\T \\A \\u \\v \\w \\W # $ help 是bash的内置命令，用于记录bash的内置命令和关键字 man 是全系统的文档系统，用于与查看命令联机帮助页 info 是源自GNU项目的另外一个文档系统 正则表达式元字符关机 halt shut down poweroff 注意，init 0只能作为超级用户使用的关机，实际上init 0只是将当前运行级别更改为0 grep 文件内容查找 echo 输出指定字符串或变量 -e：激活转义字符 消除元字符：\\ &quot; &quot; &#39; &#39; 因为反斜杠是元字符的一种，所以在激活转义字符的时候需要消除转义字符中的反斜杠的影响 ls ls ~ 显示当前用户主目录的内容 cd cd 回到HOME变量所设置的主目录 Linux文件名长度限制是255个字符 clear Ctrl-L \\033c test 元字符 `command`命令替换符 转义字符","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"随机数学","slug":"Math/概率论与数理统计","date":"2020-04-03T04:42:33.000Z","updated":"2020-05-22T06:33:20.578Z","comments":true,"path":"2020/04/03/ Math/概率论与数理统计/","link":"","permalink":"http://yoursite.com/2020/04/03/ Math/概率论与数理统计/","excerpt":"","text":"随机事件及其概率引入随机试验，简称为试验；若均满足：可重复性；可观测性；随机性。 $E:$ 试验 $w$: 样本点 $\\Omega = ${ $w_1,w_2…w_i$ } : 样本空间 $A$，其中$A\\subseteqq \\Omega$: 事件 {$w_i$} : 基本事件 $\\Omega$: 必然事件 $\\phi$: 不可能事件 若 试验结果 $w\\in A$,则称事件A发生 事件的关系$A\\subseteqq B $: 包含 $A=B$: 相等 互斥： 不能同时发生 $\\bar{A}=B$: 互逆，对立 事件的运算$A\\cup B=${$w|w\\in A或w\\in B$} $A\\cap B或AB=${$w|w\\in A或w\\in B$} $A-B=${$w|w\\in A且 w\\notin B$} $\\overline {A\\cup B}=\\overline A\\cap \\overline B$ $\\overline {A\\cap B}=\\overline A\\cup \\overline B$ $n_A$: 事件A发生的频数 $f_n(A)$: 事件A发生的频率 $其中 f_n(A)=\\frac{n_A}{n}$ 减法公式：$P(B-A)=P(B)-P(AB)$ 加法公式：$P(A\\cup B)=P(A)+P(B)-P(AB)$ 古典概型：有限个样本点；基本事件发生的可能性相同。几何概型条件概型$P(B|A)=\\frac{P(AB)}{P(A)} \\Longrightarrow P(AB)=P(A)P(B|A)$ 条件概型的性质：非负性；规范性：$P(\\Omega |A)=1$；可列可加性：对于不相容的事件$B_1,B_2,\\cdot \\cdot \\cdot $有 P((\\cup_{i=1}^\\infty B_i )|A)=\\sum_{i=1}^\\infty P(B_i|A)全概率公式： P(B)=\\sum\\limits_{i=1}^nP(A_i)P(B|A_i)其中： \\cup _{i=1} ^n A_i=\\Omega 且 \\cap _{i=1} ^n A_i=\\Phi推导： 对任意事件B，有 B=B\\cap \\Omega =B\\cap (\\cup _{i=1} ^n A_i)=\\cup _{i=1} ^n {A_iB} 由条件概型的性质可得全概率公式。若某问题可画出概率树，那么该问题属于条件概型，甚至符合全概率公式。 贝叶斯公式： P(A_j|B)=\\frac{P(A_jB)}{P(B)}=\\frac{P(B|A_j)P(A_j)}{\\sum_{i=1}^nP(A_i)P(B|A_i)}独立性如果 P(AB)=P(A)P(B)\\\\ P(\\overline{A}B)=P(\\overline{A})P(B)\\\\ P(\\overline{A}\\overline{B})=P(\\overline{A})P(\\overline{B})则称事件A与事件B相互独立。 伯努利若某试验$E$是n重伯努利试验，即试验$E$只有两个对立的结果，将其进行n次。设$P(A)=p$。 有 P_n(k)=(_k^n)p^k(1-p)^{n-k}=C_n^kp^k(1-p)^{n-k}随机变量及其概率分布随机变量性质： $P${$a&lt;X\\leq b$}$=P{ X\\leq b}-P{ X\\leq a}=F(b)-F(a)$ 单调不减 $F(-\\infty )=lim_{x\\rightarrow -\\infty }F(x)=0$ $F(+\\infty )=lim_{x\\rightarrow +\\infty }F(x)=1$ F(x)是右连续的，即$F(x^{+})=F(x)$ 离散型随机变量两点分布 二项分布，伯努利试验记作$X ~B(n,p) X在(n+1)p处取得最大值$ 几何分布 泊松分布： P\\{ X=k\\}=\\frac{\\lambda ^ke^{-\\lambda}}{k!}\\\\ 其中，\\lambda为服从参数,记作X P(\\lambda)连续型随机变量均匀分布 f(x)=\\left\\{ \\begin{array}{lr} \\frac{1}{b-a},a0\\\\ 0&x\\leq0\\\\ \\end{array} \\right.\\\\其中，\\lambda>0是常数，称为X服从参数为\\lambda的指数分布\\\\正态分布$N(\\mu ,\\sigma^2)$有概率密度函数 f(x)=\\frac{1}{\\sqrt{2\\pi }\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}},-\\infty","categories":[{"name":"随机数学","slug":"随机数学","permalink":"http://yoursite.com/categories/随机数学/"}],"tags":[]},{"title":"Java核心技术i","slug":"Java核心技术i","date":"2020-04-02T14:56:52.000Z","updated":"2020-04-20T07:02:25.771Z","comments":true,"path":"2020/04/02/ Java核心技术i/","link":"","permalink":"http://yoursite.com/2020/04/02/ Java核心技术i/","excerpt":"","text":"$\\lambda 表达式形式：参数，箭头 (-&gt;) 以及一个表达式$ 无需指定$\\lambda 表达式的返回类型$ 只有当$\\lambda$表达式的体只调用一个方法而不做其他操作时，才能把$\\lambda$表达式重写为方法。page248 $\\lambda$就是闭包 $\\lambda$捕获的变量是事实最终变量$effectively\\ final$ $exception\\ handing ,异常处理 \\ throw\\ 抛出\\ exception\\ handler\\ 异常处理器$ $只需要声明\\ IOException,检查型(checked)异常$ $i.找到一个合适的异常类\\ ii.创建这个类的一个对象\\ iii.将对象抛出$ 集合迭代器·Iterator接口123456public interface Interator&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemain(Consumer&lt;? super E&gt; action);&#125; CollectionQueue实现方式 循环数组 链表 MapIO流 字节流在直接在文件中操作，字符流需要使用缓冲区","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Linux复习","slug":"Linux复习","date":"2020-04-02T14:56:52.000Z","updated":"2020-06-19T16:42:46.978Z","comments":true,"path":"2020/04/02/ Linux复习/","link":"","permalink":"http://yoursite.com/2020/04/02/ Linux复习/","excerpt":"","text":"0x01 计算机分类 巨型计算机 大型计算机 小型计算机 微型计算机 计算机基本组成 输入 处理 输出 存储 计算机的硬件模块 输入设备 处理器单元 算术逻辑单元 寄存器 控制单元 内存 随机存储器 RAM Random Access Memory，不能提供永久存储，当电源中断时，内容丢失 只读存储器 ROM Read Only Memory，用于永久保存产商放置在系统中的程序和数据，不能修改 外部存储器 输出设备 操作系统模型 硬件 内核 服务层 命令层shell 用户层 0x02 UNIX最初用汇编语言开发 汇编语言编写的程序是与机器相关的 1973年,Ken和Dennis成功用C语言重写了UNIX，其中95%为C语言，只有很少部分是汇编语言代码 UNIX2个主要版本 AT&amp;T UNIX系统V，本书讨论的命令适用于SVR4,UNIX System V Release 4 Berkeley UNIX，其版本称为BSD,Berkeley Software Distribution 其他的UNIX变种都是基于这两个版本 一些其他的变种，几乎所有的变种都是基于系统V AIX -&gt;IBM公司开发 HP-UX-&gt;惠普公司 LINUX-&gt;芬兰赫尔辛基大学的学生Linux Torvalds的想法 Solaris也称SunOS-&gt;Sun公司基于V第2版和BSD4.3开发 UnixWare，Novell 公司开发，后来卖给了Santa Cruz Operation公司 UNIX模型 内核 常驻模块 工具层，Shell 虚拟计算机 进程 UNIX特性 可移植 多用户 多任务 多级文件系统 与设备独立的输入输出操作 用户界面Shell 0x03 登录 修改口令 passwd 口令格式 新口令与旧口令3个字符不同 长度至少6个字符，至少2个字母和1个数字 不能与用户标识相同 退出系统 [Ctrl-d] 在没有退出系统前关闭终端电源并没有结束用户与UNIX系统的交互 基本的命令行格式 命令名 命令选项 命令参数 字段间用1个或多个空格隔开 UNIX系统对大小写敏感 一些命令 who，列出当前登录系统的所用用户登录名，终端号，登录时间 who am i，显示本终端用户的信息 cal显示日历表 cal 2 2001显示2001年2月的日历表 cal 2001显示2001年的日历表 learn 包括若干课程的计算机辅助教学程序 help 提供多级菜单来引导用户学习命令 man 显示在线系统文档的内容，man cal可以查找cal的帮助信息 中断程序运行，[Del]或[Ctrl-c]中断键 Shell种类 Bourne shell Korn shell是Bourne shell的超集 C shell是BSD UNIX的一部分 登录过程12345678910st=&gt;start: UNIX系统启动，操作系统的内核装入内存op1=&gt;operation: 用户登录，shell 程序装入内存op2=&gt;operation: init程序为系统的每一个终端端口激活getty程序op3=&gt;operation: getty程序在相应终端上显示login，并等待用户输入op4=&gt;operation: 若登录成功，进入shell程序op5=&gt;operation: 若用户退出程序，shell终止op6=&gt;operation: UNIX在终端启动一个新的getty程序并等待新用户登录e=&gt;end: 结束st-&gt;op2-&gt;op3-&gt;op4-&gt;op1-&gt;op5-&gt;op6-&gt;e 0x04 vi编辑器 编辑器 行编辑器，如emacs，ex 全屏编辑器，如vi 发展过程ed-&gt;ex-&gt;vi，其中vi由ex发展而来 vi的两个版本 view编辑器 vedit编辑器 vi的工作模式 命令模式 文本输入模式 缩写ab 缩写的指定是临时的，它们只是在当前编辑会话中有效 宏map map给用户在命令模式下的捷径 供用户可用的键只有少数几个K,q,V,[Ctrl-e],[Ctrl-e] 宏的指定是临时的，它们只是在当前编辑会话中有效 设置.exrc 欲设置编辑器环境启动有效，则将设置的环境写到.exrc中，其启动原理为 121.用户打开vi编辑器2.vi根据当前工作目录的.exrc文件设置编辑环境(若无则查找用户主目录,否则为默认环境) 在vi编辑器中允许UNIX Shell命令，: !+命令 行连接J 搜索和替换 命令模式 文本输入模式 0x05 文件系统 分类 规则文件 目录文件 特殊文件，即，设备 一些奇怪的目录说法 用户主目录 根目录，根目录用/命名 工作目录 文件名 最大长度取决于UNIX的版本和系统厂商 所有UNIX系统允许至少14个字符长的文件名，大多数可支持长达255个字符的长度 字母数字组合 输出重定向 输入重定向 0x06 shell UNIX操作系统组成 内核 应用 用户与操作系统通过shell进行通信，而基于硬件的操作由内核完成。 shell主要特征 命令执行 文件名替换 I/O重定向 管道 环境控制 后台计算 shell脚本 引用字符，用于消除元字符的特殊含义 反斜杠\\ 双引号&quot; &quot;：不可消除$，单引号，双引号，! 单引号&#39;&#39;：不可消除单引号 shell变量 环境变量，即标准变量 局部变量 若变量中有空格，需要使用引用字符 一些shell变量 PATH变量设置shell在定位命令时所查找的目录名 PS1变量设置用户提示符字符串 PS2变量设置用户尚未键入完整命令前安回车键的命令提示符 CDPATH变量设置cd命令所查找的的目录 SHELL变量设置用户登录shell的完整路径 TERM变量设置用户终端类型 TZ变量设置用户所在时区 更多的元字符 1234567891011121314151617181920 - `;`，可以键入多个命令用分号隔开 - `( )`，命令编组 - `&amp;`，后台计算，一个命令其后紧跟`&amp;`- 更多的`UNIX`系统工具 - 延时计时，`sleep`命令 - `ps`，显示PID - `nohup` - `kill`，终止一个进程，即向指定的线程发送一个信号 - `tee`，分离输出 - ep ```shell sort phone.list | tee phone.sort 解释：管道将sort命令的输出给tee，tee显示到终端和保存到phone.sort grep，文件搜索 sort，文本文件排序，按行将指定文件内容排序。若有2行第一个字符相同，则比较第2个字符…以此类推 export，将本shell变量可用于其子shell echo，其中-e激活转义字符 启动文件 即用户在登录时，shell查看这2个特殊文件，并执行2个文件中的命令 系统策略/etc/profile 用户策略，位于用户主目录的.profile文件 0x07 shell 编程 shell会忽略以#开头的行 执行脚本 使用sh命令，即调用另外一个shell来读取文件，执行命令 将脚本:footprints:变成可执行文件，chmod命令 转义字符 执行命令.，使用户在当前shell允许程序，而不创建新的子进程。 想使用的PATH长期有效，则将改变后的PAHT放到.profile中。 读取输入read 命令行参数 使用特殊shell位置变量 赋值set命令 exit n，终止程序，若没有提供退出值n，那么通常赋值最后一个命令的退出值 条件与试验 if-then结构 [ ]必须用[]方括号括起来，必须有空格包围 if-then-else if-then-elif test命令，若表达式为真，则test为0，否则返回非0 参数替换{}，即简单版的if-else结构 算术运算符expr 1 + 2，运算符与运算元素之间必须有空格 单独使用会把最终答案输出到屏幕上 可以用于数字与字母的ASCII码的比较 算术操作let (ksh) let自动使用变量的值，直接键入x不需要$x let不需要\\来消除* %的特殊含义 循环 for-in-done结构 while结构 let的命令缩写，下面版本仅适用于ksh，(( )) 调试shell 0x08 磁盘 最大文件数目由以下决定 未用存储空间大小 用于保存索引节点的存储空间大小 0x00 字节，8位，适合存储字符 字，一种字节组合，在不同系统中字的大小不同 [Spacebar]:一个空格 [Tab]:8个空格 UNIX中文件时字节序列 .表示当前目录 ..表示父目录 显示当前shell的名称 1echo $SHELL :x可以保存文件并退出vi编辑器 绝大多数UNIX命令是保存在磁盘上的程序，称之为系统工具。 shell变量名可使用字母；数字；下划线，但第一个必须为字母 关于KORN shell的内容请参考Page 165 将值存入变量时，等号两边不允许有空格 date if [ ]，[ ]与任何东西都需要有空格，包括if https://yanbin.blog/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"OS教程","slug":"操作系统/OS教程","date":"2020-03-31T06:23:43.314Z","updated":"2020-07-12T13:19:44.697Z","comments":true,"path":"2020/03/31/ 操作系统/OS教程/","link":"","permalink":"http://yoursite.com/2020/03/31/ 操作系统/OS教程/","excerpt":"","text":"前言1 中断，在程序运行过程中出现某种紧急事件，必须中止当前正在运行的程序，转去处理此事件，然后再恢复原来运行的程序。有$\\begin{Bmatrix} 强迫性中断\\ 自愿性中断\\ \\end {Bmatrix}$。 2 中断系统，中断装置+中断处理程序 3 中断装置，识别中断源$\\Longrightarrow$ 保存现场$(运行的物理环境：地址寄存器，通用寄存器，浮点寄存器，SP，PSW，PC，文件表)\\Longrightarrow $引出中断程序 1 进程互斥；进程同步；进程饥饿；进程死机；进程饿死 2 $吞吐量=\\frac{任务数量}{处理时间}$ 3 $PCB,process\\ control\\ block $，进程控制块，是标志进程存在的数据结构，其中包含系统对进程进行管理所需要的全部信息。 4 $TCB,thread\\ control\\ block$，线程控制块，是标志线程存在的数据结构，其中包含系统对线程进行管理所需要的全部信息。 5 $PSW,program\\ status\\ word$，程序状态字，表示当前程序的运行环境，状态 6 $JCB\\ ,Job\\ Control\\ Block$，作业控制块，是标志作业存在的数据结构，其中包含系统对作业进行管理所需要的全部信息。 7 $PC$，指令计数。 8 $FCB,file\\ control \\ block$，文件控制块 1 $FCFS,first\\ come\\ first\\ service $，先到先服务。 。。。 程序并发执行的条件 满足$Bernstein 条件$ $race\\ condition,竞争条件，多个进程在访问变量时，因实际交叉次序不同而导致执行结果不同$ 互斥软件实现互斥Dekker12345678910111213141516171819//参数id为当前的线程号void Dekker_Lock(int id)&#123; flag[id]=1; int id0=(id+1)%2; while(flag[id0]==1)&#123; if(turn==id0)&#123; flag[id]=0; while(turn==id0)&#123; ;//do nothing &#125; flag[id]=1;//为了防止其他进程进入临界区 &#125; &#125;&#125;void Dekker_unLock(int id)&#123; turn=(id+1)%2; flag[id]=0;&#125; Peterson12345678void Peterson_Lock(int id)&#123; flag[id]=1; turn=(id+1)%2;//让给对方，判断对方是否需要 while(flag[1]==1&amp;&amp;turn==(id+1)%2) ;//do nothing&#125;void Peterson_unLock(int id)&#123; flag[id]=0;&#125; Lamport1234567891011121314151617181920212223242526272829303132int find_max()&#123; int i=0; int max_flag=0; for(i=0;i&lt;g_totalThreads;i++)&#123; if(number[i]&gt;number[max_flag]) max_flag=i; &#125; return max_flag;&#125;bool If_choose()&#123; int i=0; for(i=0;i&lt;g_totalThreads;i++)&#123; if(choosing[i]==1) return false; &#125; return true;&#125;void Lamport_Lock(int id)&#123; choosing[id]=1; number[id]=find_max()+1; choosing[id]=0; int j=0; for(j=0;j&lt;g_totalThreads;j++)&#123; while(If_choose()==false) ; while(number[j]!=0 &amp;&amp;(number[j]&lt;number[id] ||(number[j]==number[id]&amp;&amp;j&lt;id))) ; &#125;&#125;void Lamport_unLock(int id)&#123; number[id]=0;&#125; Eisenberg_Mcguire12345678910111213141516171819202122232425262728void Eisenberg_Mcguire_Lock(int id)&#123; int j; do&#123; flag[id]=want_in; j=turn; while(j!=id)&#123; if(flag[j]!=idle)&#123; j=turn; &#125;else&#123; j=(j+1)%g_totalThreads; &#125; &#125; flag[id]=in_cs; j=0; while((j&lt;g_totalThreads)&amp;&amp;(j==id||Flag[j]!=in_cs))&#123; j++; &#125;//判断所有其他进程是否in_cs &#125;while (j!=g_totalThreads); turn=id;&#125;void Eisenberg_Mcguire_unLock(int id)&#123; int j=(turn+1)%g_totalThreads; while(flag[j]==idle)&#123; j=(j+1)%g_totalThreads; &#125; turn=j; flag[id]=idle;&#125; $bus \\ request\\ protocol,总线请求协议$ 同步$synchronization,同步$ $process\\ cooperation,进程合作$ $cooperation\\ process,合作进程$ $semaphore,信号量；PV$ 1234struct semaphore&#123; int value; pointer_to_PCB queue;&#125; $primitive,原语，不可间断的程序$ 12345678910void P(semaphore *s)&#123; s-&gt;value--; if(s-&gt;value&lt;0) asleep(s-&gt;queue);&#125;void V(semphore *s)&#123; s-&gt;value++; if(s-&gt;value&gt;=0) wakeup(s-&gt;queue);&#125; $e.g$ 司机-售票员问题，同步 生产者-消费者问题，单资源管理 读者-写者问题，互斥同时提高并发性 吸烟者问题，多资源管理 死锁死锁的避免银行家算法12345678910111213141516171819202122232425262728293031323334353637383940414243int n;//进程总数int m;//资源类的总数int Available[m];//当前可用资源数，初始化为资源总量int Claim[n,m];//进程i最多需要j种资源的数量int Allocation[n,m];//进程i现在占有j种资源的数量，初始化为0int Need[n,m];//进程i还需要j种资源的数量，初始化为Claim[i][j]int Request[n,m];//进程i当前申请j种资源的数量bool g();bool f(int i)&#123;//进程i发出资源申请 if(Request[i]&gt;Need[i]) return false;//大于尚需资源 if(Request[i]&gt;Available[i]) return false;//大于当前资源数 //资源预分配 Available=Available-Request[i]; Allocation[i]=Allocation[i]+Request[i]; Need[i]=Need[i]-Request[i]; return g();//检测算法&#125;bool g()&#123;//判断是否会发生死锁状态 int Work[m]; Work=Available;//防止影响到原来的Availabe bool Finish[n]=false;//有哪些已经完成了 bool flag=true; int i=1; while(flag)&#123; flag=false; for(i=0;i&lt;n;i++)&#123; if(Finish[i]==false&amp;&amp;Need[i]&lt;=Work[i])&#123;//i可执行 /* 注意再Shoshami和Coffman所提出的是 Finish[i]==false&amp;&amp;Request[i]&lt;=Work[i] */ flag=true; Work=Work+Allocation[i];//恢复资源 Finish[i]=true; &#125; &#125; &#125; for(i=0;i&lt;n;i++)&#123; if(Finish[i]==false) return false; &#125; return true;&#125; Shoshamin&amp;&amp;Coffman的死锁检测算法12345678910111213141516171819bool g()&#123; int Work[m]=Available; bool Finish[n]=false; bool flag=true; while(flag)&#123; flag=false; for(int i=0;i&lt;n;i++)&#123; if(Finish[i]==false&amp;&amp;Request[i]&lt;=Work)&#123; flag=true; Finish=true; Work=Work+Allocation[i];//恢复 &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(Finish[i]==false) return false; &#125; return true;&#125; 主存储器管理内存内存分区 静态分区 动态分区 内存区分配 first fit，FF，最先适应 best fit，BF，最佳适应 worst fit，WF，最坏适应 页式存储 EAT,effective access time 内存的有效访问时间 EAT=快表命中率\\cdot (快表访问时间+内存访问时间)+(1-快表命中率)\\cdot (快表访问时间+2\\cdot 内存访问时间)\\\\ 其中，不命中时，访问页表计入内存访问一次 虚拟存储系统外存储器管理技术策略 平均分配 按进程程序长度分配 按进程优先级的比例分配 按进程长度和优先级的比例分配 ee","categories":[{"name":"OS","slug":"OS","permalink":"http://yoursite.com/categories/OS/"}],"tags":[]},{"title":"计算机系统结构","slug":"计算机系统结构","date":"2020-03-31T06:20:46.000Z","updated":"2020-04-27T06:39:32.285Z","comments":true,"path":"2020/03/31/ 计算机系统结构/","link":"","permalink":"http://yoursite.com/2020/03/31/ 计算机系统结构/","excerpt":"","text":"前言 1字节=1 byte=1 B 1KB=$1^{10}$B 1系统结构，组成，实现 计算机系统结构：计算机系统的软，硬件的界面。 计算机组成：计算机系统结构的逻辑实现。 计算机实现：计算机组成的物理实现 换句话来说，我们设计计算机的时间轴为：$系统结构\\longrightarrow 组成\\longrightarrow 实现$ $t_{cpu}:$执行一段程序所用的CPU时间。 $IC:$该段程序的指令条数，取决于指令集结构 和编译技术。 $CPI,Cycle \\ Per \\ Instruction:$平均每一条指令所需要的时钟周期，取决于组成和指令集结构 $T:$时钟周期，取决于实现 和组成 3 流水线以静态，线性，顺序流水线为例 $吞吐率\\ ThroughPut\\ TP=\\frac{n}{T_k}=\\frac{任务数量}{运行时间}=\\frac{n}{(k+n-1)\\Delta t}$ $加速比\\ Speedup\\ S=\\frac{T_s}{T_k}=\\frac{顺序执行时间}{运行时间}=\\frac{nk}{k+m-1}$ $效率\\ Efficiency\\ E=\\frac{n\\Delta t}{T_k}=\\frac{设备实际使用时间}{运行时间*设备数目}=\\frac{n}{k+n-1}$ dependence 相关，两条指令之间存在某种依赖关系 真数据相关，data dependence，$①指令j使用指令i产生的结果;②指令j与指令k数据相关，指令k又与指令i数据相关$ 名相关，name dependence，如果两条指令使用相同的名，但是它们之间没有数据流动 $anti-dependence,反相关，指令j写的名与指令i读的名相同；\\ output\\ dependence,输出相关,指令j与指令i写的名相同。 $ 控制相关，control dependence ，有分支指令引起的相关。 流水线冲突 pipline hazards，由于相关的存在，使得下一条指令不能再指定的时钟周期执行 结构冲突 数据冲突，相关的指令靠得足够近。 $RAM,Read \\ After \\ Write ,写后读冲突，真数据相关$ $WAW,Write \\ After \\ Write ，写后写冲突，输出相关，在五段流水线(MIPS)中不会发生$ $WAR,Write \\ After \\ Read,读后写冲突.反相关$ 仅发生在这样的情况：有些指令的写操作被提前了，有些操作的读操作被滞后了，即指令被重新排序了,在五段流水线(MIPS)中不会发生 4 指令级并行​ ILP,Instruction-Level\\ Parallelism,指令级并行\\left\\{ \\begin{array}{lr} 基于硬件（代码执行中）的动态开发方法\\\\ 基于软件（代码执行前）的静态开发方法 \\end{array}\\right.\\\\$CPI{实际流水线}=CPI{理想}+停顿{结构冲突}+停顿{数据冲突}+停顿_{控制冲突}$ $IPC,Instructions \\ Per\\ Cycle,每个时钟周期完成的指令条数$ $CDB,Common\\ Data \\ Bus,公共数据总线$ $IS,Issue,流出阶段：指令译码，检查是否存在结构冲突。$ $RO,Read\\ Operands,读操作数：检测数据冲突$ $BHT,Branch\\ History\\ Table\\ ,Branch\\ Predicition\\ Buffer,分支历史表，分支预测缓冲器\\是最简单的动态分支预测方法$ $BTB,Branch\\ Target\\ Buffer,分支目标缓冲器，也称分支目标Cache$ $branch\\ folding,分支折叠$ $speculation,前瞻执行$ $ROB,ReOrder\\ Buffer，再定序缓冲器，为了在猜错的情况下能够恢复现场$ $Tomasulo算法$ $基于硬件的前瞻算法，顺序流出，乱序执行，顺序确认$ 存储系统 局部性原理 principle of locality 空间局部性：程序将要用到的信息很有可能于正在使用的信息相邻 时间局部性：程序将要用到的信息很可能就是现在正在使用的信息 CacheCache命中：CPU能在缓存中访问到存储层次的四个基本问题 映像规则 查找算法 替换算法 随机法 FIFO,First-In-First-Out 先入先出法 LRU,Least-Recently-Used 最近最少使用法 写策略 写直达 写回 按写分配 不按写分配 映像规则 fully associative mapping 全相联映像 direct mapping 直接映像 $j=i\\ mod M$ set associative n路组相联映像 n为每一组的块数 Cache性能分析 平均访存时间=命中时间+不命中率*不命中开销 CPU时间=（CPU执行周期数+访存次数$$不命中率$$不命中开销）$*$时钟周期时间 性能改进 降低不命中率 减少强制性不命中—增加块的大小 ，增加命中时间 减少容量不命中—增加Cache容量，成本增加，命中时间增加，一般用于片外Cache 减少冲突不命中—提高相联度，增加命中时间 伪相联组 降低不命中开销 让读不命中优先于写不命中 写缓冲合并 请求字处理技术 非阻塞Cache 减少命中时间 简单小Cache 虚拟Cache Cache访问流水化 踪迹Cache 伪相联组 并行主存系统 性能指标 延迟，存储器的访问时间，启动一次存储器到完成该操作所需要的时间 带宽，单位时间内存储器存取的信息量 普通存储器：单体单字宽存储器 并行主存： 提高存储带宽 种类：单体多字存储器和多体交叉存储器 单体m字 一个存储体，给一个地址，在一个存储周期，取m个CPU字 $B_M=m*\\frac{W}{T_M}$，带宽为单体单字的m倍 主要用于主存与Cache 多体交叉存储器 高位交叉编址 低位交叉编址 提高带宽 输入/输出系统$MTTF,Mean\\ Time\\ To\\ Failure,平均失效前时间$ $MTTR,Mean\\ Time\\ To \\ Repair，平均修复时间$ $MTBF=MTTF+MTTR,Mean\\ Time\\ Between\\ Failure,平均失效间隔时间$ $reliability,可靠性$ 衡量标准：MTTF,其中失效率=\\frac{1}{MTTF}$availability,可用性$ 可用性=\\frac{MTTF}{MTTR+MTTF}$dependability,可信性，不可度量$ 提高系统组成部件可靠性的方法：$valid\\ construction,有效构建方法；error\\ correction,纠错方法$ 仲裁) 程序查询方式) 通道流量分析 $T_S,设备选择时间$ $T_D,传送一个字节所用的时间$ $p:在一个通道上连接的设备数目，且这些设备都同时在工作$ $n:每台设备传送的字节数$ $k:数组多路通道传输一个数据块中包含的字节数。一般情况下，k&lt;n$ $T:通道完成全部数据传送工作所需要的时间$ EG$e.g.1$ 解 不妨设加速比为S 那么有 S=\\frac {time_前}{time_后}=\\frac{11.1\\%*2+33.3\\%*20+38.9\\%*10+16.7\\%*4}{11.1\\%*1+33.3\\%*15+38.9\\%*3+16.7\\%*1}=\\frac{11.44}{6.44}=1.77$e.g.2$ 考虑条件分支指令的两种不同设计方法：（1）CPUA：通过比较指令设置条件码，然后测试条件码进行分支。（2）CPUB：在分支指令中包括比较过程。在这两种CPU中，条件分支指令都占用2个时钟周期，而所有其他指令占用1个时钟周期。对于CPUA，执行的指令中分支指令占20%；由于每条分支指令之前都需要有比较指令，因此比较指令也占20%。不妨假设其他指令条数相同。由于CPUA在分支时不需要比较，因此CPUB的时钟周期时间是CPUA的1.25倍。问：哪一个CPU更快？如果CPUB的时钟周期时间只是CPUA的1.1倍，哪一个CPU更快呢？ $t_{cpu}=ICCPIT$ 那么有 t_{cpuA}=IC*(0.4*2+0.6*1)*T \\\\ t_{cpuB}=IC*(2/8*2+6/8*1)*1.25T最后即可得答案。","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"http://yoursite.com/categories/计算机系统结构/"}],"tags":[]},{"title":"state machine&Euclidean Alg","slug":"MachineLearning/离散数学第4讲","date":"2020-03-21T08:09:17.000Z","updated":"2020-03-23T14:34:27.505Z","comments":true,"path":"2020/03/21/ MachineLearning/离散数学第4讲/","link":"","permalink":"http://yoursite.com/2020/03/21/ MachineLearning/离散数学第4讲/","excerpt":"","text":"state machine 水壶问题 有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: 12输入: x = 3, y = 5, z = 4输出: True 示例 2: 12输入: x = 2, y = 6, z = 5输出: False 我们不妨将每一次两个水壶中所拥有的水的体积作为该时刻的状态。 状态表示为$P(n)=(a,b)$。 其中，$a$表示容量为$x$升的水壶所有的水，$b$表示容量为$y$升的水壶所有的水。 状态转移有装满一个水壶；清空一个水壶；从一个水壶向另外一个水壶倒水，知道装满或者倒空。 最终状态必然有$a_0+b_0=z$ 1结论：ans=GCD(x,y)|z 容易推理出若$m|a_0,m|b_0,则有m|z$ 那么我们需要寻找这样的状态$(a_0,b_0)$ 证明：m|x且m|y\\Longrightarrow m|a且m|b不妨设$m|x且m|y$。 显然$P(0)=(0,0),任意m|0符合(1)式$ 设$P(n)=(a,b),m|a且m|b$ 证明$P(n+1)=(a_1,b_1),m|a_1,m|b_1$ 根据状态转移有 P(n+1)=\\left\\{ \\begin{array}{lr} (a,0)\\\\ (0,b)\\\\ (x,b)\\\\ (a,y)\\\\ (a-(y-b),y)\\\\ (0,a+b)\\\\ (x,b-(x-a))\\\\ (a+b,0)\\\\ \\end{array} \\right.只证$(2)式$的每一个数字都能被$m$整除，答案是显然的。 那么我们就可以得到最终的状态$(a_0,b_0)必然有m|a_0,m|b_0,那么有m|z$。 为了保证每一个$m$的取值都能满足以上推论。 必然需要满足$GCD(x,y)|z$ 所以有$z\\%GCD(x,y)==0$ Euclidean Alg GCD(a,b)=GCD(Remainder(b,a),a)\\\\ 其中，Remainder(b,a)=b-q*a=b\\%a\\geq0\\ \\ \\ \\ \\ a,b,q均为正整数证明$m|a且m|b\\Longrightarrow m|Remainder(b,a)且m|a$ 答案是显然的。 现只需证明$m|Remainder(b,a) 且m|a\\Longrightarrow m|b$ 已知b-qa=k_1m,a=k_2m\\\\ 有b=(k_1+k_2q)m\\\\ 有m|b1234567891011121314151617181920class Solution &#123;public: int GCD(int a,int b)&#123; if(a==0||b==0) return max(a,b); int c; while(b%a!=0)&#123; c=b%a; b=a; a=c; &#125; return a; &#125; bool canMeasureWater(int x, int y, int z) &#123; if(z==0) return true; if(z&gt;x+y)return false; int m=GCD(x,y); if(z%m==0) return true; return false; &#125;&#125;;","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://yoursite.com/categories/离散数学/"}],"tags":[]},{"title":"算法设计与分析","slug":"算法设计及分析","date":"2020-02-13T14:42:33.000Z","updated":"2020-05-20T06:06:37.460Z","comments":true,"path":"2020/02/13/ 算法设计及分析/","link":"","permalink":"http://yoursite.com/2020/02/13/ 算法设计及分析/","excerpt":"","text":"2证明$f(n)=O(g(n))$，有 \\exists c,n_0,对于\\forall n\\geq n_0 有 f(n)\\leq c*g(n)即$g(n)$时$f(n)$的渐近上限。 证明$f(n)=\\Omega (g(n))$，有 \\exists c,n_0,对于\\forall n\\geq n_0 有 f(n)\\geq c*g(n)即$g(n)$时$f(n)$的渐近下限。 若同时满足$(1),(2)$ 则有 f(n)=\\Theta (g(n)),且g(n)=\\theta (f(n))3 贪心方法1 一般方法 n个输入,可行解为n个输入的子集\\\\ 约束条件\\Longrightarrow 可行解 根据目标函数\\Longrightarrow最优解核心：选取能产生最优解的量度标准2背包定理5.1 如果$p_1 /w_1 ≥ p_2 /w_2 ≥ … ≥ p_n /w_n $，则算法GREEDY-KNAPSACK 对于给定的背包问题实例生成一个最优解。 证明 ​ 设$X=(x_1,…,x_n)$是算法生成的解 1.若所有的$x_i$=1,显然这个解就是最优解。 2.否则，设j是使得$x_j!=1$的最小下标，那么由算法可知 对于$1\\leq i&lt;j$，$x_i=1$ 对于$j&lt;i\\leq n$，$x_i=0$ 对于$i=j$，$0\\leq x_i&lt;1$ 3.若$X$不是最优解，那么必然存在一个最优解$Y=(y_1…y_n),使得\\sum p_i y_i&gt;\\sum p_ix_i,那么必然有\\sum w_iy_i=M$ 设$k$是使得$y_k!=x_k$的最小下标，这样的$k$必然存在 $k&lt;j$时，由于$x_k=1$,必然有$y_k&lt; x_k$ $k=j$时，若$y_k&gt;x_k$，那么必然有$\\sum w_i y_i&gt;M$，矛盾，故必然有$y_k&lt;x_k$ $k&gt;j$时，若$y_k&gt;x_k$，那么必然有$\\sum w_i y_i&gt;M$，矛盾，故必然有$y_k&lt;x_k$ 故有$y_k&lt;x_k$。 4.现在使得$yk=x_k$,那么其代价为$y{k+1},…y_n$必须减去同样多的重量，使得总容量为$M$,那么导致了新解$Z$。有 \\sum _{k","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/categories/算法设计与分析/"}],"tags":[]},{"title":"Warshall&All_componet","slug":"Algorithm/Warshall","date":"2019-11-18T13:44:59.000Z","updated":"2020-03-23T14:18:30.383Z","comments":true,"path":"2019/11/18/ Algorithm/Warshall/","link":"","permalink":"http://yoursite.com/2019/11/18/ Algorithm/Warshall/","excerpt":"","text":"Warshall &amp; All_componet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;struct Edge&#123; int VerAdj; int cost; Edge*link;&#125;;struct Vertex&#123; int VerName; Edge*adjacent;&#125;;struct node&#123; int VerName; node*link;&#125;;int graphsize;int edgesize;const int MAX=1e2;void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i,j,k; int from,to,cost; for(i=0;i&lt;graphsize;i++) &#123; S[i].adjacent=NULL; S[i].VerName=i; &#125; for(i=1;i&lt;=edgesize;i++) &#123; scanf(\"%d%d\",&amp;from,&amp;to); Edge*p=new Edge; p-&gt;cost=0; p-&gt;link=NULL; p-&gt;VerAdj=to; Edge*q=S[from].adjacent; if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; if(q-&gt;cost&gt;p-&gt;cost) &#123; delete q; S[from].adjacent=p; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; if(q-&gt;link==NULL) &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; else &#123; if(q-&gt;link-&gt;VerAdj==p-&gt;VerAdj) &#123; if(q-&gt;link-&gt;cost&gt;p-&gt;cost) &#123; Edge*q0=q-&gt;link; p-&gt;link=q0-&gt;link; q-&gt;link=p; delete q0; &#125; else delete p; &#125; else &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125; &#125; &#125;&#125;void Warshall(Vertex S[],int WSM[MAX][MAX])&#123; int i,j,k; Edge*p; int a; for(i=0;i&lt;graphsize;i++) &#123; for(j=0;j&lt;graphsize;j++) &#123; if(i==j) WSM[i][j]=1; else &#123; WSM[i][j]=0; WSM[j][i]=0; &#125; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; p=S[i].adjacent; a=S[i].VerName; while(p!=NULL) &#123; WSM[a][p-&gt;VerAdj]=1; p=p-&gt;link; &#125; &#125; for(k=0;k&lt;graphsize;k++) &#123; for(i=0;i&lt;graphsize;i++) &#123; if(WSM[i][k]==1) &#123; for(j=0;j&lt;graphsize;j++) &#123; WSM[i][j]=(WSM[i][j])||(WSM[k][j]); &#125; &#125; &#125; &#125;&#125;void All_componet(Vertex S[])&#123; int WSM[MAX][MAX]; int markedList[MAX]; int i,j,k; for(i=0;i&lt;graphsize;i++) markedList[i]=0; Warshall(S,WSM); int t=0; int v; for(v=0;v&lt;graphsize;v++) &#123; if(markedList[v]==0) &#123; markedList[v]=1; node*scList=new node; scList-&gt;VerName=v; scList-&gt;link=NULL; node*q=scList; for(i=0;i&lt;graphsize;i++) &#123; if(i!=v&amp;&amp;WSM[v][i]==1&amp;&amp;WSM[i][v]==1) &#123; markedList[i]=1; node*p=new node; p-&gt;VerName=i; p-&gt;link=NULL; q-&gt;link=p; q=q-&gt;link; &#125; &#125; printf(\"t:%d\\n\",t); t=t+1; q=scList; node*q0; while(q!=NULL) &#123; printf(\"%d \",q-&gt;VerName); q0=q; q=q-&gt;link; delete q0; &#125; cout&lt;&lt;endl; &#125; &#125;&#125;/*6 70 10 31 22 03 44 55 4*/int main()&#123; Vertex S[MAX]; Init(S); All_componet(S); return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Prim","slug":"Algorithm/Prim","date":"2019-11-13T14:42:33.000Z","updated":"2020-03-23T14:20:26.806Z","comments":true,"path":"2019/11/13/ Algorithm/Prim/","link":"","permalink":"http://yoursite.com/2019/11/13/ Algorithm/Prim/","excerpt":"","text":"Prim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int cost; int head; int tail;&#125;;const int MAX=1e6;edge E[MAX];edge TE[MAX];int graphsize;int edgesize;struct LV&#123; int Lowcost; int Vex;&#125;;LV closedge[MAX];int Edge[5010][5010];//稠密图，使用邻接矩阵void Prim()&#123; int i; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); for(i=0;i&lt;graphsize;i++) &#123; for(int j=0;j&lt;graphsize;j++) &#123; Edge[i][j]=1e9; Edge[j][i]=1e9; &#125; &#125; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;E[i].head,&amp;E[i].tail,&amp;E[i].cost); //防止重边 if(E[i].cost&lt;Edge[E[i].head-1][E[i].tail-1]) &#123; Edge[E[i].head-1][E[i].tail-1]=E[i].cost; Edge[E[i].tail-1][E[i].head-1]=E[i].cost; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; closedge[i].Lowcost=Edge[0][i]; closedge[i].Vex=0; &#125; closedge[0].Vex=-1; int count=0; int ans=0; for(i=1;i&lt;graphsize;i++) &#123; int Min=1e9+1; int v=0; for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;closedge[j].Lowcost&lt;Min) &#123; v=j; Min=closedge[j].Lowcost; &#125; &#125; if(v!=0) &#123; ans=ans+closedge[v].Lowcost; TE[count].head=closedge[v].Vex; TE[count].tail=v; TE[count].cost=closedge[v].Lowcost; count++; closedge[v].Lowcost=0; closedge[v].Vex=-1; //进行一些操作使得它们保持最小 for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;Edge[v][j]&lt;closedge[j].Lowcost) &#123; closedge[j].Lowcost=Edge[v][j]; closedge[j].Vex=v; &#125; &#125; &#125; &#125; printf(\"%d\",ans);&#125;//prim/*6 100 1 10 2 40 3 71 2 42 3 21 5 22 5 52 4 33 4 64 5 3*/int main()&#123; Prim();&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Kmeans","slug":"MachineLearning/Kmeans","date":"2019-11-13T14:42:33.000Z","updated":"2020-03-23T14:17:27.839Z","comments":true,"path":"2019/11/13/ MachineLearning/Kmeans/","link":"","permalink":"http://yoursite.com/2019/11/13/ MachineLearning/Kmeans/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#基于聚类算法(kmeans)的图像分割'''导入所需要的模块：1.用于处理二维矩阵的数学库2.随机生成数的模块3.用于将图片(JPG)转换为矩阵以及把矩阵转换为图片(JPG)的模块'''import numpy as npfrom random import randomfrom PIL import Image# 导入数据，file_path是图像的存储位置# 返回值def load_data(file_path): f = open(file_path, \"rb\") # 以二进制的方式打开图像文件 data = [] im = Image.open(f) # 导入图片 m, n = im.size # 得到图片的大小 print (m), (n) for i in range(m): for j in range(n): tmp = [] x, y, z = im.getpixel((i, j)) tmp.append(x / 256.0) tmp.append(y / 256.0) tmp.append(z / 256.0) data.append(tmp) f.close() return np.mat(data)def distance(vecA, vecB): '''计算vecA与vecB之间的欧式距离的平方 input: vecA(mat)A点坐标 vecB(mat)B点坐标 output: dist[0, 0](float)A点与B点距离的平方 ''' dist = (vecA - vecB) * (vecA - vecB).T return dist[0, 0]def randCent(data, k): '''随机初始化聚类中心 input: data(mat):训练数据 k(int):类别个数 output: centroids(mat):聚类中心 ''' n = np.shape(data)[1] # 属性的个数 centroids = np.mat(np.zeros((k, n))) # 初始化k个聚类中心 for j in range(n): # 初始化聚类中心每一维的坐标 minJ = np.min(data[:, j]) rangeJ = np.max(data[:, j]) - minJ # 在最大值和最小值之间随机初始化 centroids[:, j] = minJ * np.mat(np.ones((k , 1))) + np.random.rand(k, 1) * rangeJ return centroidsdef kmeans(data, k, centroids): '''根据KMeans算法求解聚类中心 input: data(mat):训练数据 k(int):类别个数 centroids(mat):随机初始化的聚类中心 output: centroids(mat):训练完成的聚类中心 subCenter(mat):每一个样本所属的类别 ''' m, n = np.shape(data) # m：样本的个数，n：特征的维度 subCenter = np.mat(np.zeros((m, 2))) # 初始化每一个样本所属的类别 change = True # 判断是否需要重新计算聚类中心 while change == True: change = False # 重置 for i in range(m): minDist = np.inf # 设置样本与聚类中心之间的最小的距离，初始值为争取穷 minIndex = 0 # 所属的类别 for j in range(k): # 计算i和每个聚类中心之间的距离 dist = distance(data[i, ], centroids[j, ]) if dist &lt; minDist: minDist = dist minIndex = j # 判断是否需要改变 if subCenter[i, 0] != minIndex: # 需要改变 change = True subCenter[i, ] = np.mat([minIndex, minDist]) # 重新计算聚类中心 for j in range(k): sum_all = np.mat(np.zeros((1, n))) r = 0 # 每个类别中的样本的个数 for i in range(m): if subCenter[i, 0] == j: # 计算第j个类别 sum_all += data[i, ] r += 1 for z in range(n): try: centroids[j, z] = sum_all[0, z] / r print (r) except: print (\" r is zero\") return subCenterdef save_result(file_name, source): '''保存source中的结果到file_name文件中 input: file_name(string):文件名 source(mat):需要保存的数据 output: ''' m, n = np.shape(source) f = open(file_name, \"w\") for i in range(m): tmp = [] for j in range(n): tmp.append(str(source[i, j])) f.write(\"\\t\".join(tmp) + \"\\n\") f.close()# --------------------------------------------------FLOAT_MAX = 1e100 # 设置一个较大的值作为初始化的最小的距离def nearest(point, cluster_centers): '''计算point和cluster_centers之间的最小距离 input: point(mat):当前的样本点 cluster_centers(mat):当前已经初始化的聚类中心 output: min_dist(float):点point和当前的聚类中心之间的最短距离 ''' min_dist = FLOAT_MAX m = np.shape(cluster_centers)[0] # 当前已经初始化的聚类中心的个数 for i in range(m): # 计算point与每个聚类中心之间的距离 d = distance(point, cluster_centers[i, ]) # 选择最短距离 if min_dist &gt; d: min_dist = d return min_distdef get_centroids(points, k): '''KMeans++的初始化聚类中心的方法 input: points(mat):样本 k(int):聚类中心的个数 output: cluster_centers(mat):初始化后的聚类中心 ''' m, n = np.shape(points) cluster_centers = np.mat(np.zeros((k , n))) # 1、随机选择一个样本点为第一个聚类中心 index = np.random.randint(0, m) cluster_centers[0, ] = np.copy(points[index, ]) # 2、初始化一个距离的序列 d = [0.0 for _ in range(m)] print (\"\\t初始化一个距离序列\") print (\" k=\",k) for i in range(1, k): print(i) sum_all = 0 for j in range(m): # 3、对每一个样本找到最近的聚类中心点 d[j] = nearest(points[j, ], cluster_centers[0:i, ]) # 4、将所有的最短距离相加 sum_all += d[j] # 5、取得sum_all之间的随机值 sum_all *= random() # 6、获得距离最远的样本点作为聚类中心点 for j, di in enumerate(d): sum_all -= di if sum_all &gt; 0: continue cluster_centers[i] = np.copy(points[j, ]) break return cluster_centersdef run_kmeanspp(data, k): # 1、KMeans++的聚类中心初始化方法 print (\"\\t---------- 1.K-Means++ generate centers ------------\") centroids = get_centroids(data, k) # 2、聚类计算 print (\"\\t---------- 2.kmeans ------------\") subCenter = kmeans(data, k, centroids) # 3、保存所属的类别文件 print (\"\\t---------- 3.save subCenter ------------\") save_result(\"sub_pp\", subCenter) # 4、保存聚类中心 print (\"\\t---------- 4.save centroids ------------\") save_result(\"center_pp\", centroids)#--------------------------------------------------k = 4 #聚类中心的个数# 1、导入数据print (\"---------- 1.load data ------------\")data = load_data(\"Pic_B.jpg\")# 2、利用kMeans++聚类print (\"---------- 2.run kmeans++ ------------\")run_kmeanspp(data, k)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[]},{"title":"BinTree","slug":"Algorithm/BinTree","date":"2019-10-27T04:28:29.000Z","updated":"2020-06-02T17:18:05.335Z","comments":true,"path":"2019/10/27/ Algorithm/BinTree/","link":"","permalink":"http://yoursite.com/2019/10/27/ Algorithm/BinTree/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#include&lt;stack&gt;#include&lt;utility&gt;#include&lt;queue&gt;using namespace std;template&lt;class T&gt;class BinTreeNode&#123;public: BinTreeNode&lt;T&gt;*left; BinTreeNode&lt;T&gt;*right; T data;public: BinTreeNode(const T&amp;item,BinTreeNode&lt;T&gt;*L=NULL,BinTreeNode&lt;T&gt;*R=NULL):data(item),left(L),right(R)&#123;&#125; BinTreeNode&lt;T&gt;*GetLeft()const &#123; return left; &#125; BinTreeNode&lt;T&gt;*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode&lt;T&gt;*L) &#123; left=L; &#125; void SetRight(BinTreeNode&lt;T&gt;*R) &#123; right=R; &#125; T&amp; GetData()&#123;return data;&#125; void SetData(const T&amp;item)&#123;data=item;&#125;&#125;;template&lt;class T&gt;class BinTree&#123;public: BinTreeNode&lt;T&gt;*root; T stop;public: BinTree(BinTreeNode&lt;T&gt;*t=NULL):root(t)&#123;&#125; void PreOrder(BinTreeNode&lt;T&gt;*t)const; void InOrder(BinTreeNode&lt;T&gt;*t)const; void PostOrder(BinTreeNode&lt;T&gt;*t)const; void LevelOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPreOrder(BinTreeNode&lt;T&gt;*t)const; void NorecInOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPostOrder(BinTreeNode&lt;T&gt;*t)const; void CreateBinTree(T tostop); BinTreeNode&lt;T&gt;* Create(); BinTreeNode&lt;T&gt;*CopyTree(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p); BinTreeNode&lt;T&gt;*Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const; void InsertLeft(T item,BinTreeNode&lt;T&gt;*t); void InsertRight(T item,BinTreeNode&lt;T&gt;*s); void DelSubtree(BinTreeNode&lt;T&gt;*t); void Del(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*GetRoot()&#123;return root;&#125; void SetRoot(BinTreeNode&lt;T&gt;*t)&#123;root=t;&#125; T getStop()&#123;return stop;&#125; void SetStop(T tostop)&#123;stop=tostop;&#125; bool IsEmpty()&#123;return root==NULL;&#125;&#125;;template&lt;class T&gt;void BinTree&lt;T&gt;::PreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; PreOrder(t-&gt;GetLeft()); PreOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; InOrder(t-&gt;GetLeft()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; InOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::PostOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; PostOrder(t-&gt;GetLeft()); PostOrder(t-&gt;GetRight()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecInOrder(BinTreeNode&lt;T&gt;*t)const&#123; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; while(t!=NULL||S.empty()==false) &#123; while(t!=NULL) &#123; S.push(t); t=t-&gt;GetLeft(); &#125; if(S.empty()==true)return ; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; t=t-&gt;GetRight(); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t==NULL)return ; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; S.push(t); while(S.empty()==false) &#123; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; if(t-&gt;GetRight()!=NULL) S.push(t-&gt;GetRight()); if(t-&gt;GetLeft()!=NULL) S.push(t-&gt;GetLeft()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPostOrder(BinTreeNode&lt;T&gt;*t)const&#123; pair&lt;BinTreeNode&lt;T&gt;*,int&gt; p; if(t==NULL)return ; p=make_pair(t,0); stack&lt;pair&lt;BinTreeNode&lt;T&gt;*,int&gt;&gt;S; S.push(p); while(S.empty()==false) &#123; p=S.top(); S.pop(); if(p.second==0) &#123; p.second++; S.push(p); if((p.first)-&gt;GetLeft()!=NULL) &#123; p.first=(p.first)-&gt;GetLeft(); p.second=0; S.push(p); &#125; &#125; else &#123; if(p.second==1) &#123; p.second++; S.push(p); if((p.first)-&gt;GetRight()!=NULL) &#123; p.first=(p.first)-&gt;GetRight(); p.second=0; S.push(p); &#125; &#125; else &#123; cout&lt;&lt;p.first-&gt;GetData()&lt;&lt;endl; &#125; &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::LevelOrder(BinTreeNode&lt;T&gt;*t)const&#123; queue&lt;BinTreeNode&lt;T&gt;*&gt;Q; if(t==NULL)return ; BinTreeNode&lt;T&gt; *p=t; Q.push(p); while(Q.empty()==false) &#123; p=Q.front(); Q.pop(); cout&lt;&lt;p-&gt;GetData()&lt;&lt;endl; if(p-&gt;GetLeft()!=NULL) &#123; Q.push(p-&gt;GetLeft()); &#125; if(p-&gt;GetRight()!=NULL) &#123; Q.push(p-&gt;GetRight()); &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::CreateBinTree(T tostop)&#123; SetStop(tostop); root=Create();&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;* BinTree&lt;T&gt;::Create()&#123; BinTreeNode&lt;T&gt;*t,*t1,*t2; T item; cin&gt;&gt;item; if(item==stop) &#123; t=NULL; return t; &#125; t=new BinTreeNode&lt;T&gt;(item,NULL,NULL); t1=Create(); t-&gt;SetLeft(t1); t2=Create(); t-&gt;SetRight(t2); return t;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::CopyTree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return NULL; BinTreeNode&lt;T&gt;*L=nullptr,*R=nullptr; if(t-&gt;GetLeft()!=NULL) &#123; L=CopyTree(t-&gt;GetLeft()); &#125; if(t-&gt;GetRight()!=NULL) &#123; R=CopyTree(t-&gt;GetRight()); &#125; BinTreeNode&lt;T&gt;*nod=new BinTreeNode&lt;T&gt;(t-&gt;GetData(),L,R); return nod;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p)&#123; BinTreeNode&lt;T&gt;*q; if(t==NULL||p==NULL) return NULL; if(t-&gt;GetLeft()==p||t-&gt;GetRight()==p) return t; q=Father(t-&gt;GetLeft(),p); if(q!=NULL)return q; return Father(t-&gt;GetRight(),p);&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const&#123; BinTreeNode&lt;T&gt;*p; if(t==NULL)return NULL; if(t-&gt;data==item) return t; p=Find(t-&gt;GetLeft(),item); if(p!=NULL) return p; p=Find(t-&gt;GetRight(),item); return p;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::Del(BinTreeNode&lt;T&gt;*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertLeft(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetLeft(s-&gt;GetLeft()); p-&gt;SetRight(NULL); s-&gt;SetLeft(p);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertRight(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetRight(s-&gt;GetRight()); s-&gt;SetRight(p); p-&gt;SetLeft(NULL);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::DelSubtree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return ; if(t==root) &#123; Del(t); root=NULL; return ; &#125; BinTreeNode&lt;T&gt;*f=Father(root,t); if(f!=nullptr) &#123; if(f-&gt;GetLeft()==t) f-&gt;SetLeft(NULL); if(f-&gt;GetRight()==t)f-&gt;SetRight((NULL)); &#125; Del(t);&#125;int main()&#123; BinTree&lt;int&gt; t; t.CreateBinTree(-1); BinTreeNode&lt;int&gt;*t2=t.Find(t.root,4); t.InsertRight(6,t2); t.InOrder(t.root); return 0;&#125;/*1 2 4 -1 5 -1 -1 -1 3 -1 -1*/","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"EulerSieve","slug":"Algorithm/EulerSieve","date":"2019-10-21T06:16:46.000Z","updated":"2020-03-31T06:23:13.631Z","comments":true,"path":"2019/10/21/ Algorithm/EulerSieve/","link":"","permalink":"http://yoursite.com/2019/10/21/ Algorithm/EulerSieve/","excerpt":"","text":"EulerSieve时间复杂度​ O(n) 实现12345678910111213141516171819202122const int maxn = 10100; int prime[maxn], pNum = 0; // prime记录素数，pNum记录素数个数 //保存的值为0~pNum-1bool p[maxn] = &#123;false&#125;; // p记录当前数是否被筛去void EulerSieve(int n) // 查找记录2-n的素数&#123; int j; for (int i = 2; i &lt;= n; i++) &#123; if (p[i] == false) // 如果未被筛过，则为素数 prime[pNum++] = i; for (j = 0; j &lt; pNum; j++) &#123; if (i * prime[j] &gt; n) // 当要标记的合数超出范围时跳出 break; p[i * prime[j]] = true; // 将已经记录的素数的倍数进行标记 if (i % prime[j] == 0) //关键步骤 break; &#125; &#125;&#125; 理解时间复杂度证明","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"qpow","slug":"Algorithm/qpow","date":"2019-10-20T17:18:42.000Z","updated":"2020-03-23T14:18:39.223Z","comments":true,"path":"2019/10/21/ Algorithm/qpow/","link":"","permalink":"http://yoursite.com/2019/10/21/ Algorithm/qpow/","excerpt":"","text":"快速幂假设​ 求x^n的值 时间复杂度​ O(log n) 解释​ 通过加大底数的权重来使得乘法次数更少 ​ 1.假设n为奇数：x^n=x*x^(n-1) 则将x计入结果 ​ 2.假设n为偶数：x^n=x^(n/2)*x^(n/2) 则将x的权重变为x^2 实现代码1234567891011121314/*快速幂运算 log 2 n*/typedef long long LL;LL qpow(LL a, LL n, LL mod)&#123; LL result = 1; while (n!=0) &#123; if (n &amp; 1) result = (result * a) % mod;//计入结果 a = (a * a) % mod;//权重变大 n &gt;&gt;= 1;//n=n/2; &#125; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Kruskal","slug":"Algorithm/Kruskal","date":"2019-10-10T14:56:52.000Z","updated":"2020-03-23T14:14:19.299Z","comments":true,"path":"2019/10/10/ Algorithm/Kruskal/","link":"","permalink":"http://yoursite.com/2019/10/10/ Algorithm/Kruskal/","excerpt":"","text":"Kruskal Kruskal总是维护无向连通图的最小生成森林 最终得到该图的最小生成树 由来​ Kruskal算法是一种用来查找最小生成树的贪心算法，由Joseph Kruskal在1956年发表。 假设​ 有n个点m条无向边的图，且已知每一条边(x,y,z)，代表点x和点y之间有哦权值为z的无向边。 时间复杂度​ O(m log m) 预备知识​ 并查集 先挖坑 解释​ 在遍历所给无向连通图的过程中，kruskal 总是维护着最小生成森林。 ​ 最终得到最小生成树。 ​ 有以下步骤： ​ 1.初始化并查集，每一个点各自构成一个集合 ​ 2.对边集S进行从小到大排序 ​ 3.从S中取出一条边（注意：现在是从S中从小到大取出，判断这条边的两个端点是否属于同一个集合（使用并查集维护），不是则将端点x和端点y使用并查集combine起来。且将边加入最小生成森林。 ​ 4.不断重复S直至访问完所有边 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//以边集来保存图，假设有m条边//时间复杂度为mlogmconst int MAX=11010;struct edge&#123; int x; int y; int z;&#125;;//代表x和y两点之间有路且权值为zedge S[MAX];int Father[MAX];int n,m;int ans;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; return a.z&lt;b.z;&#125;inline void Init()&#123; int i; scanf(\"%d%d\",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;S[i].x,&amp;S[i].y,&amp;S[i].z);&#125;//并查集找父亲inline int Find(int x)&#123; while(x!=Father[x]) x=Father[x]; return x; &#125;//combineinline void combine(int x,int y)&#123; Father[x]=y;&#125;inline void Kruskal()&#123; ans=0; int x; int y; int i; for(i=1;i&lt;=n;i++) Father[i]=i; sort(S+1,S+m+1); for(i=1;i&lt;=m;i++) &#123; x=Find(S[i].x); y=Find(S[i].y); if(x!=y) &#123; ans=ans+S[i].z; combine(x,y); &#125; &#125;&#125; 模板题 ​ 回顾学习算法的第四天。戒掉可乐的第四天 ​ Orz ​ Orz","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"细品西瓜-前传","slug":"MachineLearning/西瓜1","date":"2019-10-10T14:56:52.000Z","updated":"2020-06-03T13:34:56.977Z","comments":true,"path":"2019/10/10/ MachineLearning/西瓜1/","link":"","permalink":"http://yoursite.com/2019/10/10/ MachineLearning/西瓜1/","excerpt":"","text":"学习是系统通过经验提升性能的过程 绪论 假设空间 版本空间 模型评估与选择 过拟合：将训练样本自身的一些特点作为所有样本的一般特性，导致泛化性能下降，学习能力过于强大。 欠拟合：学习能力不足。 模型选择泛化误差最小的模型 ROC,Receiver Operating Characteristic 受试者工作特征 AUC,Area Under ROC Curve ROC曲线下的面积","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://yoursite.com/categories/Machine-Learning/"}],"tags":[]},{"title":"iterator","slug":"迭代器","date":"2019-10-09T15:21:21.000Z","updated":"2020-04-29T07:25:52.395Z","comments":true,"path":"2019/10/09/ 迭代器/","link":"","permalink":"http://yoursite.com/2019/10/09/ 迭代器/","excerpt":"","text":"C++ 迭代器 定义：可以是概念本身，可以是迭代器类型，可以是某个迭代器对象。 总之，它能使我们能访问容器的元素或者改变某个元素。 123456789vector&lt;int&gt; Vec;auto it=Vec.begin();while(it!=Vec.end())&#123; cout&lt;&lt;*it&lt;&lt;endl; //解引用&#125;auto it=Vec.cbegin(); while(it!=Vec.cend())&#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; 其中end成员我们称之为尾后迭代器of-the-end iterator，其为尾元素的下一个位置。 其中Vec.cbegin()的返回值vector&lt;int&gt;::const_iterator，为C++11新标准引入的函数。 迭代器失效，若向迭代器所属的容器中添加元素，那么迭代器失效。 运算 所有容器均支持递增运算it++，也支持==和!=比较 其中string和vector支持的运算更多 Java Iterator 定义：是集合类的接口 123456public interface Iterator&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemaining(Consumer&lt;? super E&gt; action);&#125; 123456Collection&lt;String&gt; C;Iterator&lt;String&gt; iter=C.iterator();while(iter.hasNext())&#123; String element =iter.next(); //do something&#125;","categories":[{"name":"垃圾场","slug":"垃圾场","permalink":"http://yoursite.com/categories/垃圾场/"}],"tags":[]},{"title":"Manacher","slug":"Algorithm/Manacher","date":"2019-10-09T15:21:21.000Z","updated":"2020-03-23T14:14:43.854Z","comments":true,"path":"2019/10/09/ Algorithm/Manacher/","link":"","permalink":"http://yoursite.com/2019/10/09/ Algorithm/Manacher/","excerpt":"","text":"由来​ 1975年，一个叫Manacher的人发明了一个Manacher算法 作用​ 给定一个字符串S，求出其最大回文子串 时间复杂度 O(n) 原理 对称性 1.字符串处理​ 由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 ​ Example： 原串S a c a b a 转换后的串T # a # c # a # b # a # ​ 为了防止越界，做出以下修改，使得T变成$#a#a#a#b#a#@ 2.Len数组​ 设有字符串T上的位置i，Len[i]表示以i为中心的回文串的半径，和KMP算法相比，这里的数组并非只是预处理的作用，而是在线的处理 ​ 可得： i 1 2 3 4 5 6 7 8 9 10 11 T[i] # a # c # a # b # a # Len[i] 1 2 1 4 1 2 1 4 1 2 1 ​ 如何得到Len数组？ ​ （先挖坑） ​ 主要思想是利用对称性 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int MAX=110000000+10;char S[MAX];//原串char tmp[MAX*2+10];//辅助字符串Tint Len[MAX*2+10];//Len数组int N1;//原串S的长度int N2;//T的长度inline void GetT()&#123; int i,N1=strlen(S); N2=N1*2+1; tmp[0]='$'; for(i=1;i&lt;=2*N1;i=i+2) &#123; tmp[i]='#'; tmp[i+1]=S[i/2]; &#125; tmp[i]='#'; tmp[i+1]='@'; //这样处理的原因是优化后面的操作，比如这样的情况 \"bb\" tmp[i+2]=0;&#125;//得到最大的回文串长度inline int Manacher()&#123; GetLen(); int mx=0; int ans=0; int po=0; int i; for(i=1;i&lt;=N2;i++) &#123; if(mx&gt;i) &#123; //对称性,两者取最小 if((mx-i)&lt;Len[2*po-1]) Len[i]=mx-i; else Len[i]=Len[2*po-1]; &#125; else//第三种情况 Len[i]=1; //不断向外扩展，巧妙 while(tmp[i-Len[i]]==tmp[i+Len[i]]) Len[i]++; //更新值 if(Len[i]+i&gt;mx) &#123; mx=Len[i]+i; po=i; &#125; if(Len[i]&gt;ans) ans=Len[i]; &#125; return ans-1;&#125; 1234567891011121314151617181920212223242526272829public class Solution &#123; public String Manacher(String s)&#123; if(s.length()&lt;2) return s; String t=\"$\"; int i=0,k=0,j=0; for(i=0;i&lt;s.length();i++) t+=\"#\"+s.charAt(i); t+=\"#@\"; int n=t.length(); int [] p=new int[n]; int mx=0; int id=0; int index=0; int maxLength=-1; for(i=1;i&lt;n-1;i++)&#123; p[i]=mx&gt;i ? Math.min(mx-i,p[2*id-i]):1;//第一种情况+第二种情况：第三种情况 while(t.charAt(i+p[i])==t.charAt(i-p[i])) p[i]++;//无论哪一种都可以进行拓展 if(mx&lt;i+p[i]) &#123;//更新右边界以及右边界的中心 mx=i+p[i]; id=i; &#125; if(maxLength&lt;p[i]-1)&#123;//更新最长回文串长度 maxLength=p[i]-1; index=i; &#125; &#125; int start=(index-maxLength)/2; return s.substring(start,start+maxLength); &#125;&#125; ​ https://blog.csdn.net/dyx404514/article/details/42061017","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"KMP","slug":"Algorithm/KMP","date":"2019-10-01T06:25:53.000Z","updated":"2020-03-23T14:19:45.078Z","comments":true,"path":"2019/10/01/ Algorithm/KMP/","link":"","permalink":"http://yoursite.com/2019/10/01/ Algorithm/KMP/","excerpt":"","text":"名字由来​ 由Knuth，Morris,Pratt三人所设计的线性时间字符串匹配算法 时间复杂度​ 设有长度为n的文本串S和长度为m的匹配串P，求匹配串成功匹配文本串字串的首地址 ​ O(n+m) 原理引出​ 对匹配串预处理生成一种失配的映射（或者称为函数，其实称为函数会更加恰当），我们姑且把这个函数成为Next函数。当匹配串对文本串进行匹配时，不妨想象一下，我们在失配的时候对应的失配位置i，都会有相同的移动位移，这样就会产生一个关于i的函数，我们姑且把这样的函数称之为Next(i)，那么这个函数的返回值是什么呢？在不同的博客上它的返回值是不一样的，比如，有些直接返回P下一个需要比较的位置，有些是返回P需要移动的距离（自行脑补一下），有些是返回最大该位置的最大的前后缀一样的字串的字符数，有些的Next函数是经过优化过的，自然返回值和原来的有些不一样。不过它们的使用方法都大同小异。 ​ 我们以返回值为P下一个需要匹配的位置为例。 Next函数的产生​ 先挖坑 1234567891011121314151617181920inline void GetNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; Next[j]=k; &#125; else &#123; k=Next[k]; &#125; &#125;&#125; NextPro数组的产生12345678910111213141516171819202122inline void GetProNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; //只是比Next数组多了一个判断罢了 if(P[j]!=P[k]) Next[j]=k; else Next[j]=Next[k]; &#125; else k=Next[k]; &#125;&#125; KMPSearch代码12345678910111213141516171819202122232425262728const int MAX=10010;char P[MAX];char S[MAX];int Next[MAX];int KmpSearch()&#123; GetProNext();//只需要在这里预处理P的Next数组即可 int sLen=strlen(S); int pLen=strlen(P); int i=0; int j=0; while(i&lt;sLen&amp;&amp;j&lt;pLen) &#123; if(j==-1||S[i]==P[j]) &#123; i++; j++; &#125; else &#123; j=Next[j]; &#125; &#125; if(j==pLen) return i-j; else return -1;&#125; 这个讲解很棒https://blog.csdn.net/v_JULY_v/article/details/7041827","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]}]}