{"meta":{"title":"zhongmz","subtitle":"Don","description":"写写算法 写写日记","author":"钟美智","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-09-23T05:28:32.000Z","updated":"2019-10-07T14:41:15.885Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2019-09-23T05:35:25.000Z","updated":"2019-10-07T14:52:04.209Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"week3","slug":"week3","date":"2019-11-25T13:35:21.000Z","updated":"2019-11-25T14:38:32.973Z","comments":true,"path":"2019/11/25/ week3/","link":"","permalink":"http://yoursite.com/2019/11/25/ week3/","excerpt":"","text":"a123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;struct node&#123; char data; node*Left; node*Right;&#125;;const int MAX=1e3;char str1[MAX];char str2[MAX];void Init()&#123; scanf(\"%s%s\",str1,str2);&#125;bool flag;//建立二叉树node*CreateBinTree(int s1,int e1,int s2,int e2)&#123; if(s1==e1&amp;&amp;s2==e2) &#123; if(str1[s1]==str2[s2]) &#123; node*t=new node; t-&gt;data=str1[s1]; t-&gt;Left=NULL; t-&gt;Right=NULL; return t; &#125; else &#123; flag=false; return NULL; &#125; &#125; char ch=str1[e1]; int i,j,k; for(i=s2;i&lt;=e2;i++) &#123; if(str2[i]==ch) &#123; break; &#125; &#125; if(i&gt;e2) &#123; flag=false; return NULL; &#125; node*t=new node; t-&gt;data=ch; t-&gt;Left=NULL; t-&gt;Right=NULL; //注意这里会有一些坑 if(i!=s2) t-&gt;Left=CreateBinTree(s1,e1-e2+i-1,s2,i-1); if(i!=e2) t-&gt;Right=CreateBinTree(e1-e2+i,e1-1,i+1,e2); return t;&#125;void Del(node*t)&#123; if(t==NULL) return ; Del(t-&gt;Left); Del(t-&gt;Right); delete t;&#125;//得到树的高度int LevelOrder(node*tree)&#123; node*t=tree; int ans=0; queue&lt;node*&gt; Q; if(t==NULL) &#123; return 0; &#125; node*p; Q.push(t); int total=1; int tt=0; while(Q.empty()==false) &#123; tt=0; ans++; while(total&gt;0) &#123; total--; p=Q.front(); Q.pop(); if(p-&gt;Left!=NULL) &#123; tt++; Q.push(p-&gt;Left); &#125; if(p-&gt;Right!=NULL) &#123; tt++; Q.push(p-&gt;Right); &#125; &#125; total=tt; &#125; return ans-1;&#125;//先根遍历二叉树void PreOreder(node*t)&#123; if(t==NULL) return ; printf(\"%c\",t-&gt;data); PreOreder(t-&gt;Left); PreOreder(t-&gt;Right);&#125;void Func()&#123; flag=true; node*t=CreateBinTree(0,strlen(str1)-1,0,strlen(str2)-1); if(flag==false) &#123; printf(\"INVALID\\n\"); Del(t); return ; &#125; printf(\"%d\\n\",LevelOrder(t)); PreOreder(t); Del(t);&#125;int main()&#123; Init(); Func(); return 0;&#125;/*CEFDBHGACBEDFAGHCBEDFAGHCEFDBHGABCACAB*/ b123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int MAX=1e3+10;char str[MAX][100];//假设每一个数字不超过100位int total;//一共多少个节点char s[MAX];int len;/*先由中缀表达式转换为后缀表达式，再由后缀表达式构建表达式树来计算表达式树的值*/class BinTreeNode&#123;public: BinTreeNode*left; BinTreeNode*right; char data[100];public: BinTreeNode(const char*ss=NULL,BinTreeNode*L=NULL,BinTreeNode*R=NULL):left(L),right(R)&#123;if(ss!=NULL)strcpy(data,ss);&#125; BinTreeNode*GetLeft()const &#123; return left; &#125; BinTreeNode*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode*L) &#123; left=L; &#125; void SetRight(BinTreeNode*R) &#123; right=R; &#125; char* GetData()&#123;return data;&#125; void SetData(const char*item)&#123;strcpy(data,item);&#125;&#125;;class pairn&#123;public: BinTreeNode* first; int second;&#125;;class Stack4&#123;public: pairn str[MAX]; int n=0; pairn Top() &#123; return str[n]; &#125; void Push(pairn p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;class Stack&#123;public: char str[MAX][100]; int n=0; char* Top() &#123; return str[n]; &#125; void Push(const char s[100]) &#123; n++; strcpy(str[n],s); &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;class Stack3&#123;public: int str[MAX]; int n=0; int Top() &#123; return str[n]; &#125; void Push(int p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;//将所有的数字转化为正数//不会出现2*(-3)的情况void Init()&#123; scanf(\"%s\",s); int i; int j; len=strlen(s); for(i=0;i&lt;len-1;i++) &#123; if(s[i]=='(') &#123; if(s[i+1]=='-') &#123; for(j=len;j&gt;i+1;j--) &#123; s[j]=s[j-1]; &#125; s[i+1]='0'; len++; &#125; &#125; &#125; s[len]=0;&#125;int f(char ch)&#123; if(ch=='*'||ch=='/') return 2; if(ch=='+'||ch=='-') return 1;&#125;void In_To_Post()&#123; int i,j,k; Stack S1; Stack S2; S1.n=0; S2.n=0; total=0; char str0[100]; for(i=0;i&lt;len;i++) &#123; j=0; //假设是数字 while(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'&amp;&amp;i!=len) &#123; str0[j]=s[i]; j++; i++; &#125; if(j!=0) &#123; str0[j]=0; S1.Push(str0); &#125; if(i==len) &#123; break; &#125; if(s[i]=='(') &#123; S2.Push(\"(\"); // cout&lt;&lt;\"TOP\"&lt;&lt;S2.Top()&lt;&lt;endl; &#125; if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/') &#123; // cout&lt;&lt;\"i:\"&lt;&lt;i&lt;&lt;\"s[i]:\"&lt;&lt;s[i]&lt;&lt;endl; str0[0]=s[i]; str0[1]=0; if((S2.Top())[0]=='('||S2.Empty()==true) S2.Push(str0); else &#123; while(S2.Top()[0]!='('&amp;&amp;f(S2.Top()[0])&gt;=f(str0[0])&amp;&amp;S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; S2.Push(str0); &#125; &#125; if(s[i]==')') &#123; while(S2.Top()[0]!='('&amp;&amp;S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; S2.Pop(); &#125; &#125; // cout&lt;&lt;\"S1.n: \"&lt;&lt;S1.n&lt;&lt;\" S2.n:\"&lt;&lt;S2.n&lt;&lt;endl; while(S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; total=S1.n; i=total; while(S1.Empty()==false) &#123; strcpy(str[i],S1.Top()); i--; S1.Pop(); &#125;&#125;/*1+2*3+(4*5+6)*7*/class Stack2&#123;public: BinTreeNode* str[MAX]; int n=0; BinTreeNode* Top() &#123; return str[n]; &#125; void Push(BinTreeNode*p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;BinTreeNode*CreateExprTree()&#123; BinTreeNode*root,*p; int i=1; Stack2 S2; S2.n=0; BinTreeNode*L; BinTreeNode*R; for(i=1;i&lt;=total;i++) &#123; if(str[i][0]=='+'||str[i][0]=='-'||str[i][0]=='*'||str[i][0]=='/') &#123; R=S2.Top(); S2.Pop(); L=S2.Top(); S2.Pop(); p=new BinTreeNode; p-&gt;SetData(str[i]); p-&gt;SetLeft(L); p-&gt;SetRight(R); S2.Push(p); &#125; else &#123; p=new BinTreeNode; p-&gt;SetData(str[i]); p-&gt;SetLeft(NULL); p-&gt;SetRight(NULL); S2.Push(p); &#125; &#125; root=S2.Top(); S2.Pop(); return root;&#125;int Ca(const char q[100])&#123; int sum=0; int i=0; for(i=0;q[i]!=0;i++) &#123; sum=sum*10+q[i]-'0'; &#125; return sum;&#125;const int ILL=-1e9;int GetValue(BinTreeNode*root)&#123; int sum=0; if(root==NULL) return 0; Stack3 Cac; pairn p; p.first=root; p.second=0; Stack4 P; P.Push(p); int i,j,k; int op1,op2; while(P.Empty()==false) &#123; p=P.Top(); P.Pop(); i=p.second; if(i==0) &#123; p.second++; P.Push(p); if(p.first-&gt;GetLeft()!=NULL) &#123; p.second=0; p.first=p.first-&gt;GetLeft(); P.Push(p);e &#125; &#125; if(i==1) &#123; p.second++; P.Push(p); if(p.first-&gt;GetRight()!=NULL) &#123; p.second=0; p.first=p.first-&gt;GetRight(); P.Push(p); &#125; &#125; if(i==2) &#123; if(p.first-&gt;GetLeft()==NULL&amp;&amp;p.first-&gt;GetRight()==NULL) &#123; Cac.Push(Ca(p.first-&gt;GetData())); &#125; else &#123; op2=Cac.Top(); Cac.Pop(); op1=Cac.Top(); Cac.Pop(); char y[100]; strcpy(y,p.first-&gt;GetData()); int ans=0; if(y[0]=='+')ans=op1+op2; if(y[0]=='-')ans=op1-op2; if(y[0]=='*')ans=op1*op2; if(y[0]=='/') &#123; if(op2==0) &#123; printf(\"ILLRGAL\\n\"); return ILL; &#125; ans=op1/op2; &#125; Cac.Push(ans); &#125; &#125; &#125; sum=Cac.Top(); return sum;&#125;/*1+10*2*/void Del(BinTreeNode*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;int main()&#123; Init(); In_To_Post(); BinTreeNode*root=CreateExprTree(); int ans=GetValue(root); if(ans!=ILL) printf(\"%d\\n\",ans); Del(root); return 0;&#125;","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"Warshall&All_componet","slug":"Warshall","date":"2019-11-18T13:44:59.000Z","updated":"2019-11-18T14:27:40.817Z","comments":true,"path":"2019/11/18/ Warshall/","link":"","permalink":"http://yoursite.com/2019/11/18/ Warshall/","excerpt":"","text":"Warshall &amp; All_componet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;struct Edge&#123; int VerAdj; int cost; Edge*link;&#125;;struct Vertex&#123; int VerName; Edge*adjacent;&#125;;struct node&#123; int VerName; node*link;&#125;;int graphsize;int edgesize;const int MAX=1e2;void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i,j,k; int from,to,cost; for(i=0;i&lt;graphsize;i++) &#123; S[i].adjacent=NULL; S[i].VerName=i; &#125; for(i=1;i&lt;=edgesize;i++) &#123; scanf(\"%d%d\",&amp;from,&amp;to); Edge*p=new Edge; p-&gt;cost=0; p-&gt;link=NULL; p-&gt;VerAdj=to; Edge*q=S[from].adjacent; if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; if(q-&gt;cost&gt;p-&gt;cost) &#123; delete q; S[from].adjacent=p; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; if(q-&gt;link==NULL) &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; else &#123; if(q-&gt;link-&gt;VerAdj==p-&gt;VerAdj) &#123; if(q-&gt;link-&gt;cost&gt;p-&gt;cost) &#123; Edge*q0=q-&gt;link; p-&gt;link=q0-&gt;link; q-&gt;link=p; delete q0; &#125; else delete p; &#125; else &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125; &#125; &#125;&#125;void Warshall(Vertex S[],int WSM[MAX][MAX])&#123; int i,j,k; Edge*p; int a; for(i=0;i&lt;graphsize;i++) &#123; for(j=0;j&lt;graphsize;j++) &#123; if(i==j) WSM[i][j]=1; else &#123; WSM[i][j]=0; WSM[j][i]=0; &#125; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; p=S[i].adjacent; a=S[i].VerName; while(p!=NULL) &#123; WSM[a][p-&gt;VerAdj]=1; p=p-&gt;link; &#125; &#125; for(k=0;k&lt;graphsize;k++) &#123; for(i=0;i&lt;graphsize;i++) &#123; if(WSM[i][k]==1) &#123; for(j=0;j&lt;graphsize;j++) &#123; WSM[i][j]=(WSM[i][j])||(WSM[k][j]); &#125; &#125; &#125; &#125;&#125;void All_componet(Vertex S[])&#123; int WSM[MAX][MAX]; int markedList[MAX]; int i,j,k; for(i=0;i&lt;graphsize;i++) markedList[i]=0; Warshall(S,WSM); int t=0; int v; for(v=0;v&lt;graphsize;v++) &#123; if(markedList[v]==0) &#123; markedList[v]=1; node*scList=new node; scList-&gt;VerName=v; scList-&gt;link=NULL; node*q=scList; for(i=0;i&lt;graphsize;i++) &#123; if(i!=v&amp;&amp;WSM[v][i]==1&amp;&amp;WSM[i][v]==1) &#123; markedList[i]=1; node*p=new node; p-&gt;VerName=i; p-&gt;link=NULL; q-&gt;link=p; q=q-&gt;link; &#125; &#125; printf(\"t:%d\\n\",t); t=t+1; q=scList; node*q0; while(q!=NULL) &#123; printf(\"%d \",q-&gt;VerName); q0=q; q=q-&gt;link; delete q0; &#125; cout&lt;&lt;endl; &#125; &#125;&#125;/*6 70 10 31 22 03 44 55 4*/int main()&#123; Vertex S[MAX]; Init(S); All_componet(S); return 0;&#125;","categories":[{"name":"图","slug":"图","permalink":"http://yoursite.com/categories/图/"}],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"week6","slug":"week6","date":"2019-11-17T08:54:51.000Z","updated":"2019-11-20T11:43:41.945Z","comments":true,"path":"2019/11/17/ week6/","link":"","permalink":"http://yoursite.com/2019/11/17/ week6/","excerpt":"","text":"a 关键路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int VerAdj; int cost; Edge*link;&#125;;struct Vertex&#123; int VerName; Edge*adjacent;&#125;;struct node&#123; int from; int to;&#125;;bool operator &lt;(const node&amp;a,const node&amp;b)&#123; if(a.from&lt;b.from) return true; if(a.from==b.from&amp;&amp;a.to&lt;b.to) return true; return false;&#125;const int MAX=1e4+10;int graphsize;int edgesize;int ans;int ve[MAX];int vl[MAX];int visited[MAX];int visited2[MAX];node sp[MAX];void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i,j,k; int from,to,cost; for(i=1;i&lt;=graphsize;i++) &#123; S[i].adjacent=NULL; S[i].VerName=i; visited[i]=0; visited2[i]=0; &#125; for(i=1;i&lt;=edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;from,&amp;to,&amp;cost); Edge*p=new Edge; p-&gt;cost=cost; p-&gt;link=NULL; p-&gt;VerAdj=to; Edge*q=S[from].adjacent; if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; if(q-&gt;cost&gt;p-&gt;cost) &#123; delete q; S[from].adjacent=p; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; if(q-&gt;link==NULL) &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; else &#123; if(q-&gt;link-&gt;VerAdj==p-&gt;VerAdj) &#123; if(q-&gt;link-&gt;cost&gt;p-&gt;cost) &#123; Edge*q0=q-&gt;link; p-&gt;link=q0-&gt;link; q-&gt;link=p; delete q0; &#125; else delete p; &#125; else &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125; &#125; &#125;&#125;void Del(Vertex S[])&#123; int i; for(i=0;i&lt;graphsize;i++) &#123; Edge*p=S[i].adjacent; while(p!=NULL) &#123; Edge*q=p; p=p-&gt;link; delete q; &#125; &#125;&#125;//ÍØÆËÅÅÐòºóµÄ¶¥µã±ívoid AOE(Vertex S[])&#123; int i,j,k,b; int total=0; ans=0; for(i=1;i&lt;=graphsize;i++) &#123; ve[i]=0; vl[i]=0; &#125; for(i=1;i&lt;=graphsize;i++) &#123; Edge*p=S[i].adjacent; while(p!=NULL) &#123; k=p-&gt;VerAdj; if(ve[S[i].VerName]+p-&gt;cost&gt;ve[k]) ve[k]=ve[S[i].VerName]+p-&gt;cost; p=p-&gt;link; &#125; &#125; for(i=1;i&lt;=graphsize;i++) &#123; vl[i]=ve[graphsize]; &#125; for(i=graphsize-1;i&gt;0;i--) &#123; Edge*p=S[i].adjacent; while(p!=NULL) &#123; k=p-&gt;VerAdj; if(vl[k]-p-&gt;cost&lt;vl[S[i].VerName]) vl[S[i].VerName]=vl[k]-p-&gt;cost; p=p-&gt;link; &#125; &#125; for(i=1;i&lt;=graphsize;i++) &#123; Edge*p=S[i].adjacent; while(p!=NULL) &#123; k=p-&gt;VerAdj; int e=ve[S[i].VerName]; int l=vl[k]-p-&gt;cost; if(l==e) &#123; //printf(\"&lt;%d,%d&gt;\\n\",S[i].VerName,k); total++; sp[total].from=S[i].VerName; sp[total].to=k; if(visited[S[i].VerName]==0&amp;&amp;visited2[k]==0) &#123; ans=ans+p-&gt;cost; visited[S[i].VerName]=1; visited2[k]=1; /* if(k==S[graphsize].VerName) &#123; printf(\"%d\\n\",ans); sort(sp+1,sp+total+1); for(j=1;j&lt;=total;j++) &#123; printf(\"%d %d\\n\",sp[j].from,sp[j].to); &#125; return ; &#125;*/ &#125; &#125; p=p-&gt;link; &#125; &#125; printf(\"%d\\n\",ans); sort(sp+1,sp+total+1); for(j=1;j&lt;=total;j++) &#123; printf(\"%d-&gt;%d\\n\",sp[j].from,sp[j].to); &#125;&#125;bool Toporder(Vertex S[],Vertex S1[])&#123; int du[MAX]; int i,j,k; int n=graphsize; for(i=1;i&lt;=n;i++) &#123; du[i]=0; &#125; for(i=1;i&lt;=n;i++) &#123; Edge*p=S[i].adjacent; while(p!=NULL) &#123; du[p-&gt;VerAdj]++; p=p-&gt;link; &#125; &#125; queue&lt;int&gt; Q; for(i=1;i&lt;=n;i++) &#123; // printf(\"%d %d\\n\",i,du[i]); if(du[i]==0) &#123; Q.push(S[i].VerName); &#125; &#125; int total=1; for(i=1;i&lt;=n;i++) &#123; if(Q.empty()==true) &#123; printf(\"unworkable project\\n\"); return true; &#125; j=Q.front(); Q.pop(); S1[total]=S[j]; total++; Edge*p=S[j].adjacent; while(p!=NULL) &#123; k=p-&gt;VerAdj; du[k]--; if(du[k]==0) &#123; Q.push(k); &#125; p=p-&gt;link; &#125; &#125; return false;&#125;void Func(Vertex S[])&#123; Vertex S1[MAX]; bool flag=Toporder(S,S1); if(flag==false) &#123; AOE(S1); &#125;&#125;int main()&#123; Vertex S[MAX]; Init(S); Func(S); Del(S); return 0;&#125;/*4 41 2 61 3 42 4 13 4 19 121 2 61 3 41 4 52 5 13 5 14 6 25 7 95 8 76 8 48 9 47 9 28 7 109 111 2 61 3 41 4 52 5 13 5 14 6 25 7 95 8 76 8 48 9 47 9 29 121 2 61 2 1001 3 41 4 52 5 13 5 14 6 25 7 95 8 76 8 48 9 47 9 210 131 2 51 3 62 4 33 4 63 5 34 5 34 6 45 7 15 8 47 9 58 9 26 10 49 10 29 111 2 61 3 41 4 52 5 13 5 14 6 25 7 95 8 76 8 48 9 47 9 27 101 2 31 4 61 3 22 5 42 4 23 4 13 6 34 5 15 7 36 7 4*/ b Kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int cost; int head; int tail;&#125;;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; if(a.cost&lt;b.cost) return true; return false;&#125;const int MAX=1e6;edge E[MAX];edge TE[MAX];int graphsize;int edgesize;void Init()&#123; int i; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;E[i].head,&amp;E[i].tail,&amp;E[i].cost); &#125; sort(E,E+edgesize);&#125;//Kruskalint Make_set[MAX];int Rank[MAX];void init()&#123; int i; for(i=0;i&lt;graphsize;i++) &#123; Make_set[i]=i; Rank[i]=0; &#125;&#125;//找到其父亲并且优化并查集int Find(int x)&#123; int k,j,r; r=x; while(r!=Make_set[r]) r=Make_set[r]; k=x; while(k!=r) &#123; j=Make_set[k]; Make_set[k]=r; k=j; &#125; return r;&#125;//结合，并且降低时间复杂度void Union(int x,int y)&#123; int f1=Find(x); int f2=Find(y); if(Rank[f1]&lt;=Rank[f2]) &#123; Make_set[f1]=f2; if(Rank[f1]==Rank[f2]) Rank[f2]++; &#125; else &#123; Make_set[f2]=f1; &#125;&#125;void Kruskal()&#123; init(); int T=graphsize; int total=1; int count=0; int j=0; int ans=0; int tt=0; while(j&lt;edgesize) &#123; int vex1=E[j].head; int vex2=E[j].tail; int cost=E[j].cost; if(Find(vex1)!=Find(vex2)) &#123; ans=ans+cost; TE[count].head=vex1; TE[count].tail=vex2; TE[count].cost=cost; count++; Union(vex1,vex2); total++; &#125; j++; &#125; /* for(j=0;j&lt;count;j++) &#123; printf(\"head:%d tail:%d cost:%d\\n\",TE[j].head,TE[j].tail,TE[j].cost); &#125;*/ if(total==graphsize) printf(\"%d\\n\",ans); else printf(\"There is no minimum spanning tree.\\n\");&#125;int main()&#123; Init(); Kruskal(); return 0;&#125;/*6 100 1 10 2 40 3 71 2 42 3 21 5 22 5 52 4 33 4 64 5 34 50 1 10 3 11 3 51 2 12 3 84 20 1 12 3 8*/ Prim 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int cost; int head; int tail;&#125;;const int MAX=1e6;edge E[MAX];edge TE[MAX];int graphsize;int edgesize;struct LV&#123; int Lowcost; int Vex;&#125;;LV closedge[MAX];int Edge[5010][5010];//稠密图，使用邻接矩阵void Prim()&#123; int i; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); for(i=0;i&lt;graphsize;i++) &#123; for(int j=0;j&lt;graphsize;j++) &#123; Edge[i][j]=1e9; Edge[j][i]=1e9; &#125; &#125; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;E[i].head,&amp;E[i].tail,&amp;E[i].cost); if(E[i].cost&lt;Edge[E[i].head][E[i].tail]) &#123; Edge[E[i].head][E[i].tail]=E[i].cost; Edge[E[i].tail][E[i].head]=E[i].cost; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; closedge[i].Lowcost=Edge[0][i]; closedge[i].Vex=0; &#125; closedge[0].Vex=-1; int count=0; int ans=0; for(i=1;i&lt;graphsize;i++) &#123; int Min=1e9; int v=-1; for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;closedge[j].Lowcost&lt;Min) &#123; v=j; Min=closedge[j].Lowcost; &#125; &#125; if(v!=-1) &#123; ans=ans+closedge[v].Lowcost; TE[count].head=closedge[v].Vex; TE[count].tail=v; TE[count].cost=closedge[v].Lowcost; count++; closedge[v].Lowcost=0; closedge[v].Vex=-1; //进行一些操作使得它们保持最小 for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;Edge[v][j]&lt;closedge[j].Lowcost) &#123; closedge[j].Lowcost=Edge[v][j]; closedge[j].Vex=v; &#125; &#125; &#125; else &#123; printf(\"There is no minimum spanning tree.\\n\"); return ; &#125; &#125; printf(\"%d\",ans);&#125;//prim/*6 100 1 10 2 40 3 71 2 42 3 21 5 22 5 52 4 33 4 64 5 3*/int main()&#123; Prim();&#125; c火神tql，1.两次Dijkstra 2.多重图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;struct Edge&#123; int VerAdj;//临接终点，从0开始编号 int cost;//花费 Edge*link;//下一个边&#125;;struct Vertex&#123; int VerName;//顶点的编号 Edge*adjacent;//第一条边&#125;;int graphsize;//顶点个数int edgesize;//边的数量const int MAX=10010;//顶点的个数int path[MAX];//路径//距离int s;int t;//建图void Init(Vertex S[])&#123; scanf(\"%d%d%d%d\",&amp;graphsize,&amp;s,&amp;t,&amp;edgesize); int i; for(i=1;i&lt;=graphsize;i++) &#123; S[i].VerName=i; S[i].adjacent=NULL; &#125; int from,to,cost; for(i=1;i&lt;=edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;from,&amp;to,&amp;cost); Edge*p=new Edge; p-&gt;cost=cost; p-&gt;VerAdj=to; p-&gt;link=NULL; Edge*q=S[from].adjacent; //使其能保持编号小的终点在前 if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; p=new Edge; p-&gt;cost=cost; p-&gt;link=NULL; p-&gt;VerAdj=from; q=S[to].adjacent; if(q==NULL) &#123; S[to].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[to].adjacent=p; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125;&#125;int visited[MAX];//Dijkstraint Dijkstra(Vertex*S,int v,int dist[])&#123; int j; int u,k; Edge*p; int n=graphsize; int i; for(i=1;i&lt;=n;i++) &#123; path[i]=-1; dist[i]=1e9; visited[i]=0; &#125; dist[v]=0; visited[v]=1; p=S[v].adjacent; u=v; for(i=1;i&lt;=n;i++) &#123; //缩紧操作 while(p!=NULL) &#123; k=p-&gt;VerAdj; if(visited[k]!=1&amp;&amp;dist[u]+p-&gt;cost&lt;dist[k]) &#123; dist[k]=dist[u]+p-&gt;cost; path[k]=u; &#125; p=p-&gt;link; &#125; int idist=1e9; for(j=1;j&lt;=n;j++) &#123; if(dist[j]&gt;=0&amp;&amp;dist[j]&lt;idist&amp;&amp;visited[j]==0) &#123; idist=dist[j]; u=j; &#125; &#125; visited[u]=1; p=S[u].adjacent; &#125; return dist[t];&#125;void Del(Vertex S[])&#123; int i; for(i=0;i&lt;graphsize;i++) &#123; Edge*p=S[i].adjacent; while(p!=NULL) &#123; Edge*p1=p; p=p-&gt;link; delete p1; &#125; &#125;&#125;int main()&#123; int dist[MAX]; int dist0[MAX]; Vertex S[MAX]; Init(S); int vi[MAX]; int i; int j; int v=1; int g; //对起点和终点都进行一次DIJ Dijkstra(S,s,dist); Dijkstra(S,t,dist0); int u; int Min=1e9; int ans=1e9; for(i=1;i&lt;=graphsize;i++) &#123; Edge*p=S[i].adjacent; u=S[i].VerName; while(p!=NULL) &#123; v=p-&gt;VerAdj; g=dist[u]+dist0[v]; if(g&lt;Min) &#123; Min=g; ans=u; &#125; p=p-&gt;link; &#125; &#125; printf(\"%d %d\\n\",Min,ans); return 0;&#125;/*4 40 1 10 3 11 3 12 0 14 50 1 40 2 11 3 12 1 12 3 1006 100 1 120 2 51 2 51 4 200 3 82 3 62 4 102 5 83 5 44 5 64 1 4 41 2 92 4 11 3 33 4 5*/","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"Prim","slug":"Prim","date":"2019-11-13T14:42:33.000Z","updated":"2019-11-13T14:43:48.290Z","comments":true,"path":"2019/11/13/ Prim/","link":"","permalink":"http://yoursite.com/2019/11/13/ Prim/","excerpt":"","text":"Prim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int cost; int head; int tail;&#125;;const int MAX=1e6;edge E[MAX];edge TE[MAX];int graphsize;int edgesize;struct LV&#123; int Lowcost; int Vex;&#125;;LV closedge[MAX];int Edge[5010][5010];//稠密图，使用邻接矩阵void Prim()&#123; int i; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); for(i=0;i&lt;graphsize;i++) &#123; for(int j=0;j&lt;graphsize;j++) &#123; Edge[i][j]=1e9; Edge[j][i]=1e9; &#125; &#125; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;E[i].head,&amp;E[i].tail,&amp;E[i].cost); //防止重边 if(E[i].cost&lt;Edge[E[i].head-1][E[i].tail-1]) &#123; Edge[E[i].head-1][E[i].tail-1]=E[i].cost; Edge[E[i].tail-1][E[i].head-1]=E[i].cost; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; closedge[i].Lowcost=Edge[0][i]; closedge[i].Vex=0; &#125; closedge[0].Vex=-1; int count=0; int ans=0; for(i=1;i&lt;graphsize;i++) &#123; int Min=1e9+1; int v=0; for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;closedge[j].Lowcost&lt;Min) &#123; v=j; Min=closedge[j].Lowcost; &#125; &#125; if(v!=0) &#123; ans=ans+closedge[v].Lowcost; TE[count].head=closedge[v].Vex; TE[count].tail=v; TE[count].cost=closedge[v].Lowcost; count++; closedge[v].Lowcost=0; closedge[v].Vex=-1; //进行一些操作使得它们保持最小 for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;Edge[v][j]&lt;closedge[j].Lowcost) &#123; closedge[j].Lowcost=Edge[v][j]; closedge[j].Vex=v; &#125; &#125; &#125; &#125; printf(\"%d\",ans);&#125;//prim/*6 100 1 10 2 40 3 71 2 42 3 21 5 22 5 52 4 33 4 64 5 3*/int main()&#123; Prim();&#125;","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"Kruskal","slug":"Kruskal-1","date":"2019-11-13T13:24:25.000Z","updated":"2019-11-13T14:44:09.625Z","comments":true,"path":"2019/11/13/ Kruskal-1/","link":"","permalink":"http://yoursite.com/2019/11/13/ Kruskal-1/","excerpt":"","text":"Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int cost; int head; int tail;&#125;;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; if(a.cost&lt;b.cost) return true; return false;&#125;const int MAX=1e6;edge E[MAX];edge TE[MAX];int graphsize;int edgesize;void Init()&#123; int i; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;E[i].head,&amp;E[i].tail,&amp;E[i].cost); &#125; sort(E,E+edgesize);&#125;//Kruskalint Make_set[MAX];int Rank[MAX];void init()&#123; int i; for(i=0;i&lt;graphsize;i++) &#123; Make_set[i]=i; Rank[i]=0; &#125;&#125;//找到其父亲并且优化并查集int Find(int x)&#123; int k,j,r; r=x; while(r!=Make_set[r]) r=Make_set[r]; k=x; while(k!=r) &#123; j=Make_set[k]; Make_set[k]=r; k=j; &#125; return r;&#125;//结合，并且降低时间复杂度void Union(int x,int y)&#123; int f1=Find(x); int f2=Find(y); if(Rank[f1]&lt;=Rank[f2]) &#123; Make_set[f1]=f2; if(Rank[f1]==Rank[f2]) Rank[f2]++; &#125; else &#123; Make_set[f2]=f1; &#125;&#125;void Kruskal()&#123; init(); int T=graphsize; int total=1; int count=0; int j=0; int ans=0; while(total!=T) &#123; int vex1=E[j].head; int vex2=E[j].tail; int cost=E[j].cost; if(Find(vex1)!=Find(vex2)) &#123; ans=ans+cost; TE[count].head=vex1; TE[count].tail=vex2; TE[count].cost=cost; count++; Union(vex1,vex2); total++; &#125; j++; &#125; /* for(j=0;j&lt;count;j++) &#123; printf(\"head:%d tail:%d cost:%d\\n\",TE[j].head,TE[j].tail,TE[j].cost); &#125;*/ printf(\"%d\\n\",ans);&#125;int main()&#123; Init(); Kruskal(); return 0;&#125;/*6 100 1 10 2 40 3 71 2 42 3 21 5 22 5 52 4 33 4 64 5 3*/","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"week5","slug":"week5","date":"2019-11-12T14:08:48.000Z","updated":"2019-11-14T03:48:36.403Z","comments":true,"path":"2019/11/12/ week5/","link":"","permalink":"http://yoursite.com/2019/11/12/ week5/","excerpt":"","text":"Dijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;struct Edge&#123; int VerAdj;//临接终点，从0开始编号 int cost;//花费 Edge*link;//下一个边&#125;;struct Vertex&#123; int VerName;//顶点的编号 Edge*adjacent;//第一条边&#125;;int graphsize;//顶点个数int edgesize;//边的数量const int MAX=50010;//顶点的个数int path[MAX];//路径int dist[MAX];//距离void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i; for(i=0;i&lt;graphsize;i++) &#123; S[i].VerName=i; S[i].adjacent=NULL; &#125; int from,to,cost; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;from,&amp;to,&amp;cost); Edge*p=new Edge; p-&gt;cost=cost; p-&gt;VerAdj=to; p-&gt;link=NULL; Edge*q=S[from].adjacent; //使其能保持编号小的终点在前 if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125;&#125; int visited[MAX];void Dijkstra(Vertex*S,int v)&#123; int j; int u,k; Edge*p; int n=graphsize; int i; for(i=0;i&lt;n;i++) &#123; path[i]=-1; dist[i]=1e9; visited[i]=0; &#125; dist[v]=0; visited[v]=1; p=S[v].adjacent; u=v; for(i=0;i&lt;n;i++) &#123; //缩紧操作 while(p!=NULL) &#123; k=p-&gt;VerAdj; if(visited[k]!=1&amp;&amp;dist[u]+p-&gt;cost&lt;dist[k]) &#123; dist[k]=dist[u]+p-&gt;cost; path[k]=u; &#125; p=p-&gt;link; &#125; int idist=1e9; for(j=0;j&lt;n;j++) &#123; if(dist[j]&gt;0&amp;&amp;dist[j]&lt;idist&amp;&amp;visited[j]==0) &#123; idist=dist[j]; u=j; &#125; &#125; visited[u]=1; p=S[u].adjacent; &#125; for(i=1;i&lt;n;i++) &#123; if(path[i]!=-1) &#123; if(i==1) printf(\"%d\",dist[i]); else printf(\" %d\",dist[i]); &#125; &#125; cout&lt;&lt;endl;&#125;void Del(Vertex S[])&#123; int i; for(i=0;i&lt;graphsize;i++) &#123; Edge*p=S[i].adjacent; while(p!=NULL) &#123; Edge*p1=p; p=p-&gt;link; delete p1; &#125; &#125;&#125;int main()&#123; Vertex S[MAX]; Init(S); int vi[MAX]; int i; Dijkstra(S,0); return 0;&#125;/*4 40 1 10 3 11 3 12 0 14 50 1 40 2 11 3 12 1 12 3 1006 100 1 120 2 51 2 51 4 200 3 82 3 62 4 102 5 83 5 44 5 6*/ 只能责怪自己图论的题目写的太少了 DFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;struct Edge&#123; int VerAdj;//临接终点，从0开始编号 int cost;//花费 Edge*link;//下一个边&#125;;struct Vertex&#123; int VerName;//顶点的编号 Edge*adjacent;//第一条边&#125;;int graphsize;//顶点个数int edgesize;const int MAX=30100;//顶点的个数Vertex S[MAX];int visited[MAX];void Init()&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i; for(i=0;i&lt;graphsize;i++) &#123; S[i].VerName=i; S[i].adjacent=NULL; &#125; int from,to,cost; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d\",&amp;from,&amp;to); Edge*p=new Edge; p-&gt;cost=0; p-&gt;VerAdj=to; p-&gt;link=NULL; Edge*q=S[from].adjacent; //使其能保持编号小的终点在前 if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125;&#125;int tag;void DFS(int v)&#123; if(tag!=0) &#123; printf(\" %d\",v); &#125; else &#123; tag=1; printf(\"%d\",v); &#125; visited[v]=1; Edge*p=S[v].adjacent; while(p!=NULL) &#123; if(visited[p-&gt;VerAdj]!=1) &#123; DFS(p-&gt;VerAdj); &#125; p=p-&gt;link; &#125;&#125;void DFS_main()&#123; int i; for(i=0;i&lt;graphsize;i++) &#123; visited[i]=0; &#125; for(i=0;i&lt;graphsize;i++) &#123; if(visited[i]==0) &#123; DFS(i); &#125; &#125; cout&lt;&lt;endl;&#125;int main()&#123; tag=0; //Vertex S[MAX]; Init(); DFS_main(); return 0;&#125;/*3 30 11 20 24 40 20 11 23 010 110 60 11 22 43 44 55 02 36 57 97 05 20 12 4*/ BFS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct Edge&#123; int VerAdj;//临接终点，从0开始编号 int cost;//花费 Edge*link;//下一个边&#125;;struct Vertex&#123; int VerName;//顶点的编号 Edge*adjacent;//第一条边&#125;;int graphsize;//顶点个数int edgesize;const int MAX=50010;//顶点的个数void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i; for(i=0;i&lt;graphsize;i++) &#123; S[i].VerName=i; S[i].VerName=NULL; &#125; int from,to,cost; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d\",&amp;from,&amp;to); Edge*p=new Edge; p-&gt;cost=0; p-&gt;VerAdj=to; p-&gt;link=NULL; Edge*q=S[from].adjacent; //使其能保持编号小的终点在前 if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125;&#125;void BFS(Vertex S[],int visited[],int v)&#123; queue&lt;int&gt; Q; int i; printf(\"%d \",v); visited[v]=1; Q.push(v); while(Q.empty()==false) &#123; v=Q.front(); Q.pop(); Edge*p=S[v].adjacent; while(p!=NULL) &#123; if(visited[p-&gt;VerAdj]==0) &#123; printf(\"%d \",p-&gt;VerAdj); visited[p-&gt;VerAdj]=1; Q.push(p-&gt;VerAdj); &#125; p=p-&gt;link; &#125; &#125;&#125;void BFS_main(Vertex S[])&#123; int visited[MAX]; int i; for(i=0;i&lt;graphsize;i++) visited[i]=0; for(i=0;i&lt;graphsize;i++) &#123; if(visited[i]==0) &#123; BFS(S,visited,i); &#125; &#125;&#125;int main()&#123; Vertex S[MAX]; Init(S); BFS_main(S); return 0;&#125;/*6 55 00 11 20 34 0*/ 拓扑排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct Edge&#123; int VerAdj;//临接终点，从0开始编号 int cost;//花费 Edge*link;//下一个边&#125;;struct Vertex&#123; int VerName;//顶点的编号 Edge*adjacent;//第一条边&#125;;int graphsize;//顶点个数int edgesize;const int MAX=50010;//顶点的个数void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i; for(i=0;i&lt;graphsize;i++) &#123; S[i].VerName=i; S[i].VerName=NULL; &#125; int from,to,cost; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d\",&amp;from,&amp;to); Edge*p=new Edge; p-&gt;cost=0; p-&gt;VerAdj=to; p-&gt;link=NULL; Edge*q=S[from].adjacent; //使其能保持编号小的终点在前 if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125;&#125;void TopoOrder(Vertex S[],int n)&#123; int count[MAX]; int i,j,k; for(i=0;i&lt;n;i++) &#123; count[i]=0; &#125; Edge*p; for(i=0;i&lt;n;i++) &#123; p=S[i].adjacent; while(p!=NULL) &#123; count[p-&gt;VerAdj]++; p=p-&gt;link; &#125; //初始化度 &#125; int top=-1; //虚拟的栈顶指针，每一个都一环套着一环 for(i=0;i&lt;n;i++) &#123; if(count[i]==0) &#123; count[i]=top; top=i; &#125; &#125; for(i=0;i&lt;n;i++) &#123; if(top==-1) &#123; printf(\"There if a cycle in network\\n\"); return ; &#125; else &#123; j=top; top=count[top]; printf(\"%d \",j); p=S[j].adjacent; while(p!=NULL) &#123; k=p-&gt;VerAdj; count[k]--; if(count[k]==0) &#123; count[k]=top; top=k; &#125; p=p-&gt;link; &#125; &#125; &#125;&#125;int main()&#123; Vertex S[MAX]; Init(S); TopoOrder(S,graphsize); return 0;&#125;/*6 60 10 20 32 12 43 4*/ c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=400;int S[MAX][MAX];int du[MAX];int main()&#123; int n; int m; scanf(\"%d%d\",&amp;n,&amp;m); int i; int a,b; for(i=0;i&lt;n;i++) &#123; du[i]=0; &#125; for(i=0;i&lt;m;i++) &#123; scanf(\"%d%d\",&amp;a,&amp;b); S[a][b]=1; du[b]++; &#125; int j; int tot=0; int tag=0; while(tot!=n) &#123; for(i=0;i&lt;n;i++) &#123; int g=i; if(du[i]==0) &#123; tot++; printf(\"%d \",g); if(tot==n) &#123; break; &#125; du[g]=-1; for(j=0;j&lt;n;j++) &#123; if(S[g][j]==1) &#123; du[j]--; S[g][j]=-1; S[j][g]=-1; &#125; &#125; i=0; &#125; &#125; &#125; return 0;&#125;/*6 60 10 20 32 12 43 45 30 12 34 3*/","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"week4","slug":"week4","date":"2019-11-05T10:09:57.000Z","updated":"2019-11-13T12:15:41.500Z","comments":true,"path":"2019/11/05/ week4/","link":"","permalink":"http://yoursite.com/2019/11/05/ week4/","excerpt":"","text":"1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=1e6+10;struct node&#123; node*LLINK; node*RLINK; char ch; int weight;&#125;;struct cr&#123; int data1; int data2; char ch;&#125;;cr CR[30];bool operator &lt;(const node&amp;a,const node&amp;b)&#123; if(a.weight&gt;=b.weight) return false; return true;&#125;bool operator &lt;(const cr&amp;a,const cr&amp;b)&#123; if(a.data1&lt;b.data1) return true; if(a.data1==b.data1&amp;&amp;a.data2&lt;b.data2) return true; return false;&#125;struct CH&#123; char date[20];&#125;;int total=0;CH S[MAX];node H[MAX];int m;char str1[MAX];char str2[MAX];char str[MAX];//得到构造哈夫曼树的数组void Init()&#123; m=0; scanf(\"%s%s%s\",str,str1,str2); int i; int j; bool flag; for(i=0;i&lt;30;i++) &#123; CR[i].data1=0; CR[i].data2=0; &#125; int tag=0; for(i=0;i&lt;strlen(str);i++) &#123; CR[str[i]-'a'+1].data1++; CR[str[i]-'a'+1].ch=str[i]; if(CR[str[i]-'a'+1].data2==0) &#123; tag++; CR[str[i]-'a'+1].data2=tag; &#125; flag=false; for(j=1;j&lt;=m;j++) &#123; if(str[i]==H[j].ch) &#123; H[j].weight++; flag=true; &#125; &#125; if(flag==false) &#123; m++; H[m].ch=str[i]; H[m].LLINK=NULL; H[m].RLINK=NULL; H[m].weight=1; &#125; &#125; for(i=0;i&lt;=28;i++) &#123; S[i].date[0]=0; &#125; sort(H+1,H+m+1);&#125;node*Huffman()&#123; node**h=new node*[m+1]; int i,j,k; for(i=1;i&lt;=m;i++) &#123; h[i]=new node; h[i]-&gt;ch=H[i].ch; h[i]-&gt;LLINK=NULL; h[i]-&gt;RLINK=NULL; h[i]-&gt;weight=H[i].weight; &#125; node*t=NULL; for(i=1;i&lt;m;i++) &#123; t=new node; t-&gt;weight=h[i]-&gt;weight+h[i]-&gt;weight; t-&gt;ch=-10; t-&gt;LLINK=h[i]; t-&gt;RLINK=h[i+1]; j=i+2; while(j&lt;=m&amp;&amp;t-&gt;weight&gt;=h[j]-&gt;weight) &#123; h[j-1]=h[j]; j++; &#125; h[j-1]=t; &#125; node*head=h[m]; // delete node []; return head;&#125;/*cbaxyyzz0100011*/int len;char ss[MAX];int ans;void DFS(node*t)&#123; if(len==0&amp;&amp;t-&gt;LLINK==NULL) &#123; ans=t-&gt;weight; strcpy(S[t-&gt;ch-'a'+1].date,\"0\"); return ; &#125; if(t-&gt;LLINK==NULL&amp;&amp;t-&gt;RLINK==NULL) &#123; ans=ans+len*t-&gt;weight; len++; ss[len]=0; strcpy(S[t-&gt;ch-'a'+1].date,ss+1); //printf(\"%c:%s\\n\",t-&gt;ch,S[t-&gt;ch-'a'+1].date); len--; return ; &#125; len++; ss[len]='0'; DFS(t-&gt;LLINK); ss[len]='1'; DFS(t-&gt;RLINK); len--;&#125;node*head;void Func()&#123; int kk=ans%8; ans=ans/8; if(kk!=0) ans++; printf(\"%d %d\\n\",strlen(str),ans); if(head-&gt;LLINK==NULL) &#123; printf(\"%c:%s\\n\",str[0],S[str[0]-'a'+1].date); //cout&lt;&lt;\"ssssss\"&lt;&lt;endl; int i; int fflag=-1; for(i=0;i&lt;strlen(str1);i++) &#123; if(str1[i]!='0') &#123; printf(\"INVALID\\n\"); fflag=1; break; &#125; &#125; if(fflag!=1) &#123; for(i=0;i&lt;strlen(str1);i++) &#123; printf(\"%c\",str[0]); &#125; cout&lt;&lt;endl; &#125; fflag=-1; for(i=0;i&lt;strlen(str2);i++) &#123; if(str2[i]!='0') &#123; printf(\"INVALID\\n\"); fflag=1; break; &#125; &#125; if(fflag!=1) &#123; for(i=0;i&lt;strlen(str2);i++) &#123; printf(\"%c\",str[0]); &#125; cout&lt;&lt;endl; &#125; return ; &#125; //printf(\"%d\\n\",ans); bool flag[30]; int i; sort(CR,CR+30); for(i=0;i&lt;30;i++) &#123; if(CR[i].data1!=0) &#123; printf(\"%c:%s\\n\",CR[i].ch,S[CR[i].ch-'a'+1].date); &#125; &#125; char str4[MAX]; int g=0; int j=0,k=0,p,y; char str3[30]; int f1=0; int f2=0; g=0; for(i=0;i&lt;strlen(str1)&amp;&amp;j&lt;strlen(str1);) &#123; f1=0; for(k=1;k&lt;=28;k++) &#123; if(strlen(S[k].date)==j-i+1&amp;&amp;S[k].date[0]!=0) &#123; //printf(\"sssss %s\\n\",S[k].date); //判断这个编码是否是符合的编码 f2=1; for(p=0;p&lt;strlen(S[k].date);p++) &#123; if(S[k].date[p]!=str1[i+p]) &#123; f2=0; break; &#125; &#125; if(f2==1) &#123; //printf(\"%c\",k+'a'-1) f1=1; g++; str4[g]=k+'a'-1; // printf(\"%c\",k+'a'-1); break; &#125; &#125; if(f1==1) &#123; break; &#125; &#125; if(f1==0) j++; else &#123; j++; i=j; &#125; &#125; if(i==j) &#123; for(k=1;k&lt;=g;k++) &#123; printf(\"%c\",str4[k]); &#125; cout&lt;&lt;endl; &#125; else &#123; // cout&lt;&lt;\"in1\"&lt;&lt;endl; printf(\"INVALID\\n\"); &#125; g=0; f1=0; f2=0; g=0; j=0; for(i=0;i&lt;strlen(str2)&amp;&amp;j&lt;strlen(str2);) &#123; //printf(\"%d %d\\n\",i,j); // cout&lt;&lt;g&lt;&lt;endl; f1=0; for(k=1;k&lt;=28;k++) &#123; if(strlen(S[k].date)==j-i+1&amp;&amp;S[k].date[0]!=0) &#123; //printf(\"sssss %s\\n\",S[k].date); //判断这个编码是否是符合的编码 f2=1; for(p=0;p&lt;strlen(S[k].date);p++) &#123; if(S[k].date[p]!=str2[i+p]) &#123; f2=0; break; &#125; &#125; if(f2==1) &#123; //printf(\"%c\",k+'a'-1) f1=1; g++; str4[g]=k+'a'-1; // printf(\"%c\",k+'a'-1); break; &#125; &#125; if(f1==1) &#123; break; &#125; &#125; if(f1==0) j++; else &#123; j++; i=j; &#125; &#125; if(i==j) &#123; for(k=1;k&lt;=g;k++) &#123; printf(\"%c\",str4[k]); &#125; cout&lt;&lt;endl; &#125; else &#123; // cout&lt;&lt;\"in1\"&lt;&lt;endl; printf(\"INVALID\\n\"); &#125;&#125;int main()&#123; Init(); int i; head=Huffman(); len=0; total=0; ans=0; // printf(\"weight:%d\\n\",head-&gt;weight); DFS(head); Func(); return 0;&#125;/*aaaaa010cbaxyyzz0100011ababab10abcabc00*/ 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;struct node&#123; char ch; node*Left; node*Right;&#125;;int s[10];const int MAX=1e5+10;const char stop='#';char ch;node*Create()&#123; node*t,*t1,*t2; cin&gt;&gt;ch; if(ch==stop) &#123; t=NULL; return t; &#125; t=new node; t-&gt;ch=ch; t-&gt;Left=Create(); t-&gt;Right=Create(); return t;&#125;void Del(node*t)&#123; if(t!=NULL) &#123; Del(t-&gt;Left); Del(t-&gt;Right); delete t; &#125;&#125;node*head=NULL;void InOrder(node*t)&#123; if(t-&gt;Left==NULL) &#123; printf(\"%c\",t-&gt;ch); return ; &#125; int flag=-1; if(s[t-&gt;Left-&gt;ch-40]&lt;s[t-&gt;ch-40]&amp;&amp;t-&gt;Left-&gt;Left!=NULL) &#123; flag=1; printf(\"(\"); &#125; InOrder(t-&gt;Left); if(flag==1&amp;&amp;t-&gt;Left-&gt;Left!=NULL) &#123; printf(\")\"); &#125; printf(\"%c\",t-&gt;ch); flag=-1; if(s[t-&gt;Right-&gt;ch-40]&lt;=s[t-&gt;ch-40]&amp;&amp;t-&gt;Right-&gt;Left!=NULL) &#123; flag=1; printf(\"(\"); &#125; InOrder(t-&gt;Right); if(flag==1&amp;&amp;t-&gt;Right-&gt;Left!=NULL) &#123; printf(\")\"); &#125;&#125;/**a##+b##c##+a##*b##c##*/int main()&#123; s['+'-40]=1; s['-'-40]=1; s['*'-40]=2; s['/'-40]=2; while(1) &#123; head=Create(); InOrder(head); cout&lt;&lt;endl; Del(head); &#125; // printf(\"%d %d %d %d\",'+','-','*','/'); return 0;&#125; 1-修正版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include&lt;bits/stdc++.h&gt;using namespace std;//const int maxn=1e5+10;int p=1,pf=1,pe=1;int seq[30];struct N&#123;//node int ch;// int ide; string way; int val; int flag; N *ls; N *rs;&#125;node[300];N *Stack[300];//Node Stack[100];struct Character&#123;//character int idx; int times; string code; int lenth; int flagprint;&#125;Char[30];void init()&#123; for(int i=0;i&lt;=26;i++)Char[i].times=0,Char[i].flagprint=1,Char[i].idx=1000; for(int i=0;i&lt;30;i++)node[i].flag=1,node[i].ls=node[i].rs=NULL;&#125;bool cmp(N *n1,N *n2)&#123; if(n1-&gt;val==n2-&gt;val)return Char[n1-&gt;ch].idx&lt;Char[n2-&gt;ch].idx; return (n1-&gt;val)&lt;(n2-&gt;val);&#125;void merge()&#123;// for(int i=pf;i&lt;pe;i++)cout&lt;&lt;Stack[i]-&gt;val&lt;&lt;\" \"&lt;&lt;(char)(Stack[i]-&gt;ch+'a')&lt;&lt;endl; N *n1=Stack[pf+1]; N *n2=Stack[pf]; pf+=2;// cout&lt;&lt;\"NOW MERGING \"&lt;&lt;char(n1-&gt;ch+'a')&lt;&lt;\" \"&lt;&lt;char(n2-&gt;ch+'a')&lt;&lt;endl;// cout&lt;&lt;\"flag: \"&lt;&lt;n1-&gt;flag&lt;&lt;\" \"&lt;&lt;n2-&gt;flag&lt;&lt;endl;// cout&lt;&lt;\"Pf pe is \"&lt;&lt;pf&lt;&lt;\" \"&lt;&lt;pe&lt;&lt;endl; node[p].ch=26,node[p].val=n1-&gt;val+n2-&gt;val; node[p].flag=0; if(n1-&gt;val!=n2-&gt;val)&#123; if(n1-&gt;val&gt;n2-&gt;val)&#123; node[p].ls=n2; node[p].rs=n1; &#125; else&#123; node[p].ls=n2; node[p].rs=n1; &#125; &#125; else&#123; if(n1-&gt;flag&amp;&amp;n2-&gt;flag)&#123; node[p].ls=n2,node[p].rs=n1;// cout&lt;&lt;\"all flag\"&lt;&lt;endl; &#125; else if(n1-&gt;flag&amp;&amp;!n2-&gt;flag)&#123; node[p].ls=n1,node[p].rs=n2;// cout&lt;&lt;\"n1\"&lt;&lt;endl; &#125; else if(!n1-&gt;flag&amp;&amp;n2-&gt;flag)&#123; node[p].ls=n2,node[p].rs=n1;// cout&lt;&lt;\"n2\"&lt;&lt;endl; &#125; else if(!n1-&gt;flag&amp;&amp;!n2-&gt;flag)&#123; node[p].ls=n2,node[p].rs=n1;// cout&lt;&lt;\"all not\"&lt;&lt;endl; &#125; &#125;// cout&lt;&lt;\"current node ls \"&lt;&lt;char('a'+node[p].ls-&gt;ch)&lt;&lt;endl;// cout&lt;&lt;\"current node rs \"&lt;&lt;char('a'+node[p].rs-&gt;ch)&lt;&lt;endl; Stack[pe++]=&amp;node[p]; p++; sort(Stack+pf,Stack+pe,cmp);&#125;void Record(N *pn,string curs)&#123;// cout&lt;&lt;\"Current char and string \"&lt;&lt;char(pn-&gt;ch+'a')&lt;&lt;\" \"&lt;&lt;curs&lt;&lt;endl; pn-&gt;way=curs; if(pn-&gt;ls!=NULL)&#123; Record(pn-&gt;ls,curs+\"0\"); &#125; if(pn-&gt;rs!=NULL)&#123;// cout&lt;&lt;char(pn-&gt;ch+'a')&lt;&lt;\" rs \"&lt;&lt;endl; Record(pn-&gt;rs,curs+\"1\"); &#125; if(pn-&gt;ls==NULL&amp;&amp;pn-&gt;rs==NULL)&#123; Char[pn-&gt;ch].code=pn-&gt;way;// cout&lt;&lt;\"LEAF\"&lt;&lt;endl; return; &#125;&#125;void solve(string s)&#123; int len=s.size(); for(int i=0;i&lt;len;i++)&#123; int c=s[i]-'a';// cout&lt;&lt;(char)(c+'a')&lt;&lt;endl; if(Char[c].times==0)&#123; Char[c].idx=p; node[p].ch=c; node[p].flag=1; p++; &#125; Char[c].times++; &#125; int P=p; for(int i=1;i&lt;p;i++)node[i].val=Char[node[i].ch].times;//gengxing val;读入字符串，建立节点 for(int i=1;i&lt;p;i++)Stack[i]=&amp;node[i]; pe=p; sort(Stack+pf,Stack+pe,cmp); for(int i=pf;i&lt;pe;i++)seq[i]=Stack[i]-&gt;ch;// for(int i=1;i&lt;p;i++)cout&lt;&lt;node[i].val&lt;&lt;\" \"&lt;&lt;(char)(node[i].ch+'a')&lt;&lt;endl;// cout&lt;&lt;\"read completed\"&lt;&lt;endl; while(pe-pf&gt;1)&#123; merge();//建树 &#125;// cout&lt;&lt;\"build completed\"&lt;&lt;endl;// cout&lt;&lt;node[1].val&lt;&lt;endl; N *pn=Stack[pe-1]; Record(pn,\"\");//编码// cout&lt;&lt;\"encrypted completed\"&lt;&lt;endl; cout&lt;&lt;len; int ans=0; for(int i=0;i&lt;len;i++)&#123; if(Char[s[i]-'a'].flagprint)&#123; ans+=Char[s[i]-'a'].code.size()*Char[s[i]-'a'].times; Char[s[i]-'a'].flagprint=0; &#125; &#125; cout&lt;&lt;\" \"&lt;&lt;ceil((double)ans/8)&lt;&lt;endl; for(int i=0;i&lt;len;i++)Char[s[i]-'a'].flagprint=1; for(int i=1;i&lt;P;i++)&#123; cout&lt;&lt;char(seq[i]+'a')&lt;&lt;\":\"&lt;&lt;Char[seq[i]].code&lt;&lt;endl;// if(Char[s[i]-'a'].flagprint)&#123;// ans+=Char[s[i]-'a'].code.size()*Char[s[i]-'a'].times;// cout&lt;&lt;s[i]&lt;&lt;\":\"&lt;&lt;Char[s[i]-'a'].code&lt;&lt;endl;// Char[s[i]-'a'].flagprint=0;//打印// &#125; &#125;// cout&lt;&lt;\"print completed\"&lt;&lt;endl;&#125;void sov(string a)&#123; int len=a.size(); string s; N *pn=Stack[pe-1]; for(int i=0;i&lt;len;i++)&#123;// cout&lt;&lt;\"cur \"&lt;&lt;a[i]&lt;&lt;endl; if(a[i]=='0')&#123; if(pn-&gt;ls!=NULL)pn=pn-&gt;ls; if(pn-&gt;ls==NULL&amp;&amp;pn-&gt;rs==NULL)&#123; s+=char(pn-&gt;ch+'a'); pn=Stack[pe-1]; &#125; &#125; else if(a[i]=='1')&#123; if(pn-&gt;rs!=NULL)pn=pn-&gt;rs; if(pn-&gt;ls==NULL&amp;&amp;pn-&gt;rs==NULL)&#123; s+=char(pn-&gt;ch+'a'); pn=Stack[pe-1]; &#125; &#125; &#125; if(pn!=Stack[pe-1])cout&lt;&lt;\"INVALID\"&lt;&lt;endl; else&#123; cout&lt;&lt;s&lt;&lt;endl; &#125;&#125;int main()&#123;// FILE *f1=fopen(\"in.txt\",\"r\"); string s,a,b; cin&gt;&gt;s&gt;&gt;a&gt;&gt;b; init(); solve(s); sov(a),sov(b); return 0;&#125;/*cbaxyyzz0100011accordinglyly101001010*/ 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;using namespace std;const int stop=0;struct node&#123; int data; node*FirstChild; node*NextBrother;&#125;;int a;node*Create()&#123; scanf(\"%d\",&amp;a); if(a==stop) &#123; return NULL; &#125; node*t=new node; t-&gt;data=a; t-&gt;FirstChild=Create(); t-&gt;NextBrother=Create(); return t;&#125;node* GetFirstChild(node*p)&#123; if(p!=NULL&amp;&amp;p-&gt;FirstChild!=NULL) return p-&gt;FirstChild; else return NULL;&#125;node* GetNextBrother(node*p)&#123; if(p!=NULL&amp;&amp;p-&gt;NextBrother!=NULL) return p-&gt;NextBrother; else return NULL;&#125;void PreOrder1(node*t)&#123; if(t==NULL) return ; printf(\"%d\\n\",t-&gt;data); PreOrder1(t-&gt;FirstChild); PreOrder1(t-&gt;NextBrother);&#125;int tot;int ans;int sum;const int MAX=1e5;int Road[MAX];int flag=0;void PreOrder(node*t)&#123; if(flag==1) return ; if(t==NULL) &#123; if(sum==ans) &#123; flag=1; int i; for(i=1;i&lt;=tot;i++) &#123; printf(\"%d \",Road[i]); &#125; printf(\"\\n\"); &#125; return ; &#125; if(flag==1) return ; //printf(\"%d\\n\",t-&gt;data); sum=sum+t-&gt;data; tot++; Road[tot]=t-&gt;data; node*child=t-&gt;FirstChild; if(child==NULL) &#123; if(sum==ans) &#123; flag=1; int i; for(i=1;i&lt;=tot;i++) &#123; printf(\"%d \",Road[i]); &#125; cout&lt;&lt;endl; &#125; return ; &#125; if(flag==1) return ; node*q; while(child!=NULL) &#123; PreOrder(child); if(flag==1) return ; tot--; sum=sum-child-&gt;data; child=child-&gt;NextBrother; &#125;&#125;int main()&#123; node*t=Create(); tot=0; sum=0; scanf(\"%d\",&amp;ans); PreOrder(t); if(flag==0) &#123; printf(\"0\\n\"); &#125; //printf(\"no\\n\");&#125;/*1 2 3 0 7 8 0 9 0 10 0 0 0 4 0 5 0 0 01 2 3 0 0 4 0 5 0 0 06*/","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"天気の子","slug":"天気の子","date":"2019-11-04T16:35:31.000Z","updated":"2019-11-04T16:40:37.472Z","comments":true,"path":"2019/11/05/ 天気の子/","link":"","permalink":"http://yoursite.com/2019/11/05/ 天気の子/","excerpt":"","text":"胜者しょうしゃの时代じだいに どこで息いきを吸すう​ 学期已过去一半有余，比赛也将再几天后开始。我能学和想学的东西都在浮躁中飘过，没有一丝的坠落… ​","categories":[],"tags":[{"name":"DIARY","slug":"DIARY","permalink":"http://yoursite.com/tags/DIARY/"}]},{"title":"Dufresne","slug":"Dufresne","date":"2019-10-30T13:28:16.000Z","updated":"2019-10-30T14:43:38.071Z","comments":true,"path":"2019/10/30/ Dufresne/","link":"","permalink":"http://yoursite.com/2019/10/30/ Dufresne/","excerpt":"","text":"“It was very bitter.” “She said she was glad i knew,that she hated all the sneaking around. And she said tha she wanted a divorce in Reno.” “I told her I would not grant one.” “If they say so.” “I really don’t remember. I was upset.” “She packed a bag…She packed a bag to go and stay with Mr.Quentin.” “I went to a few bars first. Later,I drove to his house to confront them. They weren’t home. So i parked in the turnout…and waited.” “I am not sure,I was confused, and drunk.” “I think mostly I wanted to scare them.” “No,I was sobering up.” “I got back in the car and I drove home to sleep it off. “ “Along the way,I threw my gun into the Royal River. I’ve been very clear on this point.” “Yes, it does. “ “It’s the truth.” “Since I am innocent of this crime. I find it decidedly inconvenient that the gun was never found.”","categories":[],"tags":[{"name":"Moive","slug":"Moive","permalink":"http://yoursite.com/tags/Moive/"}]},{"title":"T1","slug":"T1","date":"2019-10-29T15:20:59.000Z","updated":"2019-10-29T15:21:52.437Z","comments":true,"path":"2019/10/29/ T1/","link":"","permalink":"http://yoursite.com/2019/10/29/ T1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;template&lt;class T&gt;class BinTreeNode&#123;public: BinTreeNode&lt;T&gt;*left; BinTreeNode&lt;T&gt;*right; T data;public: BinTreeNode(BinTreeNode&lt;T&gt;*L=NULL,BinTreeNode&lt;T&gt;*R=NULL):left(L),right(R)&#123;&#125; BinTreeNode&lt;T&gt;*GetLeft()const &#123; return left; &#125; BinTreeNode&lt;T&gt;*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode&lt;T&gt;*L) &#123; left=L; &#125; void SetRight(BinTreeNode&lt;T&gt;*R) &#123; right=R; &#125; T&amp; GetData()&#123;return data;&#125; void SetData(const T&amp;item)&#123;data=item;&#125;&#125;;void f(char s[],int len)&#123; for(int i=0;i&lt;len;i++) &#123; printf(\"%c\",s[i]); &#125; cout&lt;&lt;endl;&#125;int tag;const int MAX=1e5+10;//str1是中序遍历，str2是后序遍历BinTreeNode&lt;char&gt;* CreateBinTree(char str1[],int len1,char str2[],int len2)&#123; BinTreeNode&lt;char&gt;*root=NULL; if(len1&lt;=0) &#123; return NULL; &#125; if(len1==1) &#123; if(str1[0]!=str2[0]) &#123; tag=-1; return nullptr; &#125; BinTreeNode&lt;char&gt;*t1=new BinTreeNode&lt;char&gt;; t1-&gt;SetData(str1[0]); t1-&gt;SetLeft(NULL); t1-&gt;SetLeft(NULL); return t1; &#125; char ch=str2[len2-1]; int i,j,k; for(i=0;i&lt;len1;i++) &#123; if(str1[i]==ch) break; &#125; if(i==len1)&#123;tag=-1;return NULL;&#125; int flag=i; root=new BinTreeNode&lt;char&gt;; root-&gt;SetData(str2[len1-1]); //f(str1,flag); // f(str2,flag); // f(str1+flag+1,len1-flag-1); // f(str2+flag,len1-flag-1); BinTreeNode&lt;char&gt;*t1=CreateBinTree(str1,flag,str2,flag); BinTreeNode&lt;char&gt;*t2=CreateBinTree(str1+flag+1,len1-flag-1,str2+flag,len2-flag-1); root-&gt;SetLeft(t1); root-&gt;SetRight(t2); return root;&#125;BinTreeNode&lt;char&gt;*Create(char str1[],char str2[])&#123; tag=0; int len1=strlen(str1); int len2=strlen(str2); if(len1!=len2) &#123; tag=-1; return NULL; &#125; BinTreeNode&lt;char&gt;*root=CreateBinTree(str1,len1,str2,len2); if(tag==-1) &#123; return NULL; &#125; return root;&#125;void PreOrder(BinTreeNode&lt;char&gt;*t)&#123; if(t!=NULL) &#123; cout&lt;&lt;t-&gt;GetData(); PreOrder(t-&gt;GetLeft()); PreOrder(t-&gt;GetRight()); &#125;&#125;int GetLeth(BinTreeNode&lt;char&gt;*t)&#123; if(t==NULL) return 0; int t1=GetLeth(t-&gt;GetLeft()); int t2=GetLeth(t-&gt;GetRight()); if(t1&gt;t2) return 1+t1; else return 1+t2;&#125;void Del(BinTreeNode&lt;char&gt;*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;void Func(BinTreeNode&lt;char&gt;*t)&#123; if(tag==-1) &#123; printf(\"INVALID\\n\"); return ; &#125; printf(\"%d\\n\",GetLeth(t)-1); PreOrder(t); Del(t);&#125;int main()&#123; char str1[MAX]; char str2[MAX]; scanf(\"%s%s\",str1,str2); BinTreeNode&lt;char&gt;*root=Create(str2,str1); Func(root); return 0;&#125;/*CEFDBHGACBEDFAGHCBEDFAGHCEFDBHGABCACAB*/","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"ma nong TI","slug":"ma-nong-TI","date":"2019-10-29T13:36:59.000Z","updated":"2019-11-25T11:03:15.643Z","comments":true,"path":"2019/10/29/ ma-nong-TI/","link":"","permalink":"http://yoursite.com/2019/10/29/ ma-nong-TI/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int MAX=1e3+10;char str[MAX][100];//假设每一个数字不超过100位int total;//一共多少个节点char s[MAX];int len;class BinTreeNode&#123;public: BinTreeNode*left; BinTreeNode*right; char data[100];public: BinTreeNode(const char*ss=NULL,BinTreeNode*L=NULL,BinTreeNode*R=NULL):left(L),right(R)&#123;if(ss!=NULL)strcpy(data,ss);&#125; BinTreeNode*GetLeft()const &#123; return left; &#125; BinTreeNode*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode*L) &#123; left=L; &#125; void SetRight(BinTreeNode*R) &#123; right=R; &#125; char* GetData()&#123;return data;&#125; void SetData(const char*item)&#123;strcpy(data,item);&#125;&#125;;class pairn&#123;public: BinTreeNode* first; int second;&#125;;class Stack4&#123;public: pairn str[MAX]; int n=0; pairn Top() &#123; return str[n]; &#125; void Push(pairn p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;class Stack&#123;public: char str[MAX][100]; int n=0; char* Top() &#123; return str[n]; &#125; void Push(const char s[100]) &#123; n++; strcpy(str[n],s); &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;class Stack3&#123;public: int str[MAX]; int n=0; int Top() &#123; return str[n]; &#125; void Push(int p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;//将所有的数字转化为正数//不会出现2*(-3)的情况//把这种情况变成2*(0-3)void Init()&#123; scanf(\"%s\",s); int i; int j; len=strlen(s); for(i=0;i&lt;len-1;i++) &#123; if(s[i]=='(') &#123; if(s[i+1]=='-') &#123; for(j=len;j&gt;i+1;j--) &#123; s[j]=s[j-1]; &#125; s[i+1]='0'; len++; &#125; &#125; &#125; s[len]=0;&#125;//判断运算符的优先级别int f(char ch)&#123; if(ch=='*'||ch=='/') return 2; if(ch=='+'||ch=='-') return 1;&#125;//由中缀表达式转换为后缀表达式void In_To_Post()&#123; int i,j,k; Stack S1; Stack S2; S1.n=0; S2.n=0; total=0; char str0[100]; for(i=0;i&lt;len;i++) &#123; j=0; //假设是数字 while(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'&amp;&amp;i!=len) &#123; str0[j]=s[i]; j++; i++; &#125; //是数字，入栈 if(j!=0) &#123; str0[j]=0; S1.Push(str0); &#125; if(i==len) &#123; break; &#125; if(s[i]=='(') &#123; S2.Push(\"(\"); // cout&lt;&lt;\"TOP\"&lt;&lt;S2.Top()&lt;&lt;endl; &#125; //遇到一些运算符 if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/') &#123; // cout&lt;&lt;\"i:\"&lt;&lt;i&lt;&lt;\"s[i]:\"&lt;&lt;s[i]&lt;&lt;endl; str0[0]=s[i]; str0[1]=0; if((S2.Top())[0]=='('||S2.Empty()==true) S2.Push(str0); else &#123; //判断栈顶元素的优先级和新符号的优先级，一直输出，知道遇到优先级比其低的，或者遇到左括号 while(S2.Top()[0]!='('&amp;&amp;f(S2.Top()[0])&gt;=f(str0[0])&amp;&amp;S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; S2.Push(str0); &#125; &#125; //遇到右括号，则需要依次弹出，直到遇到左括号 if(s[i]==')') &#123; while(S2.Top()[0]!='('&amp;&amp;S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; S2.Pop(); &#125; &#125; // cout&lt;&lt;\"S1.n: \"&lt;&lt;S1.n&lt;&lt;\" S2.n:\"&lt;&lt;S2.n&lt;&lt;endl; while(S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; total=S1.n; i=total; while(S1.Empty()==false) &#123; strcpy(str[i],S1.Top()); i--; S1.Pop(); &#125;&#125;/*1+2*3+(4*5+6)*7*/class Stack2&#123;public: BinTreeNode* str[MAX]; int n=0; BinTreeNode* Top() &#123; return str[n]; &#125; void Push(BinTreeNode*p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;//由后缀表达式创键表达式树//此次的表达式树保存的还是字符串BinTreeNode*CreateExprTree()&#123; BinTreeNode*root,*p; int i=1; Stack2 S2; S2.n=0; BinTreeNode*L; BinTreeNode*R; for(i=1;i&lt;=total;i++) &#123; if(str[i][0]=='+'||str[i][0]=='-'||str[i][0]=='*'||str[i][0]=='/') &#123; R=S2.Top(); S2.Pop(); L=S2.Top(); S2.Pop(); p=new BinTreeNode; p-&gt;SetData(str[i]); p-&gt;SetLeft(L); p-&gt;SetRight(R); S2.Push(p); &#125; else &#123; p=new BinTreeNode; p-&gt;SetData(str[i]); p-&gt;SetLeft(NULL); p-&gt;SetRight(NULL); S2.Push(p); &#125; &#125; root=S2.Top(); S2.Pop(); return root;&#125;//把保存数字的字符串转换为整数int Ca(const char q[100])&#123; int sum=0; int i=0; for(i=0;q[i]!=0;i++) &#123; sum=sum*10+q[i]-'0'; &#125; return sum;&#125;const int ILL=-1e9;int GetValue(BinTreeNode*root)&#123; int sum=0; if(root==NULL) return 0; Stack3 Cac; pairn p; p.first=root; p.second=0; Stack4 P; P.Push(p); int i,j,k; int op1,op2; while(P.Empty()==false) &#123; p=P.Top(); P.Pop(); i=p.second; if(i==0) &#123; p.second++; P.Push(p); if(p.first-&gt;GetLeft()!=NULL) &#123; p.second=0; p.first=p.first-&gt;GetLeft(); P.Push(p); &#125; &#125; if(i==1) &#123; p.second++; P.Push(p); if(p.first-&gt;GetRight()!=NULL) &#123; p.second=0; p.first=p.first-&gt;GetRight(); P.Push(p); &#125; &#125; if(i==2) &#123; if(p.first-&gt;GetLeft()==NULL&amp;&amp;p.first-&gt;GetRight()==NULL) &#123; Cac.Push(Ca(p.first-&gt;GetData())); &#125; else &#123; op2=Cac.Top(); Cac.Pop(); op1=Cac.Top(); Cac.Pop(); char y[100]; strcpy(y,p.first-&gt;GetData()); int ans=0; if(y[0]=='+')ans=op1+op2; if(y[0]=='-')ans=op1-op2; if(y[0]=='*')ans=op1*op2; if(y[0]=='/') &#123; if(op2==0) &#123; printf(\"ILLRGAL\\n\"); return ILL; &#125; ans=op1/op2; &#125; Cac.Push(ans); &#125; &#125; &#125; sum=Cac.Top(); return sum;&#125;/*1+10*2*/void Del(BinTreeNode*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;int main()&#123; Init(); In_To_Post(); BinTreeNode*root=CreateExprTree(); int ans=GetValue(root); if(ans!=ILL) printf(\"%d\\n\",ans); Del(root); return 0;&#125; 当码农可真开心呢，哈哈哈哈，真好啊，不能使用STL，真开心啊","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"BinTree","slug":"BinTree","date":"2019-10-27T04:28:29.000Z","updated":"2019-10-28T15:16:29.257Z","comments":true,"path":"2019/10/27/ BinTree/","link":"","permalink":"http://yoursite.com/2019/10/27/ BinTree/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#include&lt;stack&gt;#include&lt;utility&gt;#include&lt;queue&gt;using namespace std;template&lt;class T&gt;class BinTreeNode&#123;public: BinTreeNode&lt;T&gt;*left; BinTreeNode&lt;T&gt;*right; T data;public: BinTreeNode(const T&amp;item,BinTreeNode&lt;T&gt;*L=NULL,BinTreeNode&lt;T&gt;*R=NULL):data(item),left(L),right(R)&#123;&#125; BinTreeNode&lt;T&gt;*GetLeft()const &#123; return left; &#125; BinTreeNode&lt;T&gt;*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode&lt;T&gt;*L) &#123; left=L; &#125; void SetRight(BinTreeNode&lt;T&gt;*R) &#123; right=R; &#125; T&amp; GetData()&#123;return data;&#125; void SetData(const T&amp;item)&#123;data=item;&#125;&#125;;template&lt;class T&gt;class BinTree&#123;public: BinTreeNode&lt;T&gt;*root; T stop;public: BinTree(BinTreeNode&lt;T&gt;*t=NULL):root(t)&#123;&#125; void PreOrder(BinTreeNode&lt;T&gt;*t)const; void InOrder(BinTreeNode&lt;T&gt;*t)const; void PostOrder(BinTreeNode&lt;T&gt;*t)const; void LevelOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPreOrder(BinTreeNode&lt;T&gt;*t)const; void NorecInOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPostOrder(BinTreeNode&lt;T&gt;*t)const; void CreateBinTree(T tostop); BinTreeNode&lt;T&gt;* Create(); BinTreeNode&lt;T&gt;*CopyTree(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p); BinTreeNode&lt;T&gt;*Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const; void InsertLeft(T item,BinTreeNode&lt;T&gt;*t); void InsertRight(T item,BinTreeNode&lt;T&gt;*s); void DelSubtree(BinTreeNode&lt;T&gt;*t); void Del(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*GetRoot()&#123;return root;&#125; void SetRoot(BinTreeNode&lt;T&gt;*t)&#123;root=t;&#125; T getStop()&#123;return stop;&#125; void SetStop(T tostop)&#123;stop=tostop;&#125; bool IsEmpty()&#123;return root==NULL;&#125;&#125;;template&lt;class T&gt;void BinTree&lt;T&gt;::PreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; PreOrder(t-&gt;GetLeft()); PreOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; InOrder(t-&gt;GetLeft()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; InOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::PostOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; PostOrder(t-&gt;GetLeft()); PostOrder(t-&gt;GetRight()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecInOrder(BinTreeNode&lt;T&gt;*t)const&#123; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; while(t!=NULL||S.empty()==false) &#123; while(t!=NULL) &#123; S.push(t); t=t-&gt;GetLeft(); &#125; if(S.empty()==true)return ; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; t=t-&gt;GetRight(); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t==NULL)return ; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; S.push(t); while(S.empty()==false) &#123; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; if(t-&gt;GetRight()!=NULL) S.push(t-&gt;GetRight()); if(t-&gt;GetLeft()!=NULL) S.push(t-&gt;GetLeft()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPostOrder(BinTreeNode&lt;T&gt;*t)const&#123; pair&lt;BinTreeNode&lt;T&gt;*,int&gt; p; if(t==NULL)return ; p=make_pair(t,0); stack&lt;pair&lt;BinTreeNode&lt;T&gt;*,int&gt;&gt;S; S.push(p); while(S.empty()==false) &#123; p=S.top(); S.pop(); if(p.second==0) &#123; p.second++; S.push(p); if((p.first)-&gt;GetLeft()!=NULL) &#123; p.first=(p.first)-&gt;GetLeft(); p.second=0; S.push(p); &#125; &#125; else &#123; if(p.second==1) &#123; p.second++; S.push(p); if((p.first)-&gt;GetRight()!=NULL) &#123; p.first=(p.first)-&gt;GetRight(); p.second=0; S.push(p); &#125; &#125; else &#123; cout&lt;&lt;p.first-&gt;GetData()&lt;&lt;endl; &#125; &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::LevelOrder(BinTreeNode&lt;T&gt;*t)const&#123; queue&lt;BinTreeNode&lt;T&gt;*&gt;Q; if(t==NULL)return ; BinTreeNode&lt;T&gt; *p=t; Q.push(p); while(Q.empty()==false) &#123; p=Q.front(); Q.pop(); cout&lt;&lt;p-&gt;GetData()&lt;&lt;endl; if(p-&gt;GetLeft()!=NULL) &#123; Q.push(p-&gt;GetLeft()); &#125; if(p-&gt;GetRight()!=NULL) &#123; Q.push(p-&gt;GetRight()); &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::CreateBinTree(T tostop)&#123; SetStop(tostop); root=Create();&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;* BinTree&lt;T&gt;::Create()&#123; BinTreeNode&lt;T&gt;*t,*t1,*t2; T item; cin&gt;&gt;item; if(item==stop) &#123; t=NULL; return t; &#125; t=new BinTreeNode&lt;T&gt;(item,NULL,NULL); t1=Create(); t-&gt;SetLeft(t1); t2=Create(); t-&gt;SetRight(t2); return t;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::CopyTree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return NULL; BinTreeNode&lt;T&gt;*L=nullptr,*R=nullptr; if(t-&gt;GetLeft()!=NULL) &#123; L=CopyTree(t-&gt;GetLeft()); &#125; if(t-&gt;GetRight()!=NULL) &#123; R=CopyTree(t-&gt;GetRight()); &#125; BinTreeNode&lt;T&gt;*nod=new BinTreeNode&lt;T&gt;(t-&gt;GetData(),L,R); return nod;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p)&#123; BinTreeNode&lt;T&gt;*q; if(t==NULL||p==NULL) return NULL; if(t-&gt;GetLeft()==p||t-&gt;GetRight()==p) return t; q=Father(t-&gt;GetLeft(),p); if(q!=NULL)return q; return Father(t-&gt;GetRight(),p);&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const&#123; BinTreeNode&lt;T&gt;*p; if(t==NULL)return NULL; if(t-&gt;data==item) return t; p=Find(t-&gt;GetLeft(),item); if(p!=NULL) return p; p=Find(t-&gt;GetRight(),item); return p;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::Del(BinTreeNode&lt;T&gt;*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertLeft(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetLeft(s-&gt;GetLeft()); p-&gt;SetRight(NULL); s-&gt;SetLeft(p);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertRight(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetRight(s-&gt;GetRight()); s-&gt;SetRight(p); p-&gt;SetLeft(NULL);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::DelSubtree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return ; if(t==root) &#123; Del(t); root=NULL; return ; &#125; BinTreeNode&lt;T&gt;*f=Father(root,t); if(f!=nullptr) &#123; if(f-&gt;GetLeft()==t) f-&gt;SetLeft(NULL); if(f-&gt;GetRight()==t)f-&gt;SetRight((NULL)); &#125; Del(t);&#125;int main()&#123; BinTree&lt;int&gt; t; t.CreateBinTree(-1); BinTreeNode&lt;int&gt;*t2=t.Find(t.root,4); t.InsertRight(6,t2); t.InOrder(t.root); return 0;&#125;/*1 2 4 -1 5 -1 -1 -1 3 -1 -1*/","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"大数运算","slug":"大数运算","date":"2019-10-21T07:02:01.000Z","updated":"2019-10-21T07:04:12.755Z","comments":true,"path":"2019/10/21/ 大数运算/","link":"","permalink":"http://yoursite.com/2019/10/21/ 大数运算/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546//大数和整数的除法string div(string a,int b)&#123; string c; int len=a.length(),ans=0; char s; for(int i=0; i&lt;len; i++)&#123; ans=ans*10+a[i]-'0'; s=ans/b+'0'; ans%=b; c+=s; &#125; int pos=0; while(pos&lt;len &amp;&amp; c[pos]=='0') pos++; if(pos==len) return \"0\"; return c.substr(pos);&#125;//大数和整数的乘法string mul(string a,int b)&#123; string c; char s; int len=a.length(),ok=0; for(int i=len-1; i&gt;=0; i--)&#123; int temp=(a[i]-'0')*b+ok; ok=temp/10; s=temp%10+'0'; c=s+c; &#125; while(ok)&#123; s=ok%10+'0'; c=s+c; ok/=10; &#125; return c;&#125;//大数对整数取模int MOD(string str,int mod)&#123; int rem=0; for(int i=0; i&lt;str.length(); i++)&#123; rem=rem*10+str[i]-'0'; rem=rem%mod; &#125; return rem;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Bignumber","slug":"Bignumber","permalink":"http://yoursite.com/tags/Bignumber/"}]},{"title":"EulerSieve","slug":"EulerSieve","date":"2019-10-21T06:16:46.000Z","updated":"2019-11-18T13:46:02.874Z","comments":true,"path":"2019/10/21/ EulerSieve/","link":"","permalink":"http://yoursite.com/2019/10/21/ EulerSieve/","excerpt":"","text":"EulerSieve时间复杂度​ O(n) 实现12345678910111213141516171819202122const int maxn = 10100; int prime[maxn], pNum = 0; // prime记录素数，pNum记录素数个数 //保存的值为0~pNum-1bool p[maxn] = &#123;false&#125;; // p记录当前数是否被筛去void EulerSieve(int n) // 查找记录2-n的素数&#123; int j; for (int i = 2; i &lt;= n; i++) &#123; if (p[i] == false) // 如果未被筛过，则为素数 prime[pNum++] = i; for (j = 0; j &lt; pNum; j++) &#123; if (i * prime[j] &gt; n) // 当要标记的合数超出范围时跳出 break; p[i * prime[j]] = true; // 将已经记录的素数的倍数进行标记 if (i % prime[j] == 0) //关键步骤 break; &#125; &#125;&#125; 理解时间复杂度证明","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Prime","slug":"Prime","permalink":"http://yoursite.com/tags/Prime/"}]},{"title":"10-20","slug":"10-20","date":"2019-10-21T05:28:05.000Z","updated":"2019-10-21T07:08:48.412Z","comments":true,"path":"2019/10/21/ 10-20/","link":"","permalink":"http://yoursite.com/2019/10/21/ 10-20/","excerpt":"","text":"Jiaozuo Regional Contest Problem A Xu Xiake in henan Province​ 输入4个数字，判断有多少个非0的数 Problem I Distance&gt; 前缀和 模拟​ 输入n ​ 在x轴上有n个点，且分别给出它们之间的距离 ​ 输出n个数字，这些数字分别为a1,a2,a3…an。其中ai的值为：在这些点中取i个点，使得每两个点的距离之和最大。 ​ 我们只需要从两端取点则可以一定保证其和最大化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;typedef long long LL;int T;int n;LL ans;LL cnt;int Left;int Right;//分别模拟最左边和最右边的位置const int MAX=1e6+10;LL sum[MAX];void Init()&#123; scanf(\"%d\",&amp;n); int i; LL a; sum[0]=0; sum[1]=0; for(i=2;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a); sum[i]=sum[i-1]+a; &#125; //前缀和一下 Left=1; Right=n;&#125;void Func()&#123; printf(\"0\"); cnt=sum[Right]-sum[Left]; ans=cnt; printf(\" %lld\",ans); int i; for(i=3;i&lt;=n;i++) &#123; if(i%2==1) &#123; ans=ans+cnt; printf(\" %lld\",ans); Left++; &#125; else &#123; Right--; cnt=cnt+sum[Right]-sum[Left]; ans=ans+cnt; printf(\" %lld\",ans); &#125; &#125; printf(\"\\n\");&#125;int main()&#123; scanf(\"%d\",&amp;T); int i; for(i=1;i&lt;=T;i++) &#123; Init(); Func(); &#125; return 0;&#125; Problem E Resistors in Parallel​","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Train-10-20","slug":"Train-10-20","permalink":"http://yoursite.com/tags/Train-10-20/"}]},{"title":"Train-10-20","slug":"Train-10-20","date":"2019-10-21T05:28:05.000Z","updated":"2019-10-21T05:29:37.483Z","comments":true,"path":"2019/10/21/ Train-10-20/","link":"","permalink":"http://yoursite.com/2019/10/21/ Train-10-20/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Train-10-19","slug":"Train-10-19","date":"2019-10-20T17:40:28.000Z","updated":"2019-10-21T07:08:57.137Z","comments":true,"path":"2019/10/21/ Train-10-19/","link":"","permalink":"http://yoursite.com/2019/10/21/ Train-10-19/","excerpt":"","text":"传送门 Chart 1​ 搜索打表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869vector&lt;pair&lt;double,double&gt;&gt; v;const double h=0.5*sqrt(3.0);//判断是否等边三角形typedef long long LL;const double eps=1e-6;LL cnt;bool f(pair&lt;double,double&gt; a,pair&lt;double,double&gt; b,pair&lt;double,double&gt; c)&#123; double L1=(a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second); double L2=(a.first-c.first)*(a.first-c.first)+(a.second-c.second)*(a.second-c.second); double L3=(c.first-b.first)*(c.first-b.first)+(c.second-b.second)*(c.second-b.second); if(fabs(L1-L2)&lt;eps&amp;&amp;fabs(L1-L3)&lt;eps) return true; else return false;&#125;void Func()&#123; //初始化点集 pair&lt;double,double&gt; p; p.first=0.0; p.second=0.0; v.push_back(p); int i; int j,k,g; double i0; for(i=1;i&lt;=30;i++) &#123; cnt=0; i0=i; p.second=(-1.0)*i0*h; if(i%2==0) &#123; p.first=0.0; v.push_back(p); for(j=1;j&lt;=i/2;j++) &#123; p.first=(double)j; v.push_back(p); p.first=p.first*(-1.0); v.push_back(p); &#125; &#125; else &#123; for(j=0;j&lt;=i/2;j++) &#123; p.first=0.5+(double)j; v.push_back(p); p.first=p.first*(-1.0); v.push_back(p); &#125; &#125; for(j=1;j&lt;=v.size()-2;j++) &#123; for(k=j+1;k&lt;=v.size()-1;k++) &#123; for(g=k+1;g&lt;=v.size();g++) &#123; if(f(v[j-1],v[k-1],v[g-1])==true) cnt++; &#125; &#125; &#125; printf(\"i=%d cnt=%lld\\n\",i,cnt); &#125;&#125; Chart 2找规律（可以使用下这个牛皮方法） （其实是需要知道各种函数的性质方可使用 不断做差知道第四次做差的时候所有的差值为同一值（即原来的函数表达式最高次为4次） 设方程 f(n)=an^4+bn^3+cn^2+dn+e 则解方程即可（可以使用excel来解） a=1/24 b=6/24 c=11/24 d=6/24 这里还需要使用到求24的逆元 123456789101112131415const LL MOD=1e9+7;const LL Inv24=41666667;LL n;LL ans;void Func()&#123; LL n1=n*n%MOD; n1=(n1*n1)%MOD; LL n2=((n*n)%MOD*n)%MOD*6%MOD; LL n3=n*n%MOD*11%MOD; LL n4=6*n%MOD; ans=(n1+n2+n3+n4)%MOD; ans=ans*Inv24%MOD; printf(\"%lld\\n\",ans);&#125; 他好强","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Train","slug":"Train","permalink":"http://yoursite.com/tags/Train/"}]},{"title":"Fermat little theorem","slug":"Fermat-little-theorem","date":"2019-10-20T17:33:43.000Z","updated":"2019-10-20T17:38:28.821Z","comments":true,"path":"2019/10/21/ Fermat-little-theorem/","link":"","permalink":"http://yoursite.com/2019/10/21/ Fermat-little-theorem/","excerpt":"","text":"Fermat little theorem​ 如果p是一个质数，而整数a不是p的倍数，则有a^（p-1）≡1（mod p） ​ 则可以求的分数（逆元）的取模：1/a(mod p)=a^(p-2)","categories":[{"name":"math","slug":"math","permalink":"http://yoursite.com/categories/math/"}],"tags":[{"name":"Fermat little theorem","slug":"Fermat-little-theorem","permalink":"http://yoursite.com/tags/Fermat-little-theorem/"}]},{"title":"qpow","slug":"qpow","date":"2019-10-20T17:18:42.000Z","updated":"2019-10-20T17:32:10.167Z","comments":true,"path":"2019/10/21/ qpow/","link":"","permalink":"http://yoursite.com/2019/10/21/ qpow/","excerpt":"","text":"快速幂假设​ 求x^n的值 时间复杂度​ O(log n) 解释​ 通过加大底数的权重来使得乘法次数更少 ​ 1.假设n为奇数：x^n=x*x^(n-1) 则将x计入结果 ​ 2.假设n为偶数：x^n=x^(n/2)*x^(n/2) 则将x的权重变为x^2 实现代码1234567891011121314/*快速幂运算 log 2 n*/typedef long long LL;LL qpow(LL a, LL n, LL mod)&#123; LL result = 1; while (n!=0) &#123; if (n &amp; 1) result = (result * a) % mod;//计入结果 a = (a * a) % mod;//权重变大 n &gt;&gt;= 1;//n=n/2; &#125; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"http://yoursite.com/tags/快速幂/"}]},{"title":"Kruskal","slug":"Kruskal","date":"2019-10-10T14:56:52.000Z","updated":"2019-10-20T17:57:57.781Z","comments":true,"path":"2019/10/10/ Kruskal/","link":"","permalink":"http://yoursite.com/2019/10/10/ Kruskal/","excerpt":"","text":"Kruskal Kruskal总是维护无向连通图的最小生成森林 最终得到该图的最小生成树 由来​ Kruskal算法是一种用来查找最小生成树的贪心算法，由Joseph Kruskal在1956年发表。 假设​ 有n个点m条无向边的图，且已知每一条边(x,y,z)，代表点x和点y之间有哦权值为z的无向边。 时间复杂度​ O(m log m) 预备知识​ 并查集 先挖坑 解释​ 在遍历所给无向连通图的过程中，kruskal 总是维护着最小生成森林。 ​ 最终得到最小生成树。 ​ 有以下步骤： ​ 1.初始化并查集，每一个点各自构成一个集合 ​ 2.对边集S进行从小到大排序 ​ 3.从S中取出一条边（注意：现在是从S中从小到大取出，判断这条边的两个端点是否属于同一个集合（使用并查集维护），不是则将端点x和端点y使用并查集combine起来。且将边加入最小生成森林。 ​ 4.不断重复S直至访问完所有边 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//以边集来保存图，假设有m条边//时间复杂度为mlogmconst int MAX=11010;struct edge&#123; int x; int y; int z;&#125;;//代表x和y两点之间有路且权值为zedge S[MAX];int Father[MAX];int n,m;int ans;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; return a.z&lt;b.z;&#125;inline void Init()&#123; int i; scanf(\"%d%d\",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;S[i].x,&amp;S[i].y,&amp;S[i].z);&#125;//并查集找父亲inline int Find(int x)&#123; while(x!=Father[x]) x=Father[x]; return x; &#125;//combineinline void combine(int x,int y)&#123; Father[x]=y;&#125;inline void Kruskal()&#123; ans=0; int x; int y; int i; for(i=1;i&lt;=n;i++) Father[i]=i; sort(S+1,S+m+1); for(i=1;i&lt;=m;i++) &#123; x=Find(S[i].x); y=Find(S[i].y); if(x!=y) &#123; ans=ans+S[i].z; combine(x,y); &#125; &#125;&#125; 模板题 ​ 回顾学习算法的第四天。戒掉可乐的第四天 ​ Orz ​ Orz","categories":[{"name":"“algorithm\"","slug":"“algorithm","permalink":"http://yoursite.com/categories/“algorithm/"}],"tags":[{"name":"Kruskal","slug":"Kruskal","permalink":"http://yoursite.com/tags/Kruskal/"}]},{"title":"Leg","slug":"Leg","date":"2019-10-09T15:21:37.000Z","updated":"2019-10-09T15:55:24.346Z","comments":true,"path":"2019/10/09/ Leg/","link":"","permalink":"http://yoursite.com/2019/10/09/ Leg/","excerpt":"","text":"十分荒废的一次训练，自以为腿部没有人看出来就不训练了吗，一到机械前就会失措=-= 还有许多腿部的动作实在过于僵硬，组数和重量也是安排的无厘头=-= 深蹲 KG 10 10 20 10 10 RM 8 8 8 8 8 小深蹲 15 20 25 35 45 45 20 20 20 15 10 10 standing leg curl 10 10 15 15 12 12 12 12 我要开始好好训练腹部和腿部了=-=","categories":[],"tags":[{"name":"teg","slug":"teg","permalink":"http://yoursite.com/tags/teg/"}]},{"title":"Manacher","slug":"Manacher","date":"2019-10-09T15:21:21.000Z","updated":"2019-10-09T16:01:38.179Z","comments":true,"path":"2019/10/09/ Manacher/","link":"","permalink":"http://yoursite.com/2019/10/09/ Manacher/","excerpt":"","text":"由来​ 1975年，一个叫Manacher的人发明了一个Manacher算法 作用​ 给定一个字符串S，求出其最大回文子串 时间复杂度 O(n) 原理 对称性 1.字符串处理​ 由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 ​ Example： 原串S a c a b a 转换后的串T # a # c # a # b # a # ​ 为了防止越界，做出以下修改，使得T变成$#a#a#a#b#a#@ 2.Len数组​ 设有字符串T上的位置i，Len[i]表示以i为中心的回文串的半径，和KMP算法相比，这里的数组并非只是预处理的作用，而是在线的处理 ​ 可得： i 1 2 3 4 5 6 7 8 9 10 11 T[i] # a # c # a # b # a # Len[i] 1 2 1 4 1 2 1 4 1 2 1 ​ 如何得到Len数组？ ​ （先挖坑） ​ 主要思想是利用对称性 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int MAX=110000000+10;char S[MAX];//原串char tmp[MAX*2+10];//辅助字符串Tint Len[MAX*2+10];//Len数组int N1;//原串S的长度int N2;//T的长度inline void GetT()&#123; int i,N1=strlen(S); N2=N1*2+1; tmp[0]='$'; for(i=1;i&lt;=2*N1;i=i+2) &#123; tmp[i]='#'; tmp[i+1]=S[i/2]; &#125; tmp[i]='#'; tmp[i+1]='@'; tmp[i+2]=0;&#125;//得到最大的回文串长度inline int Manacher()&#123; GetLen(); int mx=0; int ans=0; int po=0; int i; for(i=1;i&lt;=N2;i++) &#123; if(mx&gt;i) &#123; //对称性 if((mx-i)&lt;Len[2*po-1]) Len[i]=mx-i; else Len[i]=Len[2*po-1]; &#125; else//第三种情况 Len[i]=1; //不断向外扩展，巧妙 while(tmp[i-Len[i]]==tmp[i+Len[i]]) Len[i]++; //更新值 if(Len[i]+i&gt;mx) &#123; mx=Len[i]+i; po=i; &#125; if(Len[i]&gt;ans) ans=Len[i]; &#125; return ans-1;&#125; ​ =-= ​ https://blog.csdn.net/dyx404514/article/details/42061017","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"http://yoursite.com/tags/Manacher/"}]},{"title":"Abdomen","slug":"Abdomen","date":"2019-10-08T08:15:17.000Z","updated":"2019-10-09T15:49:30.736Z","comments":true,"path":"2019/10/08/ Abdomen/","link":"","permalink":"http://yoursite.com/2019/10/08/ Abdomen/","excerpt":"","text":"​ 嘤嘤嘤… ​ 总是会认为腹部训练是附加于其他大肌群训练之后的小训练…可是这么久了还是原地踏步，看来要把腹部看做是一个大肌群了… 类仰卧起坐 KG 25 35 35 25 25 RM 25 15 15 20 20","categories":[{"name":"BODY","slug":"BODY","permalink":"http://yoursite.com/categories/BODY/"}],"tags":[{"name":"Abdomen","slug":"Abdomen","permalink":"http://yoursite.com/tags/Abdomen/"}]},{"title":"Chest","slug":"Chest","date":"2019-10-08T08:02:40.000Z","updated":"2019-10-09T08:13:33.137Z","comments":true,"path":"2019/10/08/ Chest/","link":"","permalink":"http://yoursite.com/2019/10/08/ Chest/","excerpt":"","text":"遇见大佬之二杠铃平板卧推 KG 5 5 10 10 10 RM 12 15 8 8 2 嘤嘤嘤…绝对不是因为我连续三天都训练上半身的原因 我终于会使用表格了 哑铃半卧推 KG 10 10 15 15 10 RM 12 12 8 4 8 坐姿推下胸 KG 10 10 15 10 RM 12 12 12 12 推不动了=-=真不行了 蝴蝶机夹胸 KG 19 24 14 14 14 RM 12 12 12 12 10","categories":[],"tags":[{"name":"Chest","slug":"Chest","permalink":"http://yoursite.com/tags/Chest/"}]},{"title":"Back","slug":"Back-1","date":"2019-10-07T14:04:27.000Z","updated":"2019-10-07T14:26:17.092Z","comments":true,"path":"2019/10/07/ Back-1/","link":"","permalink":"http://yoursite.com/2019/10/07/ Back-1/","excerpt":"","text":"背部训练LowRow​ 15KG 20RM- ​ 15KG 20RM- （应该以20KG为起始重量） ​ 25KG 10RM ​ 25KG 20RM ​ 25KG 15RM 中下拉​ 15KG 10RM- （应该以20KG为起始重量） ​ 25KG 12RM ​ 25KG 12RM ​ 25KG 15RM 龙门架划船​ 25KG 12RM（不碰肚脐） ​ 25KG 12RM （不碰肚脐） ​ 20KG 20RM（很舒服的一组） ​ 25KG 10RM ​ 20KG 20RM！！！ 吹爆龙门架划船，也许是个人原因吧。 高位下拉​ 35KG 20RM ​ 25KG 10RM（单侧各） ​ 25KG 40RM（交换单侧） ​ 20KG 40RM（交换单侧） ​ 20KG 40RM+++++++++ 宽距引体向上​ 不知道为什么感觉比高中的引体向上要累了许多=-=","categories":[{"name":"Body","slug":"Body","permalink":"http://yoursite.com/categories/Body/"}],"tags":[{"name":"Back","slug":"Back","permalink":"http://yoursite.com/tags/Back/"}]},{"title":"KMP","slug":"KMP","date":"2019-10-01T06:25:53.000Z","updated":"2019-10-07T15:42:20.369Z","comments":true,"path":"2019/10/01/ KMP/","link":"","permalink":"http://yoursite.com/2019/10/01/ KMP/","excerpt":"","text":"名字由来​ 由Knuth，Morris,Pratt三人所设计的线性时间字符串匹配算法 时间复杂度​ 设有长度为n的文本串S和长度为m的匹配串P，求匹配串成功匹配文本串字串的首地址 ​ O(n+m) 原理引出​ 对匹配串预处理生成一种失配的映射（或者称为函数，其实称为函数会更加恰当），我们姑且把这个函数成为Next函数。当匹配串对文本串进行匹配时，不妨想象一下，我们在失配的时候对应的失配位置i，都会有相同的移动位移，这样就会产生一个关于i的函数，我们姑且把这样的函数称之为Next(i)，那么这个函数的返回值是什么呢？在不同的博客上它的返回值是不一样的，比如，有些直接返回P下一个需要比较的位置，有些是返回P需要移动的距离（自行脑补一下），有些是返回最大该位置的最大的前后缀一样的字串的字符数，有些的Next函数是经过优化过的，自然返回值和原来的有些不一样。不过它们的使用方法都大同小异。 ​ 我们以返回值为P下一个需要匹配的位置为例 Next函数的产生​ 先挖坑 1234567891011121314151617181920inline void GetNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; Next[j]=k; &#125; else &#123; k=Next[k]; &#125; &#125;&#125; NextPro数组的产生12345678910111213141516171819202122inline void GetProNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; //只是比Next数组多了一个判断罢了 if(P[j]!=P[k]) Next[j]=k; else Next[j]=Next[k]; &#125; else k=Next[k]; &#125;&#125; KMPSearch代码12345678910111213141516171819202122232425262728const int MAX=10010;char P[MAX];char S[MAX];int Next[MAX];int KmpSearch()&#123; GetProNext();//只需要在这里预处理P的Next数组即可 int sLen=strlen(S); int pLen=strlen(P); int i=0; int j=0; while(i&lt;sLen&amp;&amp;j&lt;pLen) &#123; if(j==-1||S[i]==P[j]) &#123; i++; j++; &#125; else &#123; j=Next[j]; &#125; &#125; if(j==pLen) return i-j; else return -1;&#125; 这个讲解很棒https://blog.csdn.net/v_JULY_v/article/details/7041827","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/tags/KMP/"}]},{"title":"Back","slug":"Back","date":"2019-09-23T05:55:21.000Z","updated":"2019-10-09T15:49:42.394Z","comments":true,"path":"2019/09/23/ Back/","link":"","permalink":"http://yoursite.com/2019/09/23/ Back/","excerpt":"","text":"​ 这是一篇虚假的背部的训练计划 体重：65 身高：173 体脂：未知 ​ 无论是身体的哪一部分训练都可以遵循以下原则： ​ 感受身体对应的部位，了解它的肌肉线条，从而得到它拉伸的方向，拉到最远距离，缩到最近距离。接下来的每一个动作都可以依据这样的原则来进行训练 坐式低拉背​ 10KG 12RM ​ 10KG 12RM ​ 15KG 12RM ​ 20KG 12RM ​ 20KG 12RM 龙门架划船​ 25KG 12RM ​ 25KG 12RM ​ 35KG 8RM ​ 35KG 8RM ​ 25KG 8RM 坐式中拉背​ 10KG 12RM ​ 10KG 12RM ​ 15KG 12RM ​ 20KG 12RM ​ 20KG 12RM 高位下拉最喜欢的动作之一​ 30KG 16RM ​ 40KG 12RM ​ 40KG 12RM ​ 50KG 12RM ​ 50KG 5RM 正手引体向上​ 随缘力竭5组","categories":[{"name":"BODY","slug":"BODY","permalink":"http://yoursite.com/categories/BODY/"}],"tags":[]},{"title":"划水日记","slug":"index","date":"2019-09-22T15:19:49.000Z","updated":"2019-10-07T14:27:11.110Z","comments":true,"path":"2019/09/22/ index/","link":"","permalink":"http://yoursite.com/2019/09/22/ index/","excerpt":"","text":"今日观影报告：罪恶之城 今日游戏报告：星际神族训练，还是找不准timing啊 我什么时候才能开始真正些blog啊…=-= 明天要开始冲了啊，不能再这样放纵自己下去了啊！！","categories":[{"name":"DIARY","slug":"DIARY","permalink":"http://yoursite.com/categories/DIARY/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T08:49:53.178Z","updated":"2019-08-30T08:49:53.178Z","comments":true,"path":"2019/08/30/ hello-world/","link":"","permalink":"http://yoursite.com/2019/08/30/ hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}