{"meta":{"title":"Xxgzbd's Blog","subtitle":"","description":"记录","author":"钟美智","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-09-23T05:28:32.000Z","updated":"2020-03-23T14:05:25.637Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2019-09-23T05:35:25.000Z","updated":"2020-03-23T11:42:22.673Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"state machine&Euclidean Alg","slug":"离散数学第4讲","date":"2020-03-21T08:09:17.000Z","updated":"2020-03-23T14:34:27.505Z","comments":true,"path":"2020/03/21/ 离散数学第4讲/","link":"","permalink":"http://yoursite.com/2020/03/21/ 离散数学第4讲/","excerpt":"","text":"state machine 水壶问题 有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: 12输入: x = 3, y = 5, z = 4输出: True 示例 2: 12输入: x = 2, y = 6, z = 5输出: False 我们不妨将每一次两个水壶中所拥有的水的体积作为该时刻的状态。 状态表示为$P(n)=(a,b)$。 其中，$a$表示容量为$x$升的水壶所有的水，$b$表示容量为$y$升的水壶所有的水。 状态转移有装满一个水壶；清空一个水壶；从一个水壶向另外一个水壶倒水，知道装满或者倒空。 最终状态必然有$a_0+b_0=z$ 1结论：ans=GCD(x,y)|z 容易推理出若$m|a_0,m|b_0,则有m|z$ 那么我们需要寻找这样的状态$(a_0,b_0)$ 证明：m|x且m|y\\Longrightarrow m|a且m|b不妨设$m|x且m|y$。 显然$P(0)=(0,0),任意m|0符合(1)式$ 设$P(n)=(a,b),m|a且m|b$ 证明$P(n+1)=(a_1,b_1),m|a_1,m|b_1$ 根据状态转移有 P(n+1)=\\left\\{ \\begin{array}{lr} (a,0)\\\\ (0,b)\\\\ (x,b)\\\\ (a,y)\\\\ (a-(y-b),y)\\\\ (0,a+b)\\\\ (x,b-(x-a))\\\\ (a+b,0)\\\\ \\end{array} \\right.只证$(2)式$的每一个数字都能被$m$整除，答案是显然的。 那么我们就可以得到最终的状态$(a_0,b_0)必然有m|a_0,m|b_0,那么有m|z$。 为了保证每一个$m$的取值都能满足以上推论。 必然需要满足$GCD(x,y)|z$ 所以有$z\\%GCD(x,y)==0$ Euclidean Alg GCD(a,b)=GCD(Remainder(b,a),a)\\\\ 其中，Remainder(b,a)=b-q*a=b\\%a\\geq0\\ \\ \\ \\ \\ a,b,q均为正整数证明$m|a且m|b\\Longrightarrow m|Remainder(b,a)且m|a$ 答案是显然的。 现只需证明$m|Remainder(b,a) 且m|a\\Longrightarrow m|b$ 已知b-qa=k_1m,a=k_2m\\\\ 有b=(k_1+k_2q)m\\\\ 有m|b1234567891011121314151617181920class Solution &#123;public: int GCD(int a,int b)&#123; if(a==0||b==0) return max(a,b); int c; while(b%a!=0)&#123; c=b%a; b=a; a=c; &#125; return a; &#125; bool canMeasureWater(int x, int y, int z) &#123; if(z==0) return true; if(z&gt;x+y)return false; int m=GCD(x,y); if(z%m==0) return true; return false; &#125;&#125;;","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://yoursite.com/categories/离散数学/"}],"tags":[]},{"title":"算法设计与分析","slug":"算法设计及分析","date":"2020-02-13T14:42:33.000Z","updated":"2020-03-24T04:22:32.770Z","comments":true,"path":"2020/02/13/ 算法设计及分析/","link":"","permalink":"http://yoursite.com/2020/02/13/ 算法设计及分析/","excerpt":"","text":"12证明$f(n)=O(g(n))$，有 \\exists c,n_0,对于\\forall n\\geq n_0 有 f(n)\\leq c*g(n)即$g(n)$时$f(n)$的渐近上限。 证明$f(n)=\\Omega (g(n))$，有 \\exists c,n_0,对于\\forall n\\geq n_0 有 f(n)\\geq c*g(n)即$g(n)$时$f(n)$的渐近下限。 若同时满足$(1),(2)$ 则有 f(n)=\\Theta (g(n)),且g(n)=\\theta (f(n))例题： 1证明$g(n)=\\Omega (f(n)),则 \\Omega (f(n))+\\Omega (g(n))=\\Omega (f(n))$ 易知$\\exists c_1,n_1,对于\\forall n\\geq n_1,有f(n)\\geq c_1*g(n)$ 设有$p(n)=\\Omega (g(n)),即\\exists c_2,n_2,对于\\forall n\\geq n_2,有g(n)\\geq c_2*p(n) $ 可得$ \\Omega (f(n))+\\Omega (g(n))=g(n)+p(n),设n_3= max{ n1,n2},g(n)+p(n))\\geq c_1f(n)+c_2g(n)$ $则\\exists c_3=min{ c_1,c_2},使得\\forall n\\geq n_3,有\\Omega(f(n))+\\Omega(g(n))\\geq c_3*(f(n)+g(n)),故有\\Omega(f(n))+\\Omega(g(n))=\\Omega(f(n)+g(n))$ 2证明$\\Omega(cf(n))=\\Omega(f(n))$ 不妨设$\\Omega(f(n))=g(n),即\\exists c_1,n_1,对于\\forall n\\geq n_1,有f(n)\\geq c_1*g(n)$ 故有$cf(n)\\geq cc_1*g(n)。$ 即$\\exists cc1,n_1,对于\\forall n\\geq n_1,有f(n)\\geq cc_1*g(n)$ 故有$\\Omega(cf(n))=g(n)$ 故有$\\Omega(cf(n))=\\Omega(f(n))$ 3证明$f(n)=\\Omega(f(n))$ $易知，\\exists c=1,n_0=1,对于\\forall n \\geq n_0,有f(n)\\geq c*f(n)$ 故原式成立。 4不成立。 比如： $f(n)=n^3 而 g(n)=n^2$ 5证明$\\Theta(f(n))+\\theta(g(n))=\\Theta(max(f(n)+g(n)))$ 设$p(n)=max{f(n),g(n)}$ $不妨设f_1(n)=\\Theta(f(n)),g_1(n)=\\theta(g(n)),可得$ $\\exists c_1,c_2,n_1,对于\\forall n\\geq n_1,有c_1f(n)\\leq f_1(n)\\leq c_2f(n)$ $\\exists b_1,b_2,n_2,对于\\forall n\\geq n_2,有b_1g(n)\\leq g_1(n)\\leq b_2g(n)$ 对于任意$n\\geq max{ n_1,n_2}$ 有$\\frac{min{ c_1,b_1}}{2}max{ f(n),g(n)}\\leq f_1(n)+g_1(n)\\leq 2max{ c_2,b_2}*max{ f(n),g(n)}$ 故原式成立。 6证明$\\Theta (f(n))+\\Theta(g(n))=\\Theta(f(n)+g(n))$ $不妨设f_1(n)=\\Theta(f(n)),g_1(n)=\\theta(g(n)),可得$ $\\exists c_1,c_2,n_1,对于\\forall n\\geq n_1,有c_1f(n)\\leq f_1(n)\\leq c_2f(n)$ $\\exists b_1,b_2,n_2,对于\\forall n\\geq n_2,有b_1g(n)\\leq g_1(n)\\leq b_2g(n)$ 对于任意$n\\geq max{ n_1,n_2}$ 有$min{ c_1,b_1}(f(n)+g(n))\\leq f_1(n)+g_1(n)\\leq max{ c_2,b_2}(f(n)+g(n))$ 故原式成立。","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/categories/算法设计与分析/"}],"tags":[]},{"title":"Warshall&All_componet","slug":"Warshall","date":"2019-11-18T13:44:59.000Z","updated":"2020-03-23T14:18:30.383Z","comments":true,"path":"2019/11/18/ Warshall/","link":"","permalink":"http://yoursite.com/2019/11/18/ Warshall/","excerpt":"","text":"Warshall &amp; All_componet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;struct Edge&#123; int VerAdj; int cost; Edge*link;&#125;;struct Vertex&#123; int VerName; Edge*adjacent;&#125;;struct node&#123; int VerName; node*link;&#125;;int graphsize;int edgesize;const int MAX=1e2;void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i,j,k; int from,to,cost; for(i=0;i&lt;graphsize;i++) &#123; S[i].adjacent=NULL; S[i].VerName=i; &#125; for(i=1;i&lt;=edgesize;i++) &#123; scanf(\"%d%d\",&amp;from,&amp;to); Edge*p=new Edge; p-&gt;cost=0; p-&gt;link=NULL; p-&gt;VerAdj=to; Edge*q=S[from].adjacent; if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; if(q-&gt;cost&gt;p-&gt;cost) &#123; delete q; S[from].adjacent=p; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; if(q-&gt;link==NULL) &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; else &#123; if(q-&gt;link-&gt;VerAdj==p-&gt;VerAdj) &#123; if(q-&gt;link-&gt;cost&gt;p-&gt;cost) &#123; Edge*q0=q-&gt;link; p-&gt;link=q0-&gt;link; q-&gt;link=p; delete q0; &#125; else delete p; &#125; else &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125; &#125; &#125;&#125;void Warshall(Vertex S[],int WSM[MAX][MAX])&#123; int i,j,k; Edge*p; int a; for(i=0;i&lt;graphsize;i++) &#123; for(j=0;j&lt;graphsize;j++) &#123; if(i==j) WSM[i][j]=1; else &#123; WSM[i][j]=0; WSM[j][i]=0; &#125; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; p=S[i].adjacent; a=S[i].VerName; while(p!=NULL) &#123; WSM[a][p-&gt;VerAdj]=1; p=p-&gt;link; &#125; &#125; for(k=0;k&lt;graphsize;k++) &#123; for(i=0;i&lt;graphsize;i++) &#123; if(WSM[i][k]==1) &#123; for(j=0;j&lt;graphsize;j++) &#123; WSM[i][j]=(WSM[i][j])||(WSM[k][j]); &#125; &#125; &#125; &#125;&#125;void All_componet(Vertex S[])&#123; int WSM[MAX][MAX]; int markedList[MAX]; int i,j,k; for(i=0;i&lt;graphsize;i++) markedList[i]=0; Warshall(S,WSM); int t=0; int v; for(v=0;v&lt;graphsize;v++) &#123; if(markedList[v]==0) &#123; markedList[v]=1; node*scList=new node; scList-&gt;VerName=v; scList-&gt;link=NULL; node*q=scList; for(i=0;i&lt;graphsize;i++) &#123; if(i!=v&amp;&amp;WSM[v][i]==1&amp;&amp;WSM[i][v]==1) &#123; markedList[i]=1; node*p=new node; p-&gt;VerName=i; p-&gt;link=NULL; q-&gt;link=p; q=q-&gt;link; &#125; &#125; printf(\"t:%d\\n\",t); t=t+1; q=scList; node*q0; while(q!=NULL) &#123; printf(\"%d \",q-&gt;VerName); q0=q; q=q-&gt;link; delete q0; &#125; cout&lt;&lt;endl; &#125; &#125;&#125;/*6 70 10 31 22 03 44 55 4*/int main()&#123; Vertex S[MAX]; Init(S); All_componet(S); return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Kmeans","slug":"Kmeans","date":"2019-11-13T14:42:33.000Z","updated":"2020-03-23T14:17:27.839Z","comments":true,"path":"2019/11/13/ Kmeans/","link":"","permalink":"http://yoursite.com/2019/11/13/ Kmeans/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#基于聚类算法(kmeans)的图像分割'''导入所需要的模块：1.用于处理二维矩阵的数学库2.随机生成数的模块3.用于将图片(JPG)转换为矩阵以及把矩阵转换为图片(JPG)的模块'''import numpy as npfrom random import randomfrom PIL import Image# 导入数据，file_path是图像的存储位置# 返回值def load_data(file_path): f = open(file_path, \"rb\") # 以二进制的方式打开图像文件 data = [] im = Image.open(f) # 导入图片 m, n = im.size # 得到图片的大小 print (m), (n) for i in range(m): for j in range(n): tmp = [] x, y, z = im.getpixel((i, j)) tmp.append(x / 256.0) tmp.append(y / 256.0) tmp.append(z / 256.0) data.append(tmp) f.close() return np.mat(data)def distance(vecA, vecB): '''计算vecA与vecB之间的欧式距离的平方 input: vecA(mat)A点坐标 vecB(mat)B点坐标 output: dist[0, 0](float)A点与B点距离的平方 ''' dist = (vecA - vecB) * (vecA - vecB).T return dist[0, 0]def randCent(data, k): '''随机初始化聚类中心 input: data(mat):训练数据 k(int):类别个数 output: centroids(mat):聚类中心 ''' n = np.shape(data)[1] # 属性的个数 centroids = np.mat(np.zeros((k, n))) # 初始化k个聚类中心 for j in range(n): # 初始化聚类中心每一维的坐标 minJ = np.min(data[:, j]) rangeJ = np.max(data[:, j]) - minJ # 在最大值和最小值之间随机初始化 centroids[:, j] = minJ * np.mat(np.ones((k , 1))) + np.random.rand(k, 1) * rangeJ return centroidsdef kmeans(data, k, centroids): '''根据KMeans算法求解聚类中心 input: data(mat):训练数据 k(int):类别个数 centroids(mat):随机初始化的聚类中心 output: centroids(mat):训练完成的聚类中心 subCenter(mat):每一个样本所属的类别 ''' m, n = np.shape(data) # m：样本的个数，n：特征的维度 subCenter = np.mat(np.zeros((m, 2))) # 初始化每一个样本所属的类别 change = True # 判断是否需要重新计算聚类中心 while change == True: change = False # 重置 for i in range(m): minDist = np.inf # 设置样本与聚类中心之间的最小的距离，初始值为争取穷 minIndex = 0 # 所属的类别 for j in range(k): # 计算i和每个聚类中心之间的距离 dist = distance(data[i, ], centroids[j, ]) if dist &lt; minDist: minDist = dist minIndex = j # 判断是否需要改变 if subCenter[i, 0] != minIndex: # 需要改变 change = True subCenter[i, ] = np.mat([minIndex, minDist]) # 重新计算聚类中心 for j in range(k): sum_all = np.mat(np.zeros((1, n))) r = 0 # 每个类别中的样本的个数 for i in range(m): if subCenter[i, 0] == j: # 计算第j个类别 sum_all += data[i, ] r += 1 for z in range(n): try: centroids[j, z] = sum_all[0, z] / r print (r) except: print (\" r is zero\") return subCenterdef save_result(file_name, source): '''保存source中的结果到file_name文件中 input: file_name(string):文件名 source(mat):需要保存的数据 output: ''' m, n = np.shape(source) f = open(file_name, \"w\") for i in range(m): tmp = [] for j in range(n): tmp.append(str(source[i, j])) f.write(\"\\t\".join(tmp) + \"\\n\") f.close()# --------------------------------------------------FLOAT_MAX = 1e100 # 设置一个较大的值作为初始化的最小的距离def nearest(point, cluster_centers): '''计算point和cluster_centers之间的最小距离 input: point(mat):当前的样本点 cluster_centers(mat):当前已经初始化的聚类中心 output: min_dist(float):点point和当前的聚类中心之间的最短距离 ''' min_dist = FLOAT_MAX m = np.shape(cluster_centers)[0] # 当前已经初始化的聚类中心的个数 for i in range(m): # 计算point与每个聚类中心之间的距离 d = distance(point, cluster_centers[i, ]) # 选择最短距离 if min_dist &gt; d: min_dist = d return min_distdef get_centroids(points, k): '''KMeans++的初始化聚类中心的方法 input: points(mat):样本 k(int):聚类中心的个数 output: cluster_centers(mat):初始化后的聚类中心 ''' m, n = np.shape(points) cluster_centers = np.mat(np.zeros((k , n))) # 1、随机选择一个样本点为第一个聚类中心 index = np.random.randint(0, m) cluster_centers[0, ] = np.copy(points[index, ]) # 2、初始化一个距离的序列 d = [0.0 for _ in range(m)] print (\"\\t初始化一个距离序列\") print (\" k=\",k) for i in range(1, k): print(i) sum_all = 0 for j in range(m): # 3、对每一个样本找到最近的聚类中心点 d[j] = nearest(points[j, ], cluster_centers[0:i, ]) # 4、将所有的最短距离相加 sum_all += d[j] # 5、取得sum_all之间的随机值 sum_all *= random() # 6、获得距离最远的样本点作为聚类中心点 for j, di in enumerate(d): sum_all -= di if sum_all &gt; 0: continue cluster_centers[i] = np.copy(points[j, ]) break return cluster_centersdef run_kmeanspp(data, k): # 1、KMeans++的聚类中心初始化方法 print (\"\\t---------- 1.K-Means++ generate centers ------------\") centroids = get_centroids(data, k) # 2、聚类计算 print (\"\\t---------- 2.kmeans ------------\") subCenter = kmeans(data, k, centroids) # 3、保存所属的类别文件 print (\"\\t---------- 3.save subCenter ------------\") save_result(\"sub_pp\", subCenter) # 4、保存聚类中心 print (\"\\t---------- 4.save centroids ------------\") save_result(\"center_pp\", centroids)#--------------------------------------------------k = 4 #聚类中心的个数# 1、导入数据print (\"---------- 1.load data ------------\")data = load_data(\"Pic_B.jpg\")# 2、利用kMeans++聚类print (\"---------- 2.run kmeans++ ------------\")run_kmeanspp(data, k)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[]},{"title":"Prim","slug":"Prim","date":"2019-11-13T14:42:33.000Z","updated":"2020-03-23T14:20:26.806Z","comments":true,"path":"2019/11/13/ Prim/","link":"","permalink":"http://yoursite.com/2019/11/13/ Prim/","excerpt":"","text":"Prim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int cost; int head; int tail;&#125;;const int MAX=1e6;edge E[MAX];edge TE[MAX];int graphsize;int edgesize;struct LV&#123; int Lowcost; int Vex;&#125;;LV closedge[MAX];int Edge[5010][5010];//稠密图，使用邻接矩阵void Prim()&#123; int i; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); for(i=0;i&lt;graphsize;i++) &#123; for(int j=0;j&lt;graphsize;j++) &#123; Edge[i][j]=1e9; Edge[j][i]=1e9; &#125; &#125; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;E[i].head,&amp;E[i].tail,&amp;E[i].cost); //防止重边 if(E[i].cost&lt;Edge[E[i].head-1][E[i].tail-1]) &#123; Edge[E[i].head-1][E[i].tail-1]=E[i].cost; Edge[E[i].tail-1][E[i].head-1]=E[i].cost; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; closedge[i].Lowcost=Edge[0][i]; closedge[i].Vex=0; &#125; closedge[0].Vex=-1; int count=0; int ans=0; for(i=1;i&lt;graphsize;i++) &#123; int Min=1e9+1; int v=0; for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;closedge[j].Lowcost&lt;Min) &#123; v=j; Min=closedge[j].Lowcost; &#125; &#125; if(v!=0) &#123; ans=ans+closedge[v].Lowcost; TE[count].head=closedge[v].Vex; TE[count].tail=v; TE[count].cost=closedge[v].Lowcost; count++; closedge[v].Lowcost=0; closedge[v].Vex=-1; //进行一些操作使得它们保持最小 for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;Edge[v][j]&lt;closedge[j].Lowcost) &#123; closedge[j].Lowcost=Edge[v][j]; closedge[j].Vex=v; &#125; &#125; &#125; &#125; printf(\"%d\",ans);&#125;//prim/*6 100 1 10 2 40 3 71 2 42 3 21 5 22 5 52 4 33 4 64 5 3*/int main()&#123; Prim();&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"随机数学","slug":"概率论与数理统计","date":"2019-11-13T14:42:33.000Z","updated":"2020-03-23T14:16:35.592Z","comments":true,"path":"2019/11/13/ 概率论与数理统计/","link":"","permalink":"http://yoursite.com/2019/11/13/ 概率论与数理统计/","excerpt":"","text":"随机事件及其概率1引入随机试验，简称为试验；若均满足：可重复性；可观测性；随机性。 $E:$ 试验 $w$: 样本点 $\\Omega = ${ $w_1,w_2…w_i$ } : 样本空间 $A$，其中$A\\subseteqq \\Omega$: 事件 {$w_i$} : 基本事件 $\\Omega$: 必然事件 $\\phi$: 不可能事件 若 试验结果 $w\\in A$,则称事件A发生 事件的关系$A\\subseteqq B $: 包含 $A=B$: 相等 互斥： 不能同时发生 $\\bar{A}=B$: 互逆，对立 事件的运算$A\\cup B=${$w|w\\in A或w\\in B$} $A\\cap B或AB=${$w|w\\in A或w\\in B$} $A-B=${$w|w\\in A且 w\\notin B$} $\\overline {A\\cup B}=\\overline A\\cap \\overline B$ $\\overline {A\\cap B}=\\overline A\\cup \\overline B$ 2$n_A$: 事件A发生的频数 $f_n(A)$: 事件A发生的频率 $其中 f_n(A)=\\frac{n_A}{n}$ 减法公式：$P(B-A)=P(B)-P(AB)$ 加法公式：$P(A\\cup B)=P(A)+P(B)-P(AB)$ 古典概型：有限个样本点；基本事件发生的可能性相同。 几何概型 3条件概型：$P(B|A)=\\frac{P(AB)}{P(A)} \\Longrightarrow P(AB)=P(A)P(B|A)$ 条件概型的性质：非负性；规范性：$P(\\Omega |A)=1$；可列可加性：对于不相容的事件$B_1,B_2,\\cdot \\cdot \\cdot $有 P((\\cup_{i=1}^\\infty B_i )|A)=\\sum_{i=1}^\\infty P(B_i|A)全概率公式：$P(B)=\\sum\\limits_{i=1}^nP(A_i)P(B|A_i)$ ​ 其中： $\\cup {i=1} ^n A_i=\\Omega 且 \\cap {i=1} ^n A_i=\\Phi$ 推导： 对任意事件B，有 B=B\\cap \\Omega =B\\cap (\\cup _{i=1} ^n A_i)=\\cup _{i=1} ^n {A_iB} 由条件概型的性质可得全概率公式。若某问题可画出概率树，那么该问题属于条件概型，甚至符合全概率公式。 贝叶斯公式： P(A_j|B)=\\frac{P(A_jB)}{P(B)}=\\frac{P(B|A_j)P(A_j)}{\\sum_{i=1}^nP(A_i)P(B|A_i)}4如果 P(AB)=P(A)P(B)则称事件A与事件B相互独立。 若某试验$E$是n重伯努利试验，即试验$E$只有两个对立的结果，将其进行n次。设$P(A)=p$。 有 P_n(k)=(_k^n)p^k(1-p)^{n-k}=C_n^kp^k(1-p)^{n-k}随机变量及其概率分布1 随机变量性质： $P${$a&lt;X\\leq b$}$=P{ X\\leq b}-P{ X\\leq a}=F(b)-F(a)$ 单调不减 $F(-\\infty )=lim_{x\\rightarrow -\\infty }F(x)=0$ $F(+\\infty )=lim_{x\\rightarrow +\\infty }F(x)=1$ F(x)是右连续的，即$F(x^{+})=F(x)$ 2离散型随机变量两点分布 二项分布 几何分布 泊松分布：$P{ X=k}=\\frac{\\lambda ^ke^{-\\lambda}}{k!}$，其中，$\\lambda$为服从参数 3连续型随机变量均匀分布 指数分布 正态分布，有概率密度函数 f(x)=\\frac{1}{\\sqrt{2\\pi }\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}},-\\infty","categories":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/categories/Course/"}],"tags":[]},{"title":"BinTree","slug":"BinTree","date":"2019-10-27T04:28:29.000Z","updated":"2020-03-23T14:21:41.364Z","comments":true,"path":"2019/10/27/ BinTree/","link":"","permalink":"http://yoursite.com/2019/10/27/ BinTree/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#include&lt;stack&gt;#include&lt;utility&gt;#include&lt;queue&gt;using namespace std;template&lt;class T&gt;class BinTreeNode&#123;public: BinTreeNode&lt;T&gt;*left; BinTreeNode&lt;T&gt;*right; T data;public: BinTreeNode(const T&amp;item,BinTreeNode&lt;T&gt;*L=NULL,BinTreeNode&lt;T&gt;*R=NULL):data(item),left(L),right(R)&#123;&#125; BinTreeNode&lt;T&gt;*GetLeft()const &#123; return left; &#125; BinTreeNode&lt;T&gt;*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode&lt;T&gt;*L) &#123; left=L; &#125; void SetRight(BinTreeNode&lt;T&gt;*R) &#123; right=R; &#125; T&amp; GetData()&#123;return data;&#125; void SetData(const T&amp;item)&#123;data=item;&#125;&#125;;template&lt;class T&gt;class BinTree&#123;public: BinTreeNode&lt;T&gt;*root; T stop;public: BinTree(BinTreeNode&lt;T&gt;*t=NULL):root(t)&#123;&#125; void PreOrder(BinTreeNode&lt;T&gt;*t)const; void InOrder(BinTreeNode&lt;T&gt;*t)const; void PostOrder(BinTreeNode&lt;T&gt;*t)const; void LevelOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPreOrder(BinTreeNode&lt;T&gt;*t)const; void NorecInOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPostOrder(BinTreeNode&lt;T&gt;*t)const; void CreateBinTree(T tostop); BinTreeNode&lt;T&gt;* Create(); BinTreeNode&lt;T&gt;*CopyTree(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p); BinTreeNode&lt;T&gt;*Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const; void InsertLeft(T item,BinTreeNode&lt;T&gt;*t); void InsertRight(T item,BinTreeNode&lt;T&gt;*s); void DelSubtree(BinTreeNode&lt;T&gt;*t); void Del(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*GetRoot()&#123;return root;&#125; void SetRoot(BinTreeNode&lt;T&gt;*t)&#123;root=t;&#125; T getStop()&#123;return stop;&#125; void SetStop(T tostop)&#123;stop=tostop;&#125; bool IsEmpty()&#123;return root==NULL;&#125;&#125;;template&lt;class T&gt;void BinTree&lt;T&gt;::PreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; PreOrder(t-&gt;GetLeft()); PreOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; InOrder(t-&gt;GetLeft()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; InOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::PostOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; PostOrder(t-&gt;GetLeft()); PostOrder(t-&gt;GetRight()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecInOrder(BinTreeNode&lt;T&gt;*t)const&#123; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; while(t!=NULL||S.empty()==false) &#123; while(t!=NULL) &#123; S.push(t); t=t-&gt;GetLeft(); &#125; if(S.empty()==true)return ; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; t=t-&gt;GetRight(); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t==NULL)return ; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; S.push(t); while(S.empty()==false) &#123; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; if(t-&gt;GetRight()!=NULL) S.push(t-&gt;GetRight()); if(t-&gt;GetLeft()!=NULL) S.push(t-&gt;GetLeft()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPostOrder(BinTreeNode&lt;T&gt;*t)const&#123; pair&lt;BinTreeNode&lt;T&gt;*,int&gt; p; if(t==NULL)return ; p=make_pair(t,0); stack&lt;pair&lt;BinTreeNode&lt;T&gt;*,int&gt;&gt;S; S.push(p); while(S.empty()==false) &#123; p=S.top(); S.pop(); if(p.second==0) &#123; p.second++; S.push(p); if((p.first)-&gt;GetLeft()!=NULL) &#123; p.first=(p.first)-&gt;GetLeft(); p.second=0; S.push(p); &#125; &#125; else &#123; if(p.second==1) &#123; p.second++; S.push(p); if((p.first)-&gt;GetRight()!=NULL) &#123; p.first=(p.first)-&gt;GetRight(); p.second=0; S.push(p); &#125; &#125; else &#123; cout&lt;&lt;p.first-&gt;GetData()&lt;&lt;endl; &#125; &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::LevelOrder(BinTreeNode&lt;T&gt;*t)const&#123; queue&lt;BinTreeNode&lt;T&gt;*&gt;Q; if(t==NULL)return ; BinTreeNode&lt;T&gt; *p=t; Q.push(p); while(Q.empty()==false) &#123; p=Q.front(); Q.pop(); cout&lt;&lt;p-&gt;GetData()&lt;&lt;endl; if(p-&gt;GetLeft()!=NULL) &#123; Q.push(p-&gt;GetLeft()); &#125; if(p-&gt;GetRight()!=NULL) &#123; Q.push(p-&gt;GetRight()); &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::CreateBinTree(T tostop)&#123; SetStop(tostop); root=Create();&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;* BinTree&lt;T&gt;::Create()&#123; BinTreeNode&lt;T&gt;*t,*t1,*t2; T item; cin&gt;&gt;item; if(item==stop) &#123; t=NULL; return t; &#125; t=new BinTreeNode&lt;T&gt;(item,NULL,NULL); t1=Create(); t-&gt;SetLeft(t1); t2=Create(); t-&gt;SetRight(t2); return t;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::CopyTree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return NULL; BinTreeNode&lt;T&gt;*L=nullptr,*R=nullptr; if(t-&gt;GetLeft()!=NULL) &#123; L=CopyTree(t-&gt;GetLeft()); &#125; if(t-&gt;GetRight()!=NULL) &#123; R=CopyTree(t-&gt;GetRight()); &#125; BinTreeNode&lt;T&gt;*nod=new BinTreeNode&lt;T&gt;(t-&gt;GetData(),L,R); return nod;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p)&#123; BinTreeNode&lt;T&gt;*q; if(t==NULL||p==NULL) return NULL; if(t-&gt;GetLeft()==p||t-&gt;GetRight()==p) return t; q=Father(t-&gt;GetLeft(),p); if(q!=NULL)return q; return Father(t-&gt;GetRight(),p);&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const&#123; BinTreeNode&lt;T&gt;*p; if(t==NULL)return NULL; if(t-&gt;data==item) return t; p=Find(t-&gt;GetLeft(),item); if(p!=NULL) return p; p=Find(t-&gt;GetRight(),item); return p;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::Del(BinTreeNode&lt;T&gt;*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertLeft(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetLeft(s-&gt;GetLeft()); p-&gt;SetRight(NULL); s-&gt;SetLeft(p);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertRight(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetRight(s-&gt;GetRight()); s-&gt;SetRight(p); p-&gt;SetLeft(NULL);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::DelSubtree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return ; if(t==root) &#123; Del(t); root=NULL; return ; &#125; BinTreeNode&lt;T&gt;*f=Father(root,t); if(f!=nullptr) &#123; if(f-&gt;GetLeft()==t) f-&gt;SetLeft(NULL); if(f-&gt;GetRight()==t)f-&gt;SetRight((NULL)); &#125; Del(t);&#125;int main()&#123; BinTree&lt;int&gt; t; t.CreateBinTree(-1); BinTreeNode&lt;int&gt;*t2=t.Find(t.root,4); t.InsertRight(6,t2); t.InOrder(t.root); return 0;&#125;/*1 2 4 -1 5 -1 -1 -1 3 -1 -1*/","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"EulerSieve","slug":"EulerSieve","date":"2019-10-21T06:16:46.000Z","updated":"2020-03-23T14:14:06.771Z","comments":true,"path":"2019/10/21/ EulerSieve/","link":"","permalink":"http://yoursite.com/2019/10/21/ EulerSieve/","excerpt":"","text":"EulerSieve时间复杂度​ O(n) 实现12345678910111213141516171819202122const int maxn = 10100; int prime[maxn], pNum = 0; // prime记录素数，pNum记录素数个数 //保存的值为0~pNum-1bool p[maxn] = &#123;false&#125;; // p记录当前数是否被筛去void EulerSieve(int n) // 查找记录2-n的素数&#123; int j; for (int i = 2; i &lt;= n; i++) &#123; if (p[i] == false) // 如果未被筛过，则为素数 prime[pNum++] = i; for (j = 0; j &lt; pNum; j++) &#123; if (i * prime[j] &gt; n) // 当要标记的合数超出范围时跳出 break; p[i * prime[j]] = true; // 将已经记录的素数的倍数进行标记 if (i % prime[j] == 0) //关键步骤 break; &#125; &#125;&#125; 理解时间复杂度证明","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"qpow","slug":"qpow","date":"2019-10-20T17:18:42.000Z","updated":"2020-03-23T14:18:39.223Z","comments":true,"path":"2019/10/21/ qpow/","link":"","permalink":"http://yoursite.com/2019/10/21/ qpow/","excerpt":"","text":"快速幂假设​ 求x^n的值 时间复杂度​ O(log n) 解释​ 通过加大底数的权重来使得乘法次数更少 ​ 1.假设n为奇数：x^n=x*x^(n-1) 则将x计入结果 ​ 2.假设n为偶数：x^n=x^(n/2)*x^(n/2) 则将x的权重变为x^2 实现代码1234567891011121314/*快速幂运算 log 2 n*/typedef long long LL;LL qpow(LL a, LL n, LL mod)&#123; LL result = 1; while (n!=0) &#123; if (n &amp; 1) result = (result * a) % mod;//计入结果 a = (a * a) % mod;//权重变大 n &gt;&gt;= 1;//n=n/2; &#125; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Kruskal","slug":"Kruskal","date":"2019-10-10T14:56:52.000Z","updated":"2020-03-23T14:14:19.299Z","comments":true,"path":"2019/10/10/ Kruskal/","link":"","permalink":"http://yoursite.com/2019/10/10/ Kruskal/","excerpt":"","text":"Kruskal Kruskal总是维护无向连通图的最小生成森林 最终得到该图的最小生成树 由来​ Kruskal算法是一种用来查找最小生成树的贪心算法，由Joseph Kruskal在1956年发表。 假设​ 有n个点m条无向边的图，且已知每一条边(x,y,z)，代表点x和点y之间有哦权值为z的无向边。 时间复杂度​ O(m log m) 预备知识​ 并查集 先挖坑 解释​ 在遍历所给无向连通图的过程中，kruskal 总是维护着最小生成森林。 ​ 最终得到最小生成树。 ​ 有以下步骤： ​ 1.初始化并查集，每一个点各自构成一个集合 ​ 2.对边集S进行从小到大排序 ​ 3.从S中取出一条边（注意：现在是从S中从小到大取出，判断这条边的两个端点是否属于同一个集合（使用并查集维护），不是则将端点x和端点y使用并查集combine起来。且将边加入最小生成森林。 ​ 4.不断重复S直至访问完所有边 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//以边集来保存图，假设有m条边//时间复杂度为mlogmconst int MAX=11010;struct edge&#123; int x; int y; int z;&#125;;//代表x和y两点之间有路且权值为zedge S[MAX];int Father[MAX];int n,m;int ans;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; return a.z&lt;b.z;&#125;inline void Init()&#123; int i; scanf(\"%d%d\",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;S[i].x,&amp;S[i].y,&amp;S[i].z);&#125;//并查集找父亲inline int Find(int x)&#123; while(x!=Father[x]) x=Father[x]; return x; &#125;//combineinline void combine(int x,int y)&#123; Father[x]=y;&#125;inline void Kruskal()&#123; ans=0; int x; int y; int i; for(i=1;i&lt;=n;i++) Father[i]=i; sort(S+1,S+m+1); for(i=1;i&lt;=m;i++) &#123; x=Find(S[i].x); y=Find(S[i].y); if(x!=y) &#123; ans=ans+S[i].z; combine(x,y); &#125; &#125;&#125; 模板题 ​ 回顾学习算法的第四天。戒掉可乐的第四天 ​ Orz ​ Orz","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Manacher","slug":"Manacher","date":"2019-10-09T15:21:21.000Z","updated":"2020-03-23T14:14:43.854Z","comments":true,"path":"2019/10/09/ Manacher/","link":"","permalink":"http://yoursite.com/2019/10/09/ Manacher/","excerpt":"","text":"由来​ 1975年，一个叫Manacher的人发明了一个Manacher算法 作用​ 给定一个字符串S，求出其最大回文子串 时间复杂度 O(n) 原理 对称性 1.字符串处理​ 由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 ​ Example： 原串S a c a b a 转换后的串T # a # c # a # b # a # ​ 为了防止越界，做出以下修改，使得T变成$#a#a#a#b#a#@ 2.Len数组​ 设有字符串T上的位置i，Len[i]表示以i为中心的回文串的半径，和KMP算法相比，这里的数组并非只是预处理的作用，而是在线的处理 ​ 可得： i 1 2 3 4 5 6 7 8 9 10 11 T[i] # a # c # a # b # a # Len[i] 1 2 1 4 1 2 1 4 1 2 1 ​ 如何得到Len数组？ ​ （先挖坑） ​ 主要思想是利用对称性 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int MAX=110000000+10;char S[MAX];//原串char tmp[MAX*2+10];//辅助字符串Tint Len[MAX*2+10];//Len数组int N1;//原串S的长度int N2;//T的长度inline void GetT()&#123; int i,N1=strlen(S); N2=N1*2+1; tmp[0]='$'; for(i=1;i&lt;=2*N1;i=i+2) &#123; tmp[i]='#'; tmp[i+1]=S[i/2]; &#125; tmp[i]='#'; tmp[i+1]='@'; //这样处理的原因是优化后面的操作，比如这样的情况 \"bb\" tmp[i+2]=0;&#125;//得到最大的回文串长度inline int Manacher()&#123; GetLen(); int mx=0; int ans=0; int po=0; int i; for(i=1;i&lt;=N2;i++) &#123; if(mx&gt;i) &#123; //对称性,两者取最小 if((mx-i)&lt;Len[2*po-1]) Len[i]=mx-i; else Len[i]=Len[2*po-1]; &#125; else//第三种情况 Len[i]=1; //不断向外扩展，巧妙 while(tmp[i-Len[i]]==tmp[i+Len[i]]) Len[i]++; //更新值 if(Len[i]+i&gt;mx) &#123; mx=Len[i]+i; po=i; &#125; if(Len[i]&gt;ans) ans=Len[i]; &#125; return ans-1;&#125; 1234567891011121314151617181920212223242526272829public class Solution &#123; public String Manacher(String s)&#123; if(s.length()&lt;2) return s; String t=\"$\"; int i=0,k=0,j=0; for(i=0;i&lt;s.length();i++) t+=\"#\"+s.charAt(i); t+=\"#@\"; int n=t.length(); int [] p=new int[n]; int mx=0; int id=0; int index=0; int maxLength=-1; for(i=1;i&lt;n-1;i++)&#123; p[i]=mx&gt;i ? Math.min(mx-i,p[2*id-i]):1;//第一种情况+第二种情况：第三种情况 while(t.charAt(i+p[i])==t.charAt(i-p[i])) p[i]++;//无论哪一种都可以进行拓展 if(mx&lt;i+p[i]) &#123;//更新右边界以及右边界的中心 mx=i+p[i]; id=i; &#125; if(maxLength&lt;p[i]-1)&#123;//更新最长回文串长度 maxLength=p[i]-1; index=i; &#125; &#125; int start=(index-maxLength)/2; return s.substring(start,start+maxLength); &#125;&#125; ​ https://blog.csdn.net/dyx404514/article/details/42061017","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"KMP","slug":"KMP","date":"2019-10-01T06:25:53.000Z","updated":"2020-03-23T14:19:45.078Z","comments":true,"path":"2019/10/01/ KMP/","link":"","permalink":"http://yoursite.com/2019/10/01/ KMP/","excerpt":"","text":"名字由来​ 由Knuth，Morris,Pratt三人所设计的线性时间字符串匹配算法 时间复杂度​ 设有长度为n的文本串S和长度为m的匹配串P，求匹配串成功匹配文本串字串的首地址 ​ O(n+m) 原理引出​ 对匹配串预处理生成一种失配的映射（或者称为函数，其实称为函数会更加恰当），我们姑且把这个函数成为Next函数。当匹配串对文本串进行匹配时，不妨想象一下，我们在失配的时候对应的失配位置i，都会有相同的移动位移，这样就会产生一个关于i的函数，我们姑且把这样的函数称之为Next(i)，那么这个函数的返回值是什么呢？在不同的博客上它的返回值是不一样的，比如，有些直接返回P下一个需要比较的位置，有些是返回P需要移动的距离（自行脑补一下），有些是返回最大该位置的最大的前后缀一样的字串的字符数，有些的Next函数是经过优化过的，自然返回值和原来的有些不一样。不过它们的使用方法都大同小异。 ​ 我们以返回值为P下一个需要匹配的位置为例。 Next函数的产生​ 先挖坑 1234567891011121314151617181920inline void GetNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; Next[j]=k; &#125; else &#123; k=Next[k]; &#125; &#125;&#125; NextPro数组的产生12345678910111213141516171819202122inline void GetProNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; //只是比Next数组多了一个判断罢了 if(P[j]!=P[k]) Next[j]=k; else Next[j]=Next[k]; &#125; else k=Next[k]; &#125;&#125; KMPSearch代码12345678910111213141516171819202122232425262728const int MAX=10010;char P[MAX];char S[MAX];int Next[MAX];int KmpSearch()&#123; GetProNext();//只需要在这里预处理P的Next数组即可 int sLen=strlen(S); int pLen=strlen(P); int i=0; int j=0; while(i&lt;sLen&amp;&amp;j&lt;pLen) &#123; if(j==-1||S[i]==P[j]) &#123; i++; j++; &#125; else &#123; j=Next[j]; &#125; &#125; if(j==pLen) return i-j; else return -1;&#125; 这个讲解很棒https://blog.csdn.net/v_JULY_v/article/details/7041827","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T08:49:53.178Z","updated":"2019-08-30T08:49:53.178Z","comments":true,"path":"2019/08/30/ hello-world/","link":"","permalink":"http://yoursite.com/2019/08/30/ hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}