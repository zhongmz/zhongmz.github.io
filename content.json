{"meta":{"title":"Xxgzbd's Blog","subtitle":"","description":"记录","author":"钟美智","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tag","date":"2019-09-23T05:35:25.000Z","updated":"2020-03-23T11:42:22.673Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-23T05:28:32.000Z","updated":"2020-03-23T14:05:25.637Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"组合数学","slug":"组合数学","date":"2020-04-06T14:56:52.000Z","updated":"2020-04-08T10:16:52.490Z","comments":true,"path":"2020/04/06/ 组合数学/","link":"","permalink":"http://yoursite.com/2020/04/06/ 组合数学/","excerpt":"","text":"1n阶幻方，其幻和为： \\frac {n*(1+n^2)}{2}存在性：存在除2阶外的任意阶幻方。 计数与分类：奇数阶幻方；4n阶幻方；4n+2阶幻方。 构造方法：见课本 优化问题：略 2鸽巢原理 Ramsey定理 3线排列 圆排列 n元素集合的$r-$圆排列数为 \\frac {1}{r}P(n,r)=\\frac {n!}{r(n-r)!}集合的排列数和组合数 多重集合的排列 M=\\{ \\infty \\cdot a_1,\\infty \\cdot a_2...\\infty \\cdot a_n\\}的r-排列数是n^r\\\\ M=\\{ k_1\\cdot a_1,k_2\\cdot a_2...k_n\\cdot a_n\\}的全排列数为\\frac {(k_1+k_2...+k_n)!}{k_1!k_2!...k_n!}常利用公式(4)和分类法来解题目 多重集合的组合 M=\\{ \\infty \\cdot a_1,\\infty \\cdot a_2...\\infty \\cdot a_n\\}的r-组合数为\\dbinom{n+r-1}{r} M=\\{ \\infty \\cdot a_1,\\infty \\cdot a_2...\\infty \\cdot a_n\\},r \\geq n,则M中每一个元素至少取一个的r-组合数为 \\dbinom{r-1}{n-1}排列的生成 ​ (a) 邻位互换法，要得到${1,2…n}$的全排列，可以先得到${1,2…n-1}$的全排列，然后将n插入到其排列中。 ​ 活动状态：当一个数上方的箭头所指的一侧，相邻的数比该数小，那么该数处于活动状态。 ​ (b) 字典序法 $x_1+x_2…+x_n=r$的非负整数解集个数为：$\\frac{(n+r-1)!}{(n-1)!*r!}=\\dbinom{n+r-1}{r}$ 其中，$x_i\\geq 0$ 二项式定理 {(x+y)}^n=\\dbinom{n}{0}x^0y^n+\\dbinom{n}{1}x^1y^{n-1}...+\\dbinom{n}{n-1}x^{n-1}y^1+\\dbinom{n}{n}x^ny^0，其中n\\geq 0 \\dbinom{n}{k}\\\\ (1)\\ \\dbinom{n}{k}=\\dbinom{n}{n-k} \\\\ (2)\\ \\dbinom{n}{k}=\\dbinom{n-1}{k}+\\dbinom{n-1}{k-1}\\\\ (3)\\ \\dbinom{n}{\\frac{n}{2}}为max\\\\4 容斥原理$S中不具有性质P_1,P_2\\dots,P_m的元素个数为$$​ |\\overline{A_1}\\cap\\overline{A_2}\\cap\\dots\\cap\\overline{A_m}|\\\\=|S|-\\sum_{ i= 1}^{m}|A_i|+\\sum_{1\\leq i","categories":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/categories/组合数学/"}],"tags":[]},{"title":"随机数学","slug":"概率论与数理统计","date":"2020-04-03T04:42:33.000Z","updated":"2020-04-08T10:28:43.816Z","comments":true,"path":"2020/04/03/ 概率论与数理统计/","link":"","permalink":"http://yoursite.com/2020/04/03/ 概率论与数理统计/","excerpt":"","text":"随机事件及其概率1引入随机试验，简称为试验；若均满足：可重复性；可观测性；随机性。 $E:$ 试验 $w$: 样本点 $\\Omega = ${ $w_1,w_2…w_i$ } : 样本空间 $A$，其中$A\\subseteqq \\Omega$: 事件 {$w_i$} : 基本事件 $\\Omega$: 必然事件 $\\phi$: 不可能事件 若 试验结果 $w\\in A$,则称事件A发生 事件的关系$A\\subseteqq B $: 包含 $A=B$: 相等 互斥： 不能同时发生 $\\bar{A}=B$: 互逆，对立 事件的运算$A\\cup B=${$w|w\\in A或w\\in B$} $A\\cap B或AB=${$w|w\\in A或w\\in B$} $A-B=${$w|w\\in A且 w\\notin B$} $\\overline {A\\cup B}=\\overline A\\cap \\overline B$ $\\overline {A\\cap B}=\\overline A\\cup \\overline B$ 2$n_A$: 事件A发生的频数 $f_n(A)$: 事件A发生的频率 $其中 f_n(A)=\\frac{n_A}{n}$ 减法公式：$P(B-A)=P(B)-P(AB)$ 加法公式：$P(A\\cup B)=P(A)+P(B)-P(AB)$ 古典概型：有限个样本点；基本事件发生的可能性相同。 几何概型 3条件概型：$P(B|A)=\\frac{P(AB)}{P(A)} \\Longrightarrow P(AB)=P(A)P(B|A)$ 条件概型的性质：非负性；规范性：$P(\\Omega |A)=1$；可列可加性：对于不相容的事件$B_1,B_2,\\cdot \\cdot \\cdot $有 P((\\cup_{i=1}^\\infty B_i )|A)=\\sum_{i=1}^\\infty P(B_i|A)全概率公式： P(B)=\\sum\\limits_{i=1}^nP(A_i)P(B|A_i)其中： \\cup _{i=1} ^n A_i=\\Omega 且 \\cap _{i=1} ^n A_i=\\Phi推导： 对任意事件B，有 B=B\\cap \\Omega =B\\cap (\\cup _{i=1} ^n A_i)=\\cup _{i=1} ^n {A_iB} 由条件概型的性质可得全概率公式。若某问题可画出概率树，那么该问题属于条件概型，甚至符合全概率公式。 贝叶斯公式： P(A_j|B)=\\frac{P(A_jB)}{P(B)}=\\frac{P(B|A_j)P(A_j)}{\\sum_{i=1}^nP(A_i)P(B|A_i)}4如果 P(AB)=P(A)P(B)则称事件A与事件B相互独立。 若某试验$E$是n重伯努利试验，即试验$E$只有两个对立的结果，将其进行n次。设$P(A)=p$。 有 P_n(k)=(_k^n)p^k(1-p)^{n-k}=C_n^kp^k(1-p)^{n-k}随机变量及其概率分布1 随机变量性质： $P${$a&lt;X\\leq b$}$=P{ X\\leq b}-P{ X\\leq a}=F(b)-F(a)$ 单调不减 $F(-\\infty )=lim_{x\\rightarrow -\\infty }F(x)=0$ $F(+\\infty )=lim_{x\\rightarrow +\\infty }F(x)=1$ F(x)是右连续的，即$F(x^{+})=F(x)$ 2离散型随机变量两点分布 二项分布，伯努利试验记作$X ~B(n,p) X在(n+1)p处取得最大值$ 几何分布 泊松分布： P\\{ X=k\\}=\\frac{\\lambda ^ke^{-\\lambda}}{k!}\\\\ 其中，\\lambda为服从参数,记作X P(\\lambda)3连续型随机变量均匀分布 f(x)=\\left\\{ \\begin{array}{lr} \\frac{1}{b-a},a0\\\\ 0&x\\leq0\\\\ \\end{array} \\right.\\\\其中，\\lambda>0是常数，称为X服从参数为\\lambda的指数分布\\\\正态分布 $N(\\mu ,\\sigma^2)$有概率密度函数 f(x)=\\frac{1}{\\sqrt{2\\pi }\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}},-\\infty","categories":[{"name":"随机数学","slug":"随机数学","permalink":"http://yoursite.com/categories/随机数学/"}],"tags":[]},{"title":"Java核心技术i","slug":"Java核心技术i","date":"2020-04-02T14:56:52.000Z","updated":"2020-04-08T07:35:35.544Z","comments":true,"path":"2020/04/02/ Java核心技术i/","link":"","permalink":"http://yoursite.com/2020/04/02/ Java核心技术i/","excerpt":"","text":"$\\lambda 表达式形式：参数，箭头 (-&gt;) 以及一个表达式$ 无需指定$\\lambda 表达式的返回类型$ 只有当$\\lambda$表达式的体只调用一个方法而不做其他操作时，才能把$\\lambda$表达式重写为方法。page248 $\\lambda$就是闭包 $\\lambda$捕获的变量是事实最终变量$effectively\\ final$ $exception\\ handing ,异常处理 \\ throw\\ 抛出\\ exception\\ handler\\ 异常处理器$ $只需要声明\\ IOException,检查型(checked)异常$ $i.找到一个合适的异常类\\ ii.创建这个类的一个对象\\ iii.将对象抛出$ 集合迭代器·Iterator接口123456public interface Interator&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemain(Consumer&lt;? super E&gt; action);&#125; CollectionQueue实现方式 循环数组 链表 Map","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"计算机系统结构","slug":"计算机系统结构","date":"2020-03-31T06:20:46.000Z","updated":"2020-04-08T10:28:16.140Z","comments":true,"path":"2020/03/31/ 计算机系统结构/","link":"","permalink":"http://yoursite.com/2020/03/31/ 计算机系统结构/","excerpt":"","text":"1系统结构，组成，实现 计算机系统结构：计算机系统的软，硬件的界面。 计算机组成：计算机系统结构的逻辑实现。 计算机实现：计算机组成的物理实现 换句话来说，我们设计计算机的时间轴为：$系统结构\\longrightarrow 组成\\longrightarrow 实现$ $t_{cpu}:$执行一段程序所用的CPU时间。 $IC:$该段程序的指令条数，取决于指令集结构 和编译技术。 $CPI,Cycle \\ Per \\ Instruction:$平均每一条指令所需要的时钟周期，取决于组成和指令集结构 $T:$时钟周期，取决于实现 和组成 3 流水线以静态，线性，顺序流水线为例 $吞吐率\\ ThroughPut\\ TP=\\frac{n}{T_k}=\\frac{任务数量}{运行时间}=\\frac{n}{(k+n-1)\\Delta t}$ $加速比\\ Speedup\\ S=\\frac{T_s}{T_k}=\\frac{顺序执行时间}{运行时间}=\\frac{nk}{k+m-1}$ $效率\\ Efficiency\\ E=\\frac{n\\Delta t}{T_k}=\\frac{设备实际使用时间}{运行时间*设备数目}=\\frac{n}{k+n-1}$ dependence 相关，两条指令之间存在某种依赖关系 真数据相关，data dependence，$①指令j使用指令i产生的结果;②指令j与指令k数据相关，指令k又与指令i数据相关$ 名相关，name dependence，如果两条指令使用相同的名，但是它们之间没有数据流动 $anti-dependence,反相关，指令j写的名与指令i读的名相同；\\ output\\ dependence,输出相关,指令j与指令i写的名相同。 $ 控制相关，control dependence ，有分支指令引起的相关。 流水线冲突 pipline hazards，由于相关的存在，使得下一条指令不能再指定的时钟周期执行 结构冲突 数据冲突，相关的指令靠得足够近。 $RAM,Read \\ After \\ Write ,写后读冲突，真数据相关$ $WAW,Write \\ After \\ Write ，写后写冲突，输出相关，在五段流水线(MIPS)中不会发生$ $WAR,Write \\ After \\ Read,读后写冲突.反相关$ 仅发生在这样的情况：有些指令的写操作被提前了，有些操作的读操作被滞后了，即指令被重新排序了,在五段流水线(MIPS)中不会发生 4 指令级并行​ ILP,Instruction-Level\\ Parallelism,指令级并行\\left\\{ \\begin{array}{lr} 基于硬件（代码执行中）的动态开发方法\\\\ 基于软件（代码执行前）的静态开发方法 \\end{array}\\right.\\\\$CPI{实际流水线}=CPI{理想}+停顿{结构冲突}+停顿{数据冲突}+停顿_{控制冲突}$ $IPC,Instructions \\ Per\\ Cycle,每个时钟周期完成的指令条数$ $CDB,Common\\ Data \\ Bus,公共数据总线$ $IS,Issue,流出阶段：指令译码，检查是否存在结构冲突。$ $RO,Read\\ Operands,读操作数：检测数据冲突$ $BHT,Branch\\ History\\ Table\\ ,Branch\\ Predicition\\ Buffer,分支历史表，分支预测缓冲器\\是最简单的动态分支预测方法$ $BTB,Branch\\ Target\\ Buffer,分支目标缓冲器，也称分支目标Cache$ $branch\\ folding,分支折叠$ $speculation,前瞻执行$ $ROB,ReOrder\\ Buffer，再定序缓冲器，为了在猜错的情况下能够恢复现场$ $Tomasulo算法$ $基于硬件的前瞻算法，顺序流出，乱序执行，顺序确认$ EG$e.g.1$ 解 不妨设加速比为S 那么有 S=\\frac {time_前}{time_后}=\\frac{11.1\\%*2+33.3\\%*20+38.9\\%*10+16.7\\%*4}{11.1\\%*1+33.3\\%*15+38.9\\%*3+16.7\\%*1}=\\frac{11.44}{6.44}=1.77$e.g.2$ 考虑条件分支指令的两种不同设计方法：（1）CPUA：通过比较指令设置条件码，然后测试条件码进行分支。（2）CPUB：在分支指令中包括比较过程。在这两种CPU中，条件分支指令都占用2个时钟周期，而所有其他指令占用1个时钟周期。对于CPUA，执行的指令中分支指令占20%；由于每条分支指令之前都需要有比较指令，因此比较指令也占20%。不妨假设其他指令条数相同。由于CPUA在分支时不需要比较，因此CPUB的时钟周期时间是CPUA的1.25倍。问：哪一个CPU更快？如果CPUB的时钟周期时间只是CPUA的1.1倍，哪一个CPU更快呢？ $t_{cpu}=ICCPIT$ 那么有 t_{cpuA}=IC*(0.4*2+0.6*1)*T \\\\ t_{cpuB}=IC*(2/8*2+6/8*1)*1.25T最后即可得答案。","categories":[{"name":"计算机系统结构","slug":"计算机系统结构","permalink":"http://yoursite.com/categories/计算机系统结构/"}],"tags":[]},{"title":"操作系统","slug":"操作系统","date":"2020-03-31T06:16:46.000Z","updated":"2020-04-07T15:16:44.768Z","comments":true,"path":"2020/03/31/ 操作系统/","link":"","permalink":"http://yoursite.com/2020/03/31/ 操作系统/","excerpt":"","text":"中断1 中断，在程序运行过程中出现某种紧急事件，必须中止当前正在运行的程序，转去处理此事件，然后再恢复原来运行的程序。有$\\begin{Bmatrix} 强迫性中断\\ 自愿性中断\\ \\end {Bmatrix}$。 2 中断系统，中断装置+中断处理程序 3 中断装置，识别中断源$\\Longrightarrow$ 保存现场$(运行的物理环境：地址寄存器，通用寄存器，浮点寄存器，SP，PSW，PC，文件表)\\Longrightarrow $引出中断程序 1 进程互斥；进程同步；进程饥饿；进程死机；进程饿死 2 $吞吐量=\\frac{任务数量}{处理时间}$ 3 $PCB,process\\ control\\ block $，进程控制块，是标志进程存在的数据结构，其中包含系统对进程进行管理所需要的全部信息。 4 $TCB,thread\\ control\\ block$，线程控制块，是标志线程存在的数据结构，其中包含系统对线程进行管理所需要的全部信息。 5 $PSW,program\\ status\\ word$，程序状态字，表示当前程序的运行环境，状态 6 $JCB\\ ,Job\\ Control\\ Block$，作业控制块，是标志作业存在的数据结构，其中包含系统对作业进行管理所需要的全部信息。 7 $PC$，指令计数。 处理及调度算法 1 $FCFS,first\\ come\\ first\\ service $，先到先服务。 。。。 程序并发执行的条件 满足$Bernstein 条件$ $race\\ condition,竞争条件，多个进程在访问变量时，因实际交叉次序不同而导致执行结果不同$ Peterson互斥算法 $bus \\ request\\ protocol,总线请求协议$","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[]},{"title":"state machine&Euclidean Alg","slug":"离散数学第4讲","date":"2020-03-21T08:09:17.000Z","updated":"2020-03-23T14:34:27.505Z","comments":true,"path":"2020/03/21/ 离散数学第4讲/","link":"","permalink":"http://yoursite.com/2020/03/21/ 离散数学第4讲/","excerpt":"","text":"state machine 水壶问题 有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: 12输入: x = 3, y = 5, z = 4输出: True 示例 2: 12输入: x = 2, y = 6, z = 5输出: False 我们不妨将每一次两个水壶中所拥有的水的体积作为该时刻的状态。 状态表示为$P(n)=(a,b)$。 其中，$a$表示容量为$x$升的水壶所有的水，$b$表示容量为$y$升的水壶所有的水。 状态转移有装满一个水壶；清空一个水壶；从一个水壶向另外一个水壶倒水，知道装满或者倒空。 最终状态必然有$a_0+b_0=z$ 1结论：ans=GCD(x,y)|z 容易推理出若$m|a_0,m|b_0,则有m|z$ 那么我们需要寻找这样的状态$(a_0,b_0)$ 证明：m|x且m|y\\Longrightarrow m|a且m|b不妨设$m|x且m|y$。 显然$P(0)=(0,0),任意m|0符合(1)式$ 设$P(n)=(a,b),m|a且m|b$ 证明$P(n+1)=(a_1,b_1),m|a_1,m|b_1$ 根据状态转移有 P(n+1)=\\left\\{ \\begin{array}{lr} (a,0)\\\\ (0,b)\\\\ (x,b)\\\\ (a,y)\\\\ (a-(y-b),y)\\\\ (0,a+b)\\\\ (x,b-(x-a))\\\\ (a+b,0)\\\\ \\end{array} \\right.只证$(2)式$的每一个数字都能被$m$整除，答案是显然的。 那么我们就可以得到最终的状态$(a_0,b_0)必然有m|a_0,m|b_0,那么有m|z$。 为了保证每一个$m$的取值都能满足以上推论。 必然需要满足$GCD(x,y)|z$ 所以有$z\\%GCD(x,y)==0$ Euclidean Alg GCD(a,b)=GCD(Remainder(b,a),a)\\\\ 其中，Remainder(b,a)=b-q*a=b\\%a\\geq0\\ \\ \\ \\ \\ a,b,q均为正整数证明$m|a且m|b\\Longrightarrow m|Remainder(b,a)且m|a$ 答案是显然的。 现只需证明$m|Remainder(b,a) 且m|a\\Longrightarrow m|b$ 已知b-qa=k_1m,a=k_2m\\\\ 有b=(k_1+k_2q)m\\\\ 有m|b1234567891011121314151617181920class Solution &#123;public: int GCD(int a,int b)&#123; if(a==0||b==0) return max(a,b); int c; while(b%a!=0)&#123; c=b%a; b=a; a=c; &#125; return a; &#125; bool canMeasureWater(int x, int y, int z) &#123; if(z==0) return true; if(z&gt;x+y)return false; int m=GCD(x,y); if(z%m==0) return true; return false; &#125;&#125;;","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://yoursite.com/categories/离散数学/"}],"tags":[]},{"title":"算法设计与分析","slug":"算法设计及分析","date":"2020-02-13T14:42:33.000Z","updated":"2020-04-08T10:25:22.854Z","comments":true,"path":"2020/02/13/ 算法设计及分析/","link":"","permalink":"http://yoursite.com/2020/02/13/ 算法设计及分析/","excerpt":"","text":"2证明$f(n)=O(g(n))$，有 \\exists c,n_0,对于\\forall n\\geq n_0 有 f(n)\\leq c*g(n)即$g(n)$时$f(n)$的渐近上限。 证明$f(n)=\\Omega (g(n))$，有 \\exists c,n_0,对于\\forall n\\geq n_0 有 f(n)\\geq c*g(n)即$g(n)$时$f(n)$的渐近下限。 若同时满足$(1),(2)$ 则有 f(n)=\\Theta (g(n)),且g(n)=\\theta (f(n))3 贪心方法1 一般方法 n个输入,可行解为n个输入的子集\\\\ 约束条件\\Longrightarrow 可行解 根据目标函数\\Longrightarrow最优解核心：选取能产生最优解的量度标准2背包","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://yoursite.com/categories/算法设计与分析/"}],"tags":[]},{"title":"Warshall&All_componet","slug":"Warshall","date":"2019-11-18T13:44:59.000Z","updated":"2020-03-23T14:18:30.383Z","comments":true,"path":"2019/11/18/ Warshall/","link":"","permalink":"http://yoursite.com/2019/11/18/ Warshall/","excerpt":"","text":"Warshall &amp; All_componet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;struct Edge&#123; int VerAdj; int cost; Edge*link;&#125;;struct Vertex&#123; int VerName; Edge*adjacent;&#125;;struct node&#123; int VerName; node*link;&#125;;int graphsize;int edgesize;const int MAX=1e2;void Init(Vertex S[])&#123; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); int i,j,k; int from,to,cost; for(i=0;i&lt;graphsize;i++) &#123; S[i].adjacent=NULL; S[i].VerName=i; &#125; for(i=1;i&lt;=edgesize;i++) &#123; scanf(\"%d%d\",&amp;from,&amp;to); Edge*p=new Edge; p-&gt;cost=0; p-&gt;link=NULL; p-&gt;VerAdj=to; Edge*q=S[from].adjacent; if(q==NULL) &#123; S[from].adjacent=p; &#125; else &#123; if(q-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; if(q-&gt;VerAdj&gt;p-&gt;VerAdj) &#123; p-&gt;link=q; S[from].adjacent=p; &#125; else &#123; if(q-&gt;cost&gt;p-&gt;cost) &#123; delete q; S[from].adjacent=p; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; while(q-&gt;link!=NULL) &#123; if(q-&gt;link-&gt;VerAdj&gt;=p-&gt;VerAdj) &#123; break; &#125; q=q-&gt;link; &#125; if(q-&gt;link==NULL) &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; else &#123; if(q-&gt;link-&gt;VerAdj==p-&gt;VerAdj) &#123; if(q-&gt;link-&gt;cost&gt;p-&gt;cost) &#123; Edge*q0=q-&gt;link; p-&gt;link=q0-&gt;link; q-&gt;link=p; delete q0; &#125; else delete p; &#125; else &#123; p-&gt;link=q-&gt;link; q-&gt;link=p; &#125; &#125; &#125; &#125; &#125;&#125;void Warshall(Vertex S[],int WSM[MAX][MAX])&#123; int i,j,k; Edge*p; int a; for(i=0;i&lt;graphsize;i++) &#123; for(j=0;j&lt;graphsize;j++) &#123; if(i==j) WSM[i][j]=1; else &#123; WSM[i][j]=0; WSM[j][i]=0; &#125; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; p=S[i].adjacent; a=S[i].VerName; while(p!=NULL) &#123; WSM[a][p-&gt;VerAdj]=1; p=p-&gt;link; &#125; &#125; for(k=0;k&lt;graphsize;k++) &#123; for(i=0;i&lt;graphsize;i++) &#123; if(WSM[i][k]==1) &#123; for(j=0;j&lt;graphsize;j++) &#123; WSM[i][j]=(WSM[i][j])||(WSM[k][j]); &#125; &#125; &#125; &#125;&#125;void All_componet(Vertex S[])&#123; int WSM[MAX][MAX]; int markedList[MAX]; int i,j,k; for(i=0;i&lt;graphsize;i++) markedList[i]=0; Warshall(S,WSM); int t=0; int v; for(v=0;v&lt;graphsize;v++) &#123; if(markedList[v]==0) &#123; markedList[v]=1; node*scList=new node; scList-&gt;VerName=v; scList-&gt;link=NULL; node*q=scList; for(i=0;i&lt;graphsize;i++) &#123; if(i!=v&amp;&amp;WSM[v][i]==1&amp;&amp;WSM[i][v]==1) &#123; markedList[i]=1; node*p=new node; p-&gt;VerName=i; p-&gt;link=NULL; q-&gt;link=p; q=q-&gt;link; &#125; &#125; printf(\"t:%d\\n\",t); t=t+1; q=scList; node*q0; while(q!=NULL) &#123; printf(\"%d \",q-&gt;VerName); q0=q; q=q-&gt;link; delete q0; &#125; cout&lt;&lt;endl; &#125; &#125;&#125;/*6 70 10 31 22 03 44 55 4*/int main()&#123; Vertex S[MAX]; Init(S); All_componet(S); return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Kmeans","slug":"Kmeans","date":"2019-11-13T14:42:33.000Z","updated":"2020-03-23T14:17:27.839Z","comments":true,"path":"2019/11/13/ Kmeans/","link":"","permalink":"http://yoursite.com/2019/11/13/ Kmeans/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#基于聚类算法(kmeans)的图像分割'''导入所需要的模块：1.用于处理二维矩阵的数学库2.随机生成数的模块3.用于将图片(JPG)转换为矩阵以及把矩阵转换为图片(JPG)的模块'''import numpy as npfrom random import randomfrom PIL import Image# 导入数据，file_path是图像的存储位置# 返回值def load_data(file_path): f = open(file_path, \"rb\") # 以二进制的方式打开图像文件 data = [] im = Image.open(f) # 导入图片 m, n = im.size # 得到图片的大小 print (m), (n) for i in range(m): for j in range(n): tmp = [] x, y, z = im.getpixel((i, j)) tmp.append(x / 256.0) tmp.append(y / 256.0) tmp.append(z / 256.0) data.append(tmp) f.close() return np.mat(data)def distance(vecA, vecB): '''计算vecA与vecB之间的欧式距离的平方 input: vecA(mat)A点坐标 vecB(mat)B点坐标 output: dist[0, 0](float)A点与B点距离的平方 ''' dist = (vecA - vecB) * (vecA - vecB).T return dist[0, 0]def randCent(data, k): '''随机初始化聚类中心 input: data(mat):训练数据 k(int):类别个数 output: centroids(mat):聚类中心 ''' n = np.shape(data)[1] # 属性的个数 centroids = np.mat(np.zeros((k, n))) # 初始化k个聚类中心 for j in range(n): # 初始化聚类中心每一维的坐标 minJ = np.min(data[:, j]) rangeJ = np.max(data[:, j]) - minJ # 在最大值和最小值之间随机初始化 centroids[:, j] = minJ * np.mat(np.ones((k , 1))) + np.random.rand(k, 1) * rangeJ return centroidsdef kmeans(data, k, centroids): '''根据KMeans算法求解聚类中心 input: data(mat):训练数据 k(int):类别个数 centroids(mat):随机初始化的聚类中心 output: centroids(mat):训练完成的聚类中心 subCenter(mat):每一个样本所属的类别 ''' m, n = np.shape(data) # m：样本的个数，n：特征的维度 subCenter = np.mat(np.zeros((m, 2))) # 初始化每一个样本所属的类别 change = True # 判断是否需要重新计算聚类中心 while change == True: change = False # 重置 for i in range(m): minDist = np.inf # 设置样本与聚类中心之间的最小的距离，初始值为争取穷 minIndex = 0 # 所属的类别 for j in range(k): # 计算i和每个聚类中心之间的距离 dist = distance(data[i, ], centroids[j, ]) if dist &lt; minDist: minDist = dist minIndex = j # 判断是否需要改变 if subCenter[i, 0] != minIndex: # 需要改变 change = True subCenter[i, ] = np.mat([minIndex, minDist]) # 重新计算聚类中心 for j in range(k): sum_all = np.mat(np.zeros((1, n))) r = 0 # 每个类别中的样本的个数 for i in range(m): if subCenter[i, 0] == j: # 计算第j个类别 sum_all += data[i, ] r += 1 for z in range(n): try: centroids[j, z] = sum_all[0, z] / r print (r) except: print (\" r is zero\") return subCenterdef save_result(file_name, source): '''保存source中的结果到file_name文件中 input: file_name(string):文件名 source(mat):需要保存的数据 output: ''' m, n = np.shape(source) f = open(file_name, \"w\") for i in range(m): tmp = [] for j in range(n): tmp.append(str(source[i, j])) f.write(\"\\t\".join(tmp) + \"\\n\") f.close()# --------------------------------------------------FLOAT_MAX = 1e100 # 设置一个较大的值作为初始化的最小的距离def nearest(point, cluster_centers): '''计算point和cluster_centers之间的最小距离 input: point(mat):当前的样本点 cluster_centers(mat):当前已经初始化的聚类中心 output: min_dist(float):点point和当前的聚类中心之间的最短距离 ''' min_dist = FLOAT_MAX m = np.shape(cluster_centers)[0] # 当前已经初始化的聚类中心的个数 for i in range(m): # 计算point与每个聚类中心之间的距离 d = distance(point, cluster_centers[i, ]) # 选择最短距离 if min_dist &gt; d: min_dist = d return min_distdef get_centroids(points, k): '''KMeans++的初始化聚类中心的方法 input: points(mat):样本 k(int):聚类中心的个数 output: cluster_centers(mat):初始化后的聚类中心 ''' m, n = np.shape(points) cluster_centers = np.mat(np.zeros((k , n))) # 1、随机选择一个样本点为第一个聚类中心 index = np.random.randint(0, m) cluster_centers[0, ] = np.copy(points[index, ]) # 2、初始化一个距离的序列 d = [0.0 for _ in range(m)] print (\"\\t初始化一个距离序列\") print (\" k=\",k) for i in range(1, k): print(i) sum_all = 0 for j in range(m): # 3、对每一个样本找到最近的聚类中心点 d[j] = nearest(points[j, ], cluster_centers[0:i, ]) # 4、将所有的最短距离相加 sum_all += d[j] # 5、取得sum_all之间的随机值 sum_all *= random() # 6、获得距离最远的样本点作为聚类中心点 for j, di in enumerate(d): sum_all -= di if sum_all &gt; 0: continue cluster_centers[i] = np.copy(points[j, ]) break return cluster_centersdef run_kmeanspp(data, k): # 1、KMeans++的聚类中心初始化方法 print (\"\\t---------- 1.K-Means++ generate centers ------------\") centroids = get_centroids(data, k) # 2、聚类计算 print (\"\\t---------- 2.kmeans ------------\") subCenter = kmeans(data, k, centroids) # 3、保存所属的类别文件 print (\"\\t---------- 3.save subCenter ------------\") save_result(\"sub_pp\", subCenter) # 4、保存聚类中心 print (\"\\t---------- 4.save centroids ------------\") save_result(\"center_pp\", centroids)#--------------------------------------------------k = 4 #聚类中心的个数# 1、导入数据print (\"---------- 1.load data ------------\")data = load_data(\"Pic_B.jpg\")# 2、利用kMeans++聚类print (\"---------- 2.run kmeans++ ------------\")run_kmeanspp(data, k)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/categories/机器学习/"}],"tags":[]},{"title":"Prim","slug":"Prim","date":"2019-11-13T14:42:33.000Z","updated":"2020-03-23T14:20:26.806Z","comments":true,"path":"2019/11/13/ Prim/","link":"","permalink":"http://yoursite.com/2019/11/13/ Prim/","excerpt":"","text":"Prim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int cost; int head; int tail;&#125;;const int MAX=1e6;edge E[MAX];edge TE[MAX];int graphsize;int edgesize;struct LV&#123; int Lowcost; int Vex;&#125;;LV closedge[MAX];int Edge[5010][5010];//稠密图，使用邻接矩阵void Prim()&#123; int i; scanf(\"%d%d\",&amp;graphsize,&amp;edgesize); for(i=0;i&lt;graphsize;i++) &#123; for(int j=0;j&lt;graphsize;j++) &#123; Edge[i][j]=1e9; Edge[j][i]=1e9; &#125; &#125; for(i=0;i&lt;edgesize;i++) &#123; scanf(\"%d%d%d\",&amp;E[i].head,&amp;E[i].tail,&amp;E[i].cost); //防止重边 if(E[i].cost&lt;Edge[E[i].head-1][E[i].tail-1]) &#123; Edge[E[i].head-1][E[i].tail-1]=E[i].cost; Edge[E[i].tail-1][E[i].head-1]=E[i].cost; &#125; &#125; for(i=0;i&lt;graphsize;i++) &#123; closedge[i].Lowcost=Edge[0][i]; closedge[i].Vex=0; &#125; closedge[0].Vex=-1; int count=0; int ans=0; for(i=1;i&lt;graphsize;i++) &#123; int Min=1e9+1; int v=0; for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;closedge[j].Lowcost&lt;Min) &#123; v=j; Min=closedge[j].Lowcost; &#125; &#125; if(v!=0) &#123; ans=ans+closedge[v].Lowcost; TE[count].head=closedge[v].Vex; TE[count].tail=v; TE[count].cost=closedge[v].Lowcost; count++; closedge[v].Lowcost=0; closedge[v].Vex=-1; //进行一些操作使得它们保持最小 for(int j=0;j&lt;graphsize;j++) &#123; if(closedge[j].Vex!=-1&amp;&amp;Edge[v][j]&lt;closedge[j].Lowcost) &#123; closedge[j].Lowcost=Edge[v][j]; closedge[j].Vex=v; &#125; &#125; &#125; &#125; printf(\"%d\",ans);&#125;//prim/*6 100 1 10 2 40 3 71 2 42 3 21 5 22 5 52 4 33 4 64 5 3*/int main()&#123; Prim();&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"BinTree","slug":"BinTree","date":"2019-10-27T04:28:29.000Z","updated":"2020-03-31T08:02:36.755Z","comments":true,"path":"2019/10/27/ BinTree/","link":"","permalink":"http://yoursite.com/2019/10/27/ BinTree/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#include&lt;stack&gt;#include&lt;utility&gt;#include&lt;queue&gt;using namespace std;template&lt;class T&gt;class BinTreeNode&#123;public: BinTreeNode&lt;T&gt;*left; BinTreeNode&lt;T&gt;*right; T data;public: BinTreeNode(const T&amp;item,BinTreeNode&lt;T&gt;*L=NULL,BinTreeNode&lt;T&gt;*R=NULL):data(item),left(L),right(R)&#123;&#125; BinTreeNode&lt;T&gt;*GetLeft()const &#123; return left; &#125; BinTreeNode&lt;T&gt;*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode&lt;T&gt;*L) &#123; left=L; &#125; void SetRight(BinTreeNode&lt;T&gt;*R) &#123; right=R; &#125; T&amp; GetData()&#123;return data;&#125; void SetData(const T&amp;item)&#123;data=item;&#125;&#125;;template&lt;class T&gt;class BinTree&#123;public: BinTreeNode&lt;T&gt;*root; T stop;public: BinTree(BinTreeNode&lt;T&gt;*t=NULL):root(t)&#123;&#125; void PreOrder(BinTreeNode&lt;T&gt;*t)const; void InOrder(BinTreeNode&lt;T&gt;*t)const; void PostOrder(BinTreeNode&lt;T&gt;*t)const; void LevelOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPreOrder(BinTreeNode&lt;T&gt;*t)const; void NorecInOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPostOrder(BinTreeNode&lt;T&gt;*t)const; void CreateBinTree(T tostop); BinTreeNode&lt;T&gt;* Create(); BinTreeNode&lt;T&gt;*CopyTree(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p); BinTreeNode&lt;T&gt;*Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const; void InsertLeft(T item,BinTreeNode&lt;T&gt;*t); void InsertRight(T item,BinTreeNode&lt;T&gt;*s); void DelSubtree(BinTreeNode&lt;T&gt;*t); void Del(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*GetRoot()&#123;return root;&#125; void SetRoot(BinTreeNode&lt;T&gt;*t)&#123;root=t;&#125; T getStop()&#123;return stop;&#125; void SetStop(T tostop)&#123;stop=tostop;&#125; bool IsEmpty()&#123;return root==NULL;&#125;&#125;;template&lt;class T&gt;void BinTree&lt;T&gt;::PreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; PreOrder(t-&gt;GetLeft()); PreOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; InOrder(t-&gt;GetLeft()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; InOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::PostOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; PostOrder(t-&gt;GetLeft()); PostOrder(t-&gt;GetRight()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecInOrder(BinTreeNode&lt;T&gt;*t)const&#123; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; while(t!=NULL||S.empty()==false) &#123; while(t!=NULL) &#123; S.push(t); t=t-&gt;GetLeft(); &#125; if(S.empty()==true)return ; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; t=t-&gt;GetRight(); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t==NULL)return ; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; S.push(t); while(S.empty()==false) &#123; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; if(t-&gt;GetRight()!=NULL) S.push(t-&gt;GetRight()); if(t-&gt;GetLeft()!=NULL) S.push(t-&gt;GetLeft()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPostOrder(BinTreeNode&lt;T&gt;*t)const&#123; pair&lt;BinTreeNode&lt;T&gt;*,int&gt; p; if(t==NULL)return ; p=make_pair(t,0); stack&lt;pair&lt;BinTreeNode&lt;T&gt;*,int&gt;&gt;S; S.push(p); while(S.empty()==false) &#123; p=S.top(); S.pop(); if(p.second==0) &#123; p.second++; S.push(p); if((p.first)-&gt;GetLeft()!=NULL) &#123; p.first=(p.first)-&gt;GetLeft(); p.second=0; S.push(p); &#125; &#125; else &#123; if(p.second==1) &#123; p.second++; S.push(p); if((p.first)-&gt;GetRight()!=NULL) &#123; p.first=(p.first)-&gt;GetRight(); p.second=0; S.push(p); &#125; &#125; else &#123; cout&lt;&lt;p.first-&gt;GetData()&lt;&lt;endl; &#125; &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::LevelOrder(BinTreeNode&lt;T&gt;*t)const&#123; queue&lt;BinTreeNode&lt;T&gt;*&gt;Q; if(t==NULL)return ; BinTreeNode&lt;T&gt; *p=t; Q.push(p); while(Q.empty()==false) &#123; p=Q.front(); Q.pop(); cout&lt;&lt;p-&gt;GetData()&lt;&lt;endl; if(p-&gt;GetLeft()!=NULL) &#123; Q.push(p-&gt;GetLeft()); &#125; if(p-&gt;GetRight()!=NULL) &#123; Q.push(p-&gt;GetRight()); &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::CreateBinTree(T tostop)&#123; SetStop(tostop); root=Create();&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;* BinTree&lt;T&gt;::Create()&#123; BinTreeNode&lt;T&gt;*t,*t1,*t2; T item; cin&gt;&gt;item; if(item==stop) &#123; t=NULL; return t; &#125; t=new BinTreeNode&lt;T&gt;(item,NULL,NULL); t1=Create(); t-&gt;SetLeft(t1); t2=Create(); t-&gt;SetRight(t2); return t;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::CopyTree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return NULL; BinTreeNode&lt;T&gt;*L=nullptr,*R=nullptr; if(t-&gt;GetLeft()!=NULL) &#123; L=CopyTree(t-&gt;GetLeft()); &#125; if(t-&gt;GetRight()!=NULL) &#123; R=CopyTree(t-&gt;GetRight()); &#125; BinTreeNode&lt;T&gt;*nod=new BinTreeNode&lt;T&gt;(t-&gt;GetData(),L,R); return nod;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p)&#123; BinTreeNode&lt;T&gt;*q; if(t==NULL||p==NULL) return NULL; if(t-&gt;GetLeft()==p||t-&gt;GetRight()==p) return t; q=Father(t-&gt;GetLeft(),p); if(q!=NULL)return q; return Father(t-&gt;GetRight(),p);&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const&#123; BinTreeNode&lt;T&gt;*p; if(t==NULL)return NULL; if(t-&gt;data==item) return t; p=Find(t-&gt;GetLeft(),item); if(p!=NULL) return p; p=Find(t-&gt;GetRight(),item); return p;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::Del(BinTreeNode&lt;T&gt;*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertLeft(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetLeft(s-&gt;GetLeft()); p-&gt;SetRight(NULL); s-&gt;SetLeft(p);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertRight(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetRight(s-&gt;GetRight()); s-&gt;SetRight(p); p-&gt;SetLeft(NULL);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::DelSubtree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return ; if(t==root) &#123; Del(t); root=NULL; return ; &#125; BinTreeNode&lt;T&gt;*f=Father(root,t); if(f!=nullptr) &#123; if(f-&gt;GetLeft()==t) f-&gt;SetLeft(NULL); if(f-&gt;GetRight()==t)f-&gt;SetRight((NULL)); &#125; Del(t);&#125;int main()&#123; BinTree&lt;int&gt; t; t.CreateBinTree(-1); BinTreeNode&lt;int&gt;*t2=t.Find(t.root,4); t.InsertRight(6,t2); t.InOrder(t.root); return 0;&#125;/*1 2 4 -1 5 -1 -1 -1 3 -1 -1*/","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"EulerSieve","slug":"EulerSieve","date":"2019-10-21T06:16:46.000Z","updated":"2020-03-31T06:23:13.631Z","comments":true,"path":"2019/10/21/ EulerSieve/","link":"","permalink":"http://yoursite.com/2019/10/21/ EulerSieve/","excerpt":"","text":"EulerSieve时间复杂度​ O(n) 实现12345678910111213141516171819202122const int maxn = 10100; int prime[maxn], pNum = 0; // prime记录素数，pNum记录素数个数 //保存的值为0~pNum-1bool p[maxn] = &#123;false&#125;; // p记录当前数是否被筛去void EulerSieve(int n) // 查找记录2-n的素数&#123; int j; for (int i = 2; i &lt;= n; i++) &#123; if (p[i] == false) // 如果未被筛过，则为素数 prime[pNum++] = i; for (j = 0; j &lt; pNum; j++) &#123; if (i * prime[j] &gt; n) // 当要标记的合数超出范围时跳出 break; p[i * prime[j]] = true; // 将已经记录的素数的倍数进行标记 if (i % prime[j] == 0) //关键步骤 break; &#125; &#125;&#125; 理解时间复杂度证明","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"qpow","slug":"qpow","date":"2019-10-20T17:18:42.000Z","updated":"2020-03-23T14:18:39.223Z","comments":true,"path":"2019/10/21/ qpow/","link":"","permalink":"http://yoursite.com/2019/10/21/ qpow/","excerpt":"","text":"快速幂假设​ 求x^n的值 时间复杂度​ O(log n) 解释​ 通过加大底数的权重来使得乘法次数更少 ​ 1.假设n为奇数：x^n=x*x^(n-1) 则将x计入结果 ​ 2.假设n为偶数：x^n=x^(n/2)*x^(n/2) 则将x的权重变为x^2 实现代码1234567891011121314/*快速幂运算 log 2 n*/typedef long long LL;LL qpow(LL a, LL n, LL mod)&#123; LL result = 1; while (n!=0) &#123; if (n &amp; 1) result = (result * a) % mod;//计入结果 a = (a * a) % mod;//权重变大 n &gt;&gt;= 1;//n=n/2; &#125; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Kruskal","slug":"Kruskal","date":"2019-10-10T14:56:52.000Z","updated":"2020-03-23T14:14:19.299Z","comments":true,"path":"2019/10/10/ Kruskal/","link":"","permalink":"http://yoursite.com/2019/10/10/ Kruskal/","excerpt":"","text":"Kruskal Kruskal总是维护无向连通图的最小生成森林 最终得到该图的最小生成树 由来​ Kruskal算法是一种用来查找最小生成树的贪心算法，由Joseph Kruskal在1956年发表。 假设​ 有n个点m条无向边的图，且已知每一条边(x,y,z)，代表点x和点y之间有哦权值为z的无向边。 时间复杂度​ O(m log m) 预备知识​ 并查集 先挖坑 解释​ 在遍历所给无向连通图的过程中，kruskal 总是维护着最小生成森林。 ​ 最终得到最小生成树。 ​ 有以下步骤： ​ 1.初始化并查集，每一个点各自构成一个集合 ​ 2.对边集S进行从小到大排序 ​ 3.从S中取出一条边（注意：现在是从S中从小到大取出，判断这条边的两个端点是否属于同一个集合（使用并查集维护），不是则将端点x和端点y使用并查集combine起来。且将边加入最小生成森林。 ​ 4.不断重复S直至访问完所有边 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//以边集来保存图，假设有m条边//时间复杂度为mlogmconst int MAX=11010;struct edge&#123; int x; int y; int z;&#125;;//代表x和y两点之间有路且权值为zedge S[MAX];int Father[MAX];int n,m;int ans;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; return a.z&lt;b.z;&#125;inline void Init()&#123; int i; scanf(\"%d%d\",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;S[i].x,&amp;S[i].y,&amp;S[i].z);&#125;//并查集找父亲inline int Find(int x)&#123; while(x!=Father[x]) x=Father[x]; return x; &#125;//combineinline void combine(int x,int y)&#123; Father[x]=y;&#125;inline void Kruskal()&#123; ans=0; int x; int y; int i; for(i=1;i&lt;=n;i++) Father[i]=i; sort(S+1,S+m+1); for(i=1;i&lt;=m;i++) &#123; x=Find(S[i].x); y=Find(S[i].y); if(x!=y) &#123; ans=ans+S[i].z; combine(x,y); &#125; &#125;&#125; 模板题 ​ 回顾学习算法的第四天。戒掉可乐的第四天 ​ Orz ​ Orz","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Manacher","slug":"Manacher","date":"2019-10-09T15:21:21.000Z","updated":"2020-03-23T14:14:43.854Z","comments":true,"path":"2019/10/09/ Manacher/","link":"","permalink":"http://yoursite.com/2019/10/09/ Manacher/","excerpt":"","text":"由来​ 1975年，一个叫Manacher的人发明了一个Manacher算法 作用​ 给定一个字符串S，求出其最大回文子串 时间复杂度 O(n) 原理 对称性 1.字符串处理​ 由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 ​ Example： 原串S a c a b a 转换后的串T # a # c # a # b # a # ​ 为了防止越界，做出以下修改，使得T变成$#a#a#a#b#a#@ 2.Len数组​ 设有字符串T上的位置i，Len[i]表示以i为中心的回文串的半径，和KMP算法相比，这里的数组并非只是预处理的作用，而是在线的处理 ​ 可得： i 1 2 3 4 5 6 7 8 9 10 11 T[i] # a # c # a # b # a # Len[i] 1 2 1 4 1 2 1 4 1 2 1 ​ 如何得到Len数组？ ​ （先挖坑） ​ 主要思想是利用对称性 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int MAX=110000000+10;char S[MAX];//原串char tmp[MAX*2+10];//辅助字符串Tint Len[MAX*2+10];//Len数组int N1;//原串S的长度int N2;//T的长度inline void GetT()&#123; int i,N1=strlen(S); N2=N1*2+1; tmp[0]='$'; for(i=1;i&lt;=2*N1;i=i+2) &#123; tmp[i]='#'; tmp[i+1]=S[i/2]; &#125; tmp[i]='#'; tmp[i+1]='@'; //这样处理的原因是优化后面的操作，比如这样的情况 \"bb\" tmp[i+2]=0;&#125;//得到最大的回文串长度inline int Manacher()&#123; GetLen(); int mx=0; int ans=0; int po=0; int i; for(i=1;i&lt;=N2;i++) &#123; if(mx&gt;i) &#123; //对称性,两者取最小 if((mx-i)&lt;Len[2*po-1]) Len[i]=mx-i; else Len[i]=Len[2*po-1]; &#125; else//第三种情况 Len[i]=1; //不断向外扩展，巧妙 while(tmp[i-Len[i]]==tmp[i+Len[i]]) Len[i]++; //更新值 if(Len[i]+i&gt;mx) &#123; mx=Len[i]+i; po=i; &#125; if(Len[i]&gt;ans) ans=Len[i]; &#125; return ans-1;&#125; 1234567891011121314151617181920212223242526272829public class Solution &#123; public String Manacher(String s)&#123; if(s.length()&lt;2) return s; String t=\"$\"; int i=0,k=0,j=0; for(i=0;i&lt;s.length();i++) t+=\"#\"+s.charAt(i); t+=\"#@\"; int n=t.length(); int [] p=new int[n]; int mx=0; int id=0; int index=0; int maxLength=-1; for(i=1;i&lt;n-1;i++)&#123; p[i]=mx&gt;i ? Math.min(mx-i,p[2*id-i]):1;//第一种情况+第二种情况：第三种情况 while(t.charAt(i+p[i])==t.charAt(i-p[i])) p[i]++;//无论哪一种都可以进行拓展 if(mx&lt;i+p[i]) &#123;//更新右边界以及右边界的中心 mx=i+p[i]; id=i; &#125; if(maxLength&lt;p[i]-1)&#123;//更新最长回文串长度 maxLength=p[i]-1; index=i; &#125; &#125; int start=(index-maxLength)/2; return s.substring(start,start+maxLength); &#125;&#125; ​ https://blog.csdn.net/dyx404514/article/details/42061017","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"KMP","slug":"KMP","date":"2019-10-01T06:25:53.000Z","updated":"2020-03-23T14:19:45.078Z","comments":true,"path":"2019/10/01/ KMP/","link":"","permalink":"http://yoursite.com/2019/10/01/ KMP/","excerpt":"","text":"名字由来​ 由Knuth，Morris,Pratt三人所设计的线性时间字符串匹配算法 时间复杂度​ 设有长度为n的文本串S和长度为m的匹配串P，求匹配串成功匹配文本串字串的首地址 ​ O(n+m) 原理引出​ 对匹配串预处理生成一种失配的映射（或者称为函数，其实称为函数会更加恰当），我们姑且把这个函数成为Next函数。当匹配串对文本串进行匹配时，不妨想象一下，我们在失配的时候对应的失配位置i，都会有相同的移动位移，这样就会产生一个关于i的函数，我们姑且把这样的函数称之为Next(i)，那么这个函数的返回值是什么呢？在不同的博客上它的返回值是不一样的，比如，有些直接返回P下一个需要比较的位置，有些是返回P需要移动的距离（自行脑补一下），有些是返回最大该位置的最大的前后缀一样的字串的字符数，有些的Next函数是经过优化过的，自然返回值和原来的有些不一样。不过它们的使用方法都大同小异。 ​ 我们以返回值为P下一个需要匹配的位置为例。 Next函数的产生​ 先挖坑 1234567891011121314151617181920inline void GetNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; Next[j]=k; &#125; else &#123; k=Next[k]; &#125; &#125;&#125; NextPro数组的产生12345678910111213141516171819202122inline void GetProNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; //只是比Next数组多了一个判断罢了 if(P[j]!=P[k]) Next[j]=k; else Next[j]=Next[k]; &#125; else k=Next[k]; &#125;&#125; KMPSearch代码12345678910111213141516171819202122232425262728const int MAX=10010;char P[MAX];char S[MAX];int Next[MAX];int KmpSearch()&#123; GetProNext();//只需要在这里预处理P的Next数组即可 int sLen=strlen(S); int pLen=strlen(P); int i=0; int j=0; while(i&lt;sLen&amp;&amp;j&lt;pLen) &#123; if(j==-1||S[i]==P[j]) &#123; i++; j++; &#125; else &#123; j=Next[j]; &#125; &#125; if(j==pLen) return i-j; else return -1;&#125; 这个讲解很棒https://blog.csdn.net/v_JULY_v/article/details/7041827","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T08:49:53.178Z","updated":"2019-08-30T08:49:53.178Z","comments":true,"path":"2019/08/30/ hello-world/","link":"","permalink":"http://yoursite.com/2019/08/30/ hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Linux","slug":"Linux","date":"2012-04-04T14:56:52.000Z","updated":"2020-04-08T09:35:50.274Z","comments":true,"path":"2012/04/04/ Linux/","link":"","permalink":"http://yoursite.com/2012/04/04/ Linux/","excerpt":"","text":"viCommand$:wq，保存并退出$ $:w,保存$ $:w \\ filename,另存为filename$ $:wq!,保存强制退出$ $gg,使光标到文件头$ $G,使光标移到文件尾$ $nG,使光标移到第n行$ $ab,缩写，unab，取消缩写$ $宏操作符，map，unmap,取消宏\\ page 98$ $u,撤销最近的操作$ file$command\\ source\\ target$ 创建文件 $mkdir\\ filename,创建目录$ 移除文件 $rm\\ filename,移除文件$ 复制文件 $cp\\ filename1\\ filename2$ $cp\\ filename\\ list$ $cp\\ -r\\ list1(or\\ filename)\\ list2,若list2不存在则创建$ 移动文件 $mv\\ filename\\ list$ $mv\\ filename1\\ filename2,将filename1文件名改为filename2$ 链接文件 寻找文件 $find\\ page125$ 计算字数 $wc\\ filename,显示：行数(-l)，单词数(-w)，字符数(-c)$ 输出重定向，运行用户把进程的输出保存在文件中，然后，用户可以编辑，打印或者作为其他进程的输入。 $command \\ &gt; \\ filename\\ 若有，则覆盖\\command\\ &gt;&gt;\\ filename，若有，则添加到文件结尾$ $cat\\ &gt; filename,创建文件，但输入时无法修改，若有，则覆盖\\cat\\ &gt;&gt;\\ filename,创建文件，但输入时违法修改，若有，则添加到文件结尾$ $cat\\ filename1\\ &gt;\\ filename2\\cat\\ filename1\\ filename2…\\ filenamei\\ &gt;&gt;\\ target$ 显示文件 $head\\ -n\\ filename,显示文件的前n行$ $tail\\ -n\\ filename,显示文件的后n行$ $tail\\ -n +10\\ filename|head -n\\ 10,显示第10-20行$ 查找文件 $find\\ . -name \\ filename,寻找名为filename的文件$ $find\\ . \\ -name\\ filename\\ -exec\\ -cp\\ {}\\ file\\ \\verb|| ;,寻找名为filename的文件并且复制到file文件夹中$ $eg: ls &gt;&gt; a,who &gt;&gt; a,date &gt;&gt; a$ Shellkill用户只能关闭自己的进程，root可以关闭所有进程 tee 分离输出 多重输出 tee命令和|一起使用实现分离输出 选项 -a 不覆盖原来内容 -i 不响应中断","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]}]}