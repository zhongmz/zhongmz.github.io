{"meta":{"title":"zhongmz","subtitle":"Don","description":"写写算法 写写日记","author":"钟美智","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-09-23T05:28:32.000Z","updated":"2019-10-07T14:41:15.885Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2019-09-23T05:35:25.000Z","updated":"2019-10-07T14:52:04.209Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"ma nong TI","slug":"ma-nong-TI","date":"2019-10-29T13:36:59.000Z","updated":"2019-10-29T13:38:13.633Z","comments":true,"path":"2019/10/29/ ma-nong-TI/","link":"","permalink":"http://yoursite.com/2019/10/29/ ma-nong-TI/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int MAX=1e3+10;char str[MAX][100];//假设每一个数字不超过100位int total;//一共多少个节点char s[MAX];int len;class BinTreeNode&#123;public: BinTreeNode*left; BinTreeNode*right; char data[100];public: BinTreeNode(const char*ss=NULL,BinTreeNode*L=NULL,BinTreeNode*R=NULL):left(L),right(R)&#123;if(ss!=NULL)strcpy(data,ss);&#125; BinTreeNode*GetLeft()const &#123; return left; &#125; BinTreeNode*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode*L) &#123; left=L; &#125; void SetRight(BinTreeNode*R) &#123; right=R; &#125; char* GetData()&#123;return data;&#125; void SetData(const char*item)&#123;strcpy(data,item);&#125;&#125;;class pairn&#123;public: BinTreeNode* first; int second;&#125;;class Stack4&#123;public: pairn str[MAX]; int n=0; pairn Top() &#123; return str[n]; &#125; void Push(pairn p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;class Stack&#123;public: char str[MAX][100]; int n=0; char* Top() &#123; return str[n]; &#125; void Push(const char s[100]) &#123; n++; strcpy(str[n],s); &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;class Stack3&#123;public: int str[MAX]; int n=0; int Top() &#123; return str[n]; &#125; void Push(int p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;//将所有的数字转化为正数//不会出现2*(-3)的情况void Init()&#123; scanf(\"%s\",s); int i; int j; len=strlen(s); for(i=0;i&lt;len-1;i++) &#123; if(s[i]=='(') &#123; if(s[i+1]=='-') &#123; for(j=len;j&gt;i+1;j--) &#123; s[j]=s[j-1]; &#125; s[i+1]='0'; len++; &#125; &#125; &#125; s[len]=0;&#125;int f(char ch)&#123; if(ch=='*'||ch=='/') return 2; if(ch=='+'||ch=='-') return 1;&#125;void In_To_Post()&#123; int i,j,k; Stack S1; Stack S2; S1.n=0; S2.n=0; total=0; char str0[100]; for(i=0;i&lt;len;i++) &#123; j=0; //假设是数字 while(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'&amp;&amp;i!=len) &#123; str0[j]=s[i]; j++; i++; &#125; if(j!=0) &#123; str0[j]=0; S1.Push(str0); &#125; if(i==len) &#123; break; &#125; if(s[i]=='(') &#123; S2.Push(\"(\"); // cout&lt;&lt;\"TOP\"&lt;&lt;S2.Top()&lt;&lt;endl; &#125; if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/') &#123; // cout&lt;&lt;\"i:\"&lt;&lt;i&lt;&lt;\"s[i]:\"&lt;&lt;s[i]&lt;&lt;endl; str0[0]=s[i]; str0[1]=0; if((S2.Top())[0]=='('||S2.Empty()==true) S2.Push(str0); else &#123; while(S2.Top()[0]!='('&amp;&amp;f(S2.Top()[0])&gt;=f(str0[0])&amp;&amp;S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; S2.Push(str0); &#125; &#125; if(s[i]==')') &#123; while(S2.Top()[0]!='('&amp;&amp;S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; S2.Pop(); &#125; &#125; // cout&lt;&lt;\"S1.n: \"&lt;&lt;S1.n&lt;&lt;\" S2.n:\"&lt;&lt;S2.n&lt;&lt;endl; while(S2.Empty()==false) &#123; S1.Push(S2.Top()); S2.Pop(); &#125; total=S1.n; i=total; while(S1.Empty()==false) &#123; strcpy(str[i],S1.Top()); i--; S1.Pop(); &#125;&#125;/*1+2*3+(4*5+6)*7*/class Stack2&#123;public: BinTreeNode* str[MAX]; int n=0; BinTreeNode* Top() &#123; return str[n]; &#125; void Push(BinTreeNode*p) &#123; n++; str[n]=p; &#125; void Pop() &#123; n--; &#125; bool Empty() &#123; if(n&lt;=0) return true; else return false; &#125;&#125;;BinTreeNode*CreateExprTree()&#123; BinTreeNode*root,*p; int i=1; Stack2 S2; S2.n=0; BinTreeNode*L; BinTreeNode*R; for(i=1;i&lt;=total;i++) &#123; if(str[i][0]=='+'||str[i][0]=='-'||str[i][0]=='*'||str[i][0]=='/') &#123; R=S2.Top(); S2.Pop(); L=S2.Top(); S2.Pop(); p=new BinTreeNode; p-&gt;SetData(str[i]); p-&gt;SetLeft(L); p-&gt;SetRight(R); S2.Push(p); &#125; else &#123; p=new BinTreeNode; p-&gt;SetData(str[i]); p-&gt;SetLeft(NULL); p-&gt;SetRight(NULL); S2.Push(p); &#125; &#125; root=S2.Top(); S2.Pop(); return root;&#125;int Ca(const char q[100])&#123; int sum=0; int i=0; for(i=0;q[i]!=0;i++) &#123; sum=sum*10+q[i]-'0'; &#125; return sum;&#125;const int ILL=-1e9;int GetValue(BinTreeNode*root)&#123; int sum=0; if(root==NULL) return 0; Stack3 Cac; pairn p; p.first=root; p.second=0; Stack4 P; P.Push(p); int i,j,k; int op1,op2; while(P.Empty()==false) &#123; p=P.Top(); P.Pop(); i=p.second; if(i==0) &#123; p.second++; P.Push(p); if(p.first-&gt;GetLeft()!=NULL) &#123; p.second=0; p.first=p.first-&gt;GetLeft(); P.Push(p); &#125; &#125; if(i==1) &#123; p.second++; P.Push(p); if(p.first-&gt;GetRight()!=NULL) &#123; p.second=0; p.first=p.first-&gt;GetRight(); P.Push(p); &#125; &#125; if(i==2) &#123; if(p.first-&gt;GetLeft()==NULL&amp;&amp;p.first-&gt;GetRight()==NULL) &#123; Cac.Push(Ca(p.first-&gt;GetData())); &#125; else &#123; op2=Cac.Top(); Cac.Pop(); op1=Cac.Top(); Cac.Pop(); char y[100]; strcpy(y,p.first-&gt;GetData()); int ans=0; if(y[0]=='+')ans=op1+op2; if(y[0]=='-')ans=op1-op2; if(y[0]=='*')ans=op1*op2; if(y[0]=='/') &#123; if(op2==0) &#123; printf(\"ILLRGAL\\n\"); return ILL; &#125; ans=op1/op2; &#125; Cac.Push(ans); &#125; &#125; &#125; sum=Cac.Top(); return sum;&#125;/*1+10*2*/void Del(BinTreeNode*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;int main()&#123; Init(); In_To_Post(); BinTreeNode*root=CreateExprTree(); int ans=GetValue(root); if(ans!=ILL) printf(\"%d\\n\",ans); Del(root); return 0;&#125; 当码农可真开心呢，哈哈哈哈，真好啊，不难使用STL，真开心啊","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"BinTree","slug":"BinTree","date":"2019-10-27T04:28:29.000Z","updated":"2019-10-28T15:16:29.257Z","comments":true,"path":"2019/10/27/ BinTree/","link":"","permalink":"http://yoursite.com/2019/10/27/ BinTree/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#include&lt;stack&gt;#include&lt;utility&gt;#include&lt;queue&gt;using namespace std;template&lt;class T&gt;class BinTreeNode&#123;public: BinTreeNode&lt;T&gt;*left; BinTreeNode&lt;T&gt;*right; T data;public: BinTreeNode(const T&amp;item,BinTreeNode&lt;T&gt;*L=NULL,BinTreeNode&lt;T&gt;*R=NULL):data(item),left(L),right(R)&#123;&#125; BinTreeNode&lt;T&gt;*GetLeft()const &#123; return left; &#125; BinTreeNode&lt;T&gt;*GetRight()const &#123; return right; &#125; void SetLeft(BinTreeNode&lt;T&gt;*L) &#123; left=L; &#125; void SetRight(BinTreeNode&lt;T&gt;*R) &#123; right=R; &#125; T&amp; GetData()&#123;return data;&#125; void SetData(const T&amp;item)&#123;data=item;&#125;&#125;;template&lt;class T&gt;class BinTree&#123;public: BinTreeNode&lt;T&gt;*root; T stop;public: BinTree(BinTreeNode&lt;T&gt;*t=NULL):root(t)&#123;&#125; void PreOrder(BinTreeNode&lt;T&gt;*t)const; void InOrder(BinTreeNode&lt;T&gt;*t)const; void PostOrder(BinTreeNode&lt;T&gt;*t)const; void LevelOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPreOrder(BinTreeNode&lt;T&gt;*t)const; void NorecInOrder(BinTreeNode&lt;T&gt;*t)const; void NorecPostOrder(BinTreeNode&lt;T&gt;*t)const; void CreateBinTree(T tostop); BinTreeNode&lt;T&gt;* Create(); BinTreeNode&lt;T&gt;*CopyTree(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p); BinTreeNode&lt;T&gt;*Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const; void InsertLeft(T item,BinTreeNode&lt;T&gt;*t); void InsertRight(T item,BinTreeNode&lt;T&gt;*s); void DelSubtree(BinTreeNode&lt;T&gt;*t); void Del(BinTreeNode&lt;T&gt;*t); BinTreeNode&lt;T&gt;*GetRoot()&#123;return root;&#125; void SetRoot(BinTreeNode&lt;T&gt;*t)&#123;root=t;&#125; T getStop()&#123;return stop;&#125; void SetStop(T tostop)&#123;stop=tostop;&#125; bool IsEmpty()&#123;return root==NULL;&#125;&#125;;template&lt;class T&gt;void BinTree&lt;T&gt;::PreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; PreOrder(t-&gt;GetLeft()); PreOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; InOrder(t-&gt;GetLeft()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; InOrder(t-&gt;GetRight()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::PostOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t!=NULL) &#123; PostOrder(t-&gt;GetLeft()); PostOrder(t-&gt;GetRight()); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecInOrder(BinTreeNode&lt;T&gt;*t)const&#123; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; while(t!=NULL||S.empty()==false) &#123; while(t!=NULL) &#123; S.push(t); t=t-&gt;GetLeft(); &#125; if(S.empty()==true)return ; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; t=t-&gt;GetRight(); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPreOrder(BinTreeNode&lt;T&gt;*t)const&#123; if(t==NULL)return ; stack&lt;BinTreeNode&lt;T&gt;*&gt;S; S.push(t); while(S.empty()==false) &#123; t=S.top(); S.pop(); cout&lt;&lt;t-&gt;GetData()&lt;&lt;endl; if(t-&gt;GetRight()!=NULL) S.push(t-&gt;GetRight()); if(t-&gt;GetLeft()!=NULL) S.push(t-&gt;GetLeft()); &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::NorecPostOrder(BinTreeNode&lt;T&gt;*t)const&#123; pair&lt;BinTreeNode&lt;T&gt;*,int&gt; p; if(t==NULL)return ; p=make_pair(t,0); stack&lt;pair&lt;BinTreeNode&lt;T&gt;*,int&gt;&gt;S; S.push(p); while(S.empty()==false) &#123; p=S.top(); S.pop(); if(p.second==0) &#123; p.second++; S.push(p); if((p.first)-&gt;GetLeft()!=NULL) &#123; p.first=(p.first)-&gt;GetLeft(); p.second=0; S.push(p); &#125; &#125; else &#123; if(p.second==1) &#123; p.second++; S.push(p); if((p.first)-&gt;GetRight()!=NULL) &#123; p.first=(p.first)-&gt;GetRight(); p.second=0; S.push(p); &#125; &#125; else &#123; cout&lt;&lt;p.first-&gt;GetData()&lt;&lt;endl; &#125; &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::LevelOrder(BinTreeNode&lt;T&gt;*t)const&#123; queue&lt;BinTreeNode&lt;T&gt;*&gt;Q; if(t==NULL)return ; BinTreeNode&lt;T&gt; *p=t; Q.push(p); while(Q.empty()==false) &#123; p=Q.front(); Q.pop(); cout&lt;&lt;p-&gt;GetData()&lt;&lt;endl; if(p-&gt;GetLeft()!=NULL) &#123; Q.push(p-&gt;GetLeft()); &#125; if(p-&gt;GetRight()!=NULL) &#123; Q.push(p-&gt;GetRight()); &#125; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::CreateBinTree(T tostop)&#123; SetStop(tostop); root=Create();&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;* BinTree&lt;T&gt;::Create()&#123; BinTreeNode&lt;T&gt;*t,*t1,*t2; T item; cin&gt;&gt;item; if(item==stop) &#123; t=NULL; return t; &#125; t=new BinTreeNode&lt;T&gt;(item,NULL,NULL); t1=Create(); t-&gt;SetLeft(t1); t2=Create(); t-&gt;SetRight(t2); return t;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::CopyTree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return NULL; BinTreeNode&lt;T&gt;*L=nullptr,*R=nullptr; if(t-&gt;GetLeft()!=NULL) &#123; L=CopyTree(t-&gt;GetLeft()); &#125; if(t-&gt;GetRight()!=NULL) &#123; R=CopyTree(t-&gt;GetRight()); &#125; BinTreeNode&lt;T&gt;*nod=new BinTreeNode&lt;T&gt;(t-&gt;GetData(),L,R); return nod;&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Father(BinTreeNode&lt;T&gt;*t,BinTreeNode&lt;T&gt;*p)&#123; BinTreeNode&lt;T&gt;*q; if(t==NULL||p==NULL) return NULL; if(t-&gt;GetLeft()==p||t-&gt;GetRight()==p) return t; q=Father(t-&gt;GetLeft(),p); if(q!=NULL)return q; return Father(t-&gt;GetRight(),p);&#125;template&lt;class T&gt;BinTreeNode&lt;T&gt;*BinTree&lt;T&gt;::Find(BinTreeNode&lt;T&gt;*t,const T&amp;item)const&#123; BinTreeNode&lt;T&gt;*p; if(t==NULL)return NULL; if(t-&gt;data==item) return t; p=Find(t-&gt;GetLeft(),item); if(p!=NULL) return p; p=Find(t-&gt;GetRight(),item); return p;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::Del(BinTreeNode&lt;T&gt;*t)&#123; if(t!=NULL) &#123; Del(t-&gt;GetLeft()); Del(t-&gt;GetRight()); delete t; &#125;&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertLeft(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetLeft(s-&gt;GetLeft()); p-&gt;SetRight(NULL); s-&gt;SetLeft(p);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::InsertRight(T item,BinTreeNode&lt;T&gt;*s)&#123; if(s==NULL) return ; BinTreeNode&lt;T&gt;*p=new BinTreeNode&lt;T&gt;(item); p-&gt;SetRight(s-&gt;GetRight()); s-&gt;SetRight(p); p-&gt;SetLeft(NULL);&#125;template&lt;class T&gt;void BinTree&lt;T&gt;::DelSubtree(BinTreeNode&lt;T&gt;*t)&#123; if(t==NULL)return ; if(t==root) &#123; Del(t); root=NULL; return ; &#125; BinTreeNode&lt;T&gt;*f=Father(root,t); if(f!=nullptr) &#123; if(f-&gt;GetLeft()==t) f-&gt;SetLeft(NULL); if(f-&gt;GetRight()==t)f-&gt;SetRight((NULL)); &#125; Del(t);&#125;int main()&#123; BinTree&lt;int&gt; t; t.CreateBinTree(-1); BinTreeNode&lt;int&gt;*t2=t.Find(t.root,4); t.InsertRight(6,t2); t.InOrder(t.root); return 0;&#125;/*1 2 4 -1 5 -1 -1 -1 3 -1 -1*/","categories":[],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]},{"title":"大数运算","slug":"大数运算","date":"2019-10-21T07:02:01.000Z","updated":"2019-10-21T07:04:12.755Z","comments":true,"path":"2019/10/21/ 大数运算/","link":"","permalink":"http://yoursite.com/2019/10/21/ 大数运算/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546//大数和整数的除法string div(string a,int b)&#123; string c; int len=a.length(),ans=0; char s; for(int i=0; i&lt;len; i++)&#123; ans=ans*10+a[i]-'0'; s=ans/b+'0'; ans%=b; c+=s; &#125; int pos=0; while(pos&lt;len &amp;&amp; c[pos]=='0') pos++; if(pos==len) return \"0\"; return c.substr(pos);&#125;//大数和整数的乘法string mul(string a,int b)&#123; string c; char s; int len=a.length(),ok=0; for(int i=len-1; i&gt;=0; i--)&#123; int temp=(a[i]-'0')*b+ok; ok=temp/10; s=temp%10+'0'; c=s+c; &#125; while(ok)&#123; s=ok%10+'0'; c=s+c; ok/=10; &#125; return c;&#125;//大数对整数取模int MOD(string str,int mod)&#123; int rem=0; for(int i=0; i&lt;str.length(); i++)&#123; rem=rem*10+str[i]-'0'; rem=rem%mod; &#125; return rem;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Bignumber","slug":"Bignumber","permalink":"http://yoursite.com/tags/Bignumber/"}]},{"title":"EulerSieve","slug":"EulerSieve","date":"2019-10-21T06:16:46.000Z","updated":"2019-10-21T06:21:04.389Z","comments":true,"path":"2019/10/21/ EulerSieve/","link":"","permalink":"http://yoursite.com/2019/10/21/ EulerSieve/","excerpt":"","text":"EulerSieve##### 时间复杂度​ O(n) 实现12345678910111213141516171819202122const int maxn = 10100; int prime[maxn], pNum = 0; // prime记录素数，pNum记录素数个数 //保存的值为0~pNum-1bool p[maxn] = &#123;false&#125;; // p记录当前数是否被筛去void EulerSieve(int n) // 查找记录2-n的素数&#123; int j; for (int i = 2; i &lt;= n; i++) &#123; if (p[i] == false) // 如果未被筛过，则为素数 prime[pNum++] = i; for (j = 0; j &lt; pNum; j++) &#123; if (i * prime[j] &gt; n) // 当要标记的合数超出范围时跳出 break; p[i * prime[j]] = true; // 将已经记录的素数的倍数进行标记 if (i % prime[j] == 0) //关键步骤 break; &#125; &#125;&#125; 理解时间复杂度证明","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Prime","slug":"Prime","permalink":"http://yoursite.com/tags/Prime/"}]},{"title":"10-20","slug":"10-20","date":"2019-10-21T05:28:05.000Z","updated":"2019-10-21T07:08:48.412Z","comments":true,"path":"2019/10/21/ 10-20/","link":"","permalink":"http://yoursite.com/2019/10/21/ 10-20/","excerpt":"","text":"Jiaozuo Regional Contest Problem A Xu Xiake in henan Province​ 输入4个数字，判断有多少个非0的数 Problem I Distance&gt; 前缀和 模拟​ 输入n ​ 在x轴上有n个点，且分别给出它们之间的距离 ​ 输出n个数字，这些数字分别为a1,a2,a3…an。其中ai的值为：在这些点中取i个点，使得每两个点的距离之和最大。 ​ 我们只需要从两端取点则可以一定保证其和最大化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;typedef long long LL;int T;int n;LL ans;LL cnt;int Left;int Right;//分别模拟最左边和最右边的位置const int MAX=1e6+10;LL sum[MAX];void Init()&#123; scanf(\"%d\",&amp;n); int i; LL a; sum[0]=0; sum[1]=0; for(i=2;i&lt;=n;i++) &#123; scanf(\"%lld\",&amp;a); sum[i]=sum[i-1]+a; &#125; //前缀和一下 Left=1; Right=n;&#125;void Func()&#123; printf(\"0\"); cnt=sum[Right]-sum[Left]; ans=cnt; printf(\" %lld\",ans); int i; for(i=3;i&lt;=n;i++) &#123; if(i%2==1) &#123; ans=ans+cnt; printf(\" %lld\",ans); Left++; &#125; else &#123; Right--; cnt=cnt+sum[Right]-sum[Left]; ans=ans+cnt; printf(\" %lld\",ans); &#125; &#125; printf(\"\\n\");&#125;int main()&#123; scanf(\"%d\",&amp;T); int i; for(i=1;i&lt;=T;i++) &#123; Init(); Func(); &#125; return 0;&#125; Problem E Resistors in Parallel​","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Train-10-20","slug":"Train-10-20","permalink":"http://yoursite.com/tags/Train-10-20/"}]},{"title":"Train-10-20","slug":"Train-10-20","date":"2019-10-21T05:28:05.000Z","updated":"2019-10-21T05:29:37.483Z","comments":true,"path":"2019/10/21/ Train-10-20/","link":"","permalink":"http://yoursite.com/2019/10/21/ Train-10-20/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Train-10-19","slug":"Train-10-19","date":"2019-10-20T17:40:28.000Z","updated":"2019-10-21T07:08:57.137Z","comments":true,"path":"2019/10/21/ Train-10-19/","link":"","permalink":"http://yoursite.com/2019/10/21/ Train-10-19/","excerpt":"","text":"传送门 Chart 1​ 搜索打表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869vector&lt;pair&lt;double,double&gt;&gt; v;const double h=0.5*sqrt(3.0);//判断是否等边三角形typedef long long LL;const double eps=1e-6;LL cnt;bool f(pair&lt;double,double&gt; a,pair&lt;double,double&gt; b,pair&lt;double,double&gt; c)&#123; double L1=(a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second); double L2=(a.first-c.first)*(a.first-c.first)+(a.second-c.second)*(a.second-c.second); double L3=(c.first-b.first)*(c.first-b.first)+(c.second-b.second)*(c.second-b.second); if(fabs(L1-L2)&lt;eps&amp;&amp;fabs(L1-L3)&lt;eps) return true; else return false;&#125;void Func()&#123; //初始化点集 pair&lt;double,double&gt; p; p.first=0.0; p.second=0.0; v.push_back(p); int i; int j,k,g; double i0; for(i=1;i&lt;=30;i++) &#123; cnt=0; i0=i; p.second=(-1.0)*i0*h; if(i%2==0) &#123; p.first=0.0; v.push_back(p); for(j=1;j&lt;=i/2;j++) &#123; p.first=(double)j; v.push_back(p); p.first=p.first*(-1.0); v.push_back(p); &#125; &#125; else &#123; for(j=0;j&lt;=i/2;j++) &#123; p.first=0.5+(double)j; v.push_back(p); p.first=p.first*(-1.0); v.push_back(p); &#125; &#125; for(j=1;j&lt;=v.size()-2;j++) &#123; for(k=j+1;k&lt;=v.size()-1;k++) &#123; for(g=k+1;g&lt;=v.size();g++) &#123; if(f(v[j-1],v[k-1],v[g-1])==true) cnt++; &#125; &#125; &#125; printf(\"i=%d cnt=%lld\\n\",i,cnt); &#125;&#125; Chart 2找规律（可以使用下这个牛皮方法） （其实是需要知道各种函数的性质方可使用 不断做差知道第四次做差的时候所有的差值为同一值（即原来的函数表达式最高次为4次） 设方程 f(n)=an^4+bn^3+cn^2+dn+e 则解方程即可（可以使用excel来解） a=1/24 b=6/24 c=11/24 d=6/24 这里还需要使用到求24的逆元 123456789101112131415const LL MOD=1e9+7;const LL Inv24=41666667;LL n;LL ans;void Func()&#123; LL n1=n*n%MOD; n1=(n1*n1)%MOD; LL n2=((n*n)%MOD*n)%MOD*6%MOD; LL n3=n*n%MOD*11%MOD; LL n4=6*n%MOD; ans=(n1+n2+n3+n4)%MOD; ans=ans*Inv24%MOD; printf(\"%lld\\n\",ans);&#125; 他好强","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Train","slug":"Train","permalink":"http://yoursite.com/tags/Train/"}]},{"title":"Fermat little theorem","slug":"Fermat-little-theorem","date":"2019-10-20T17:33:43.000Z","updated":"2019-10-20T17:38:28.821Z","comments":true,"path":"2019/10/21/ Fermat-little-theorem/","link":"","permalink":"http://yoursite.com/2019/10/21/ Fermat-little-theorem/","excerpt":"","text":"Fermat little theorem​ 如果p是一个质数，而整数a不是p的倍数，则有a^（p-1）≡1（mod p） ​ 则可以求的分数（逆元）的取模：1/a(mod p)=a^(p-2)","categories":[{"name":"math","slug":"math","permalink":"http://yoursite.com/categories/math/"}],"tags":[{"name":"Fermat little theorem","slug":"Fermat-little-theorem","permalink":"http://yoursite.com/tags/Fermat-little-theorem/"}]},{"title":"qpow","slug":"qpow","date":"2019-10-20T17:18:42.000Z","updated":"2019-10-20T17:32:10.167Z","comments":true,"path":"2019/10/21/ qpow/","link":"","permalink":"http://yoursite.com/2019/10/21/ qpow/","excerpt":"","text":"快速幂假设​ 求x^n的值 时间复杂度​ O(log n) 解释​ 通过加大底数的权重来使得乘法次数更少 ​ 1.假设n为奇数：x^n=x*x^(n-1) 则将x计入结果 ​ 2.假设n为偶数：x^n=x^(n/2)*x^(n/2) 则将x的权重变为x^2 实现代码1234567891011121314/*快速幂运算 log 2 n*/typedef long long LL;LL qpow(LL a, LL n, LL mod)&#123; LL result = 1; while (n!=0) &#123; if (n &amp; 1) result = (result * a) % mod;//计入结果 a = (a * a) % mod;//权重变大 n &gt;&gt;= 1;//n=n/2; &#125; return result;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"http://yoursite.com/tags/快速幂/"}]},{"title":"Kruskal","slug":"Kruskal","date":"2019-10-10T14:56:52.000Z","updated":"2019-10-20T17:57:57.781Z","comments":true,"path":"2019/10/10/ Kruskal/","link":"","permalink":"http://yoursite.com/2019/10/10/ Kruskal/","excerpt":"","text":"Kruskal Kruskal总是维护无向连通图的最小生成森林 最终得到该图的最小生成树 由来​ Kruskal算法是一种用来查找最小生成树的贪心算法，由Joseph Kruskal在1956年发表。 假设​ 有n个点m条无向边的图，且已知每一条边(x,y,z)，代表点x和点y之间有哦权值为z的无向边。 时间复杂度​ O(m log m) 预备知识​ 并查集 先挖坑 解释​ 在遍历所给无向连通图的过程中，kruskal 总是维护着最小生成森林。 ​ 最终得到最小生成树。 ​ 有以下步骤： ​ 1.初始化并查集，每一个点各自构成一个集合 ​ 2.对边集S进行从小到大排序 ​ 3.从S中取出一条边（注意：现在是从S中从小到大取出，判断这条边的两个端点是否属于同一个集合（使用并查集维护），不是则将端点x和端点y使用并查集combine起来。且将边加入最小生成森林。 ​ 4.不断重复S直至访问完所有边 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//以边集来保存图，假设有m条边//时间复杂度为mlogmconst int MAX=11010;struct edge&#123; int x; int y; int z;&#125;;//代表x和y两点之间有路且权值为zedge S[MAX];int Father[MAX];int n,m;int ans;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; return a.z&lt;b.z;&#125;inline void Init()&#123; int i; scanf(\"%d%d\",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;S[i].x,&amp;S[i].y,&amp;S[i].z);&#125;//并查集找父亲inline int Find(int x)&#123; while(x!=Father[x]) x=Father[x]; return x; &#125;//combineinline void combine(int x,int y)&#123; Father[x]=y;&#125;inline void Kruskal()&#123; ans=0; int x; int y; int i; for(i=1;i&lt;=n;i++) Father[i]=i; sort(S+1,S+m+1); for(i=1;i&lt;=m;i++) &#123; x=Find(S[i].x); y=Find(S[i].y); if(x!=y) &#123; ans=ans+S[i].z; combine(x,y); &#125; &#125;&#125; 模板题 ​ 回顾学习算法的第四天。戒掉可乐的第四天 ​ Orz ​ Orz","categories":[{"name":"“algorithm\"","slug":"“algorithm","permalink":"http://yoursite.com/categories/“algorithm/"}],"tags":[{"name":"Kruskal","slug":"Kruskal","permalink":"http://yoursite.com/tags/Kruskal/"}]},{"title":"Leg","slug":"Leg","date":"2019-10-09T15:21:37.000Z","updated":"2019-10-09T15:55:24.346Z","comments":true,"path":"2019/10/09/ Leg/","link":"","permalink":"http://yoursite.com/2019/10/09/ Leg/","excerpt":"","text":"十分荒废的一次训练，自以为腿部没有人看出来就不训练了吗，一到机械前就会失措=-= 还有许多腿部的动作实在过于僵硬，组数和重量也是安排的无厘头=-= 深蹲 KG 10 10 20 10 10 RM 8 8 8 8 8 小深蹲 15 20 25 35 45 45 20 20 20 15 10 10 standing leg curl 10 10 15 15 12 12 12 12 我要开始好好训练腹部和腿部了=-=","categories":[],"tags":[{"name":"teg","slug":"teg","permalink":"http://yoursite.com/tags/teg/"}]},{"title":"Manacher","slug":"Manacher","date":"2019-10-09T15:21:21.000Z","updated":"2019-10-09T16:01:38.179Z","comments":true,"path":"2019/10/09/ Manacher/","link":"","permalink":"http://yoursite.com/2019/10/09/ Manacher/","excerpt":"","text":"由来​ 1975年，一个叫Manacher的人发明了一个Manacher算法 作用​ 给定一个字符串S，求出其最大回文子串 时间复杂度 O(n) 原理 对称性 1.字符串处理​ 由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 ​ Example： 原串S a c a b a 转换后的串T # a # c # a # b # a # ​ 为了防止越界，做出以下修改，使得T变成$#a#a#a#b#a#@ 2.Len数组​ 设有字符串T上的位置i，Len[i]表示以i为中心的回文串的半径，和KMP算法相比，这里的数组并非只是预处理的作用，而是在线的处理 ​ 可得： i 1 2 3 4 5 6 7 8 9 10 11 T[i] # a # c # a # b # a # Len[i] 1 2 1 4 1 2 1 4 1 2 1 ​ 如何得到Len数组？ ​ （先挖坑） ​ 主要思想是利用对称性 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int MAX=110000000+10;char S[MAX];//原串char tmp[MAX*2+10];//辅助字符串Tint Len[MAX*2+10];//Len数组int N1;//原串S的长度int N2;//T的长度inline void GetT()&#123; int i,N1=strlen(S); N2=N1*2+1; tmp[0]='$'; for(i=1;i&lt;=2*N1;i=i+2) &#123; tmp[i]='#'; tmp[i+1]=S[i/2]; &#125; tmp[i]='#'; tmp[i+1]='@'; tmp[i+2]=0;&#125;//得到最大的回文串长度inline int Manacher()&#123; GetLen(); int mx=0; int ans=0; int po=0; int i; for(i=1;i&lt;=N2;i++) &#123; if(mx&gt;i) &#123; //对称性 if((mx-i)&lt;Len[2*po-1]) Len[i]=mx-i; else Len[i]=Len[2*po-1]; &#125; else//第三种情况 Len[i]=1; //不断向外扩展，巧妙 while(tmp[i-Len[i]]==tmp[i+Len[i]]) Len[i]++; //更新值 if(Len[i]+i&gt;mx) &#123; mx=Len[i]+i; po=i; &#125; if(Len[i]&gt;ans) ans=Len[i]; &#125; return ans-1;&#125; ​ =-= ​ https://blog.csdn.net/dyx404514/article/details/42061017","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"http://yoursite.com/tags/Manacher/"}]},{"title":"Abdomen","slug":"Abdomen","date":"2019-10-08T08:15:17.000Z","updated":"2019-10-09T15:49:30.736Z","comments":true,"path":"2019/10/08/ Abdomen/","link":"","permalink":"http://yoursite.com/2019/10/08/ Abdomen/","excerpt":"","text":"​ 嘤嘤嘤… ​ 总是会认为腹部训练是附加于其他大肌群训练之后的小训练…可是这么久了还是原地踏步，看来要把腹部看做是一个大肌群了… 类仰卧起坐 KG 25 35 35 25 25 RM 25 15 15 20 20","categories":[{"name":"BODY","slug":"BODY","permalink":"http://yoursite.com/categories/BODY/"}],"tags":[{"name":"Abdomen","slug":"Abdomen","permalink":"http://yoursite.com/tags/Abdomen/"}]},{"title":"Chest","slug":"Chest","date":"2019-10-08T08:02:40.000Z","updated":"2019-10-09T08:13:33.137Z","comments":true,"path":"2019/10/08/ Chest/","link":"","permalink":"http://yoursite.com/2019/10/08/ Chest/","excerpt":"","text":"遇见大佬之二杠铃平板卧推 KG 5 5 10 10 10 RM 12 15 8 8 2 嘤嘤嘤…绝对不是因为我连续三天都训练上半身的原因 我终于会使用表格了 哑铃半卧推 KG 10 10 15 15 10 RM 12 12 8 4 8 坐姿推下胸 KG 10 10 15 10 RM 12 12 12 12 推不动了=-=真不行了 蝴蝶机夹胸 KG 19 24 14 14 14 RM 12 12 12 12 10","categories":[],"tags":[{"name":"Chest","slug":"Chest","permalink":"http://yoursite.com/tags/Chest/"}]},{"title":"Back","slug":"Back-1","date":"2019-10-07T14:04:27.000Z","updated":"2019-10-07T14:26:17.092Z","comments":true,"path":"2019/10/07/ Back-1/","link":"","permalink":"http://yoursite.com/2019/10/07/ Back-1/","excerpt":"","text":"背部训练LowRow​ 15KG 20RM- ​ 15KG 20RM- （应该以20KG为起始重量） ​ 25KG 10RM ​ 25KG 20RM ​ 25KG 15RM 中下拉​ 15KG 10RM- （应该以20KG为起始重量） ​ 25KG 12RM ​ 25KG 12RM ​ 25KG 15RM 龙门架划船​ 25KG 12RM（不碰肚脐） ​ 25KG 12RM （不碰肚脐） ​ 20KG 20RM（很舒服的一组） ​ 25KG 10RM ​ 20KG 20RM！！！ 吹爆龙门架划船，也许是个人原因吧。 高位下拉​ 35KG 20RM ​ 25KG 10RM（单侧各） ​ 25KG 40RM（交换单侧） ​ 20KG 40RM（交换单侧） ​ 20KG 40RM+++++++++ 宽距引体向上​ 不知道为什么感觉比高中的引体向上要累了许多=-=","categories":[{"name":"Body","slug":"Body","permalink":"http://yoursite.com/categories/Body/"}],"tags":[{"name":"Back","slug":"Back","permalink":"http://yoursite.com/tags/Back/"}]},{"title":"KMP","slug":"KMP","date":"2019-10-01T06:25:53.000Z","updated":"2019-10-07T15:42:20.369Z","comments":true,"path":"2019/10/01/ KMP/","link":"","permalink":"http://yoursite.com/2019/10/01/ KMP/","excerpt":"","text":"名字由来​ 由Knuth，Morris,Pratt三人所设计的线性时间字符串匹配算法 时间复杂度​ 设有长度为n的文本串S和长度为m的匹配串P，求匹配串成功匹配文本串字串的首地址 ​ O(n+m) 原理引出​ 对匹配串预处理生成一种失配的映射（或者称为函数，其实称为函数会更加恰当），我们姑且把这个函数成为Next函数。当匹配串对文本串进行匹配时，不妨想象一下，我们在失配的时候对应的失配位置i，都会有相同的移动位移，这样就会产生一个关于i的函数，我们姑且把这样的函数称之为Next(i)，那么这个函数的返回值是什么呢？在不同的博客上它的返回值是不一样的，比如，有些直接返回P下一个需要比较的位置，有些是返回P需要移动的距离（自行脑补一下），有些是返回最大该位置的最大的前后缀一样的字串的字符数，有些的Next函数是经过优化过的，自然返回值和原来的有些不一样。不过它们的使用方法都大同小异。 ​ 我们以返回值为P下一个需要匹配的位置为例 Next函数的产生​ 先挖坑 1234567891011121314151617181920inline void GetNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; Next[j]=k; &#125; else &#123; k=Next[k]; &#125; &#125;&#125; NextPro数组的产生12345678910111213141516171819202122inline void GetProNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; //只是比Next数组多了一个判断罢了 if(P[j]!=P[k]) Next[j]=k; else Next[j]=Next[k]; &#125; else k=Next[k]; &#125;&#125; KMPSearch代码12345678910111213141516171819202122232425262728const int MAX=10010;char P[MAX];char S[MAX];int Next[MAX];int KmpSearch()&#123; GetProNext();//只需要在这里预处理P的Next数组即可 int sLen=strlen(S); int pLen=strlen(P); int i=0; int j=0; while(i&lt;sLen&amp;&amp;j&lt;pLen) &#123; if(j==-1||S[i]==P[j]) &#123; i++; j++; &#125; else &#123; j=Next[j]; &#125; &#125; if(j==pLen) return i-j; else return -1;&#125; 这个讲解很棒https://blog.csdn.net/v_JULY_v/article/details/7041827","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/tags/KMP/"}]},{"title":"Back","slug":"Back","date":"2019-09-23T05:55:21.000Z","updated":"2019-10-09T15:49:42.394Z","comments":true,"path":"2019/09/23/ Back/","link":"","permalink":"http://yoursite.com/2019/09/23/ Back/","excerpt":"","text":"​ 这是一篇虚假的背部的训练计划 体重：65 身高：173 体脂：未知 ​ 无论是身体的哪一部分训练都可以遵循以下原则： ​ 感受身体对应的部位，了解它的肌肉线条，从而得到它拉伸的方向，拉到最远距离，缩到最近距离。接下来的每一个动作都可以依据这样的原则来进行训练 坐式低拉背​ 10KG 12RM ​ 10KG 12RM ​ 15KG 12RM ​ 20KG 12RM ​ 20KG 12RM 龙门架划船​ 25KG 12RM ​ 25KG 12RM ​ 35KG 8RM ​ 35KG 8RM ​ 25KG 8RM 坐式中拉背​ 10KG 12RM ​ 10KG 12RM ​ 15KG 12RM ​ 20KG 12RM ​ 20KG 12RM 高位下拉最喜欢的动作之一​ 30KG 16RM ​ 40KG 12RM ​ 40KG 12RM ​ 50KG 12RM ​ 50KG 5RM 正手引体向上​ 随缘力竭5组","categories":[{"name":"BODY","slug":"BODY","permalink":"http://yoursite.com/categories/BODY/"}],"tags":[]},{"title":"划水日记","slug":"index","date":"2019-09-22T15:19:49.000Z","updated":"2019-10-07T14:27:11.110Z","comments":true,"path":"2019/09/22/ index/","link":"","permalink":"http://yoursite.com/2019/09/22/ index/","excerpt":"","text":"今日观影报告：罪恶之城 今日游戏报告：星际神族训练，还是找不准timing啊 我什么时候才能开始真正些blog啊…=-= 明天要开始冲了啊，不能再这样放纵自己下去了啊！！","categories":[{"name":"DIARY","slug":"DIARY","permalink":"http://yoursite.com/categories/DIARY/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T08:49:53.178Z","updated":"2019-08-30T08:49:53.178Z","comments":true,"path":"2019/08/30/ hello-world/","link":"","permalink":"http://yoursite.com/2019/08/30/ hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}