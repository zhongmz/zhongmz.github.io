{"meta":{"title":"zhongmz","subtitle":"Don","description":"写写算法 写写日记","author":"钟美智","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-09-23T05:28:32.000Z","updated":"2019-10-07T14:41:15.885Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2019-09-23T05:35:25.000Z","updated":"2019-10-07T14:52:04.209Z","comments":true,"path":"tag/index.html","permalink":"http://yoursite.com/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Kruskal","slug":"Kruskal","date":"2019-10-10T14:56:52.000Z","updated":"2019-10-20T17:15:23.508Z","comments":true,"path":"2019/10/10/ Kruskal/","link":"","permalink":"http://yoursite.com/2019/10/10/ Kruskal/","excerpt":"","text":"Kruskal Kruskal总是维护无向连通图的最小生成森林 最终得到该图的最小生成树 由来​ Kruskal算法是一种用来查找最小生成树的贪心算法，由Joseph Kruskal在1956年发表。 假设​ 有n个点m条无向边的图，且已知每一条边(x,y,z)，代表点x和点y之间有哦权值为z的无向边。 时间复杂度​ O(m log m) 预备知识​ 并查集 先挖坑 解释​ 在遍历所给无向连通图的过程中，kruskal 总是维护着最小生成森林。 ​ 最终得到最小生成树。 ​ 有以下步骤： ​ 1.初始化并查集，每一个点各自构成一个集合 ​ 2.对边集S进行从小到大排序 ​ 3.从S中取出一条边（注意：现在是从S中从小到大取出，判断这条边的两个端点是否属于同一个集合（使用并查集维护），不是则将端点x和端点y使用并查集combine起来。且将边加入最小生成森林。 ​ 4.不断重复S直至访问完所有边 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//以边集来保存图，假设有m条边//时间复杂度为mlogmconst int MAX=11010;struct edge&#123; int x; int y; int z;&#125;;//代表x和y两点之间有路且权值为zedge S[MAX];int Father[MAX];int n,m;int ans;bool operator &lt;(const edge&amp;a,const edge&amp;b)&#123; return a.z&lt;b.z;&#125;inline void Init()&#123; int i; scanf(\"%d%d\",&amp;n,&amp;m); for(i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;S[i].x,&amp;S[i].y,&amp;S[i].z);&#125;//并查集找父亲inline int Find(int x)&#123; while(x!=Father[x]) x=Father[x]; return x; &#125;//combineinline void combine(int x,int y)&#123; Father[x]=y;&#125;inline void Kruskal()&#123; ans=0; int x; int y; int i; for(i=1;i&lt;=n;i++) Father[i]=i; sort(S+1,S+m+1); for(i=1;i&lt;=m;i++) &#123; x=Find(S[i].x); y=Find(S[i].y); if(x!=y) &#123; ans=ans+S[i].z; combine(x,y); &#125; &#125;&#125; 模板题 ​ 回顾学习算法的第四天。戒掉可乐的第四天 ​ Orz ​ Orz","categories":[{"name":"“algorithm\"","slug":"“algorithm","permalink":"http://yoursite.com/categories/“algorithm/"}],"tags":[{"name":"Kruskal","slug":"Kruskal","permalink":"http://yoursite.com/tags/Kruskal/"}]},{"title":"Leg","slug":"Leg","date":"2019-10-09T15:21:37.000Z","updated":"2019-10-09T15:55:24.346Z","comments":true,"path":"2019/10/09/ Leg/","link":"","permalink":"http://yoursite.com/2019/10/09/ Leg/","excerpt":"","text":"十分荒废的一次训练，自以为腿部没有人看出来就不训练了吗，一到机械前就会失措=-= 还有许多腿部的动作实在过于僵硬，组数和重量也是安排的无厘头=-= 深蹲 KG 10 10 20 10 10 RM 8 8 8 8 8 小深蹲 15 20 25 35 45 45 20 20 20 15 10 10 standing leg curl 10 10 15 15 12 12 12 12 我要开始好好训练腹部和腿部了=-=","categories":[],"tags":[{"name":"teg","slug":"teg","permalink":"http://yoursite.com/tags/teg/"}]},{"title":"Manacher","slug":"Manacher","date":"2019-10-09T15:21:21.000Z","updated":"2019-10-09T16:01:38.179Z","comments":true,"path":"2019/10/09/ Manacher/","link":"","permalink":"http://yoursite.com/2019/10/09/ Manacher/","excerpt":"","text":"由来​ 1975年，一个叫Manacher的人发明了一个Manacher算法 作用​ 给定一个字符串S，求出其最大回文子串 时间复杂度 O(n) 原理 对称性 1.字符串处理​ 由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 ​ Example： 原串S a c a b a 转换后的串T # a # c # a # b # a # ​ 为了防止越界，做出以下修改，使得T变成$#a#a#a#b#a#@ 2.Len数组​ 设有字符串T上的位置i，Len[i]表示以i为中心的回文串的半径，和KMP算法相比，这里的数组并非只是预处理的作用，而是在线的处理 ​ 可得： i 1 2 3 4 5 6 7 8 9 10 11 T[i] # a # c # a # b # a # Len[i] 1 2 1 4 1 2 1 4 1 2 1 ​ 如何得到Len数组？ ​ （先挖坑） ​ 主要思想是利用对称性 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int MAX=110000000+10;char S[MAX];//原串char tmp[MAX*2+10];//辅助字符串Tint Len[MAX*2+10];//Len数组int N1;//原串S的长度int N2;//T的长度inline void GetT()&#123; int i,N1=strlen(S); N2=N1*2+1; tmp[0]='$'; for(i=1;i&lt;=2*N1;i=i+2) &#123; tmp[i]='#'; tmp[i+1]=S[i/2]; &#125; tmp[i]='#'; tmp[i+1]='@'; tmp[i+2]=0;&#125;//得到最大的回文串长度inline int Manacher()&#123; GetLen(); int mx=0; int ans=0; int po=0; int i; for(i=1;i&lt;=N2;i++) &#123; if(mx&gt;i) &#123; //对称性 if((mx-i)&lt;Len[2*po-1]) Len[i]=mx-i; else Len[i]=Len[2*po-1]; &#125; else//第三种情况 Len[i]=1; //不断向外扩展，巧妙 while(tmp[i-Len[i]]==tmp[i+Len[i]]) Len[i]++; //更新值 if(Len[i]+i&gt;mx) &#123; mx=Len[i]+i; po=i; &#125; if(Len[i]&gt;ans) ans=Len[i]; &#125; return ans-1;&#125; ​ =-= ​ https://blog.csdn.net/dyx404514/article/details/42061017","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"http://yoursite.com/tags/Manacher/"}]},{"title":"Abdomen","slug":"Abdomen","date":"2019-10-08T08:15:17.000Z","updated":"2019-10-09T15:49:30.736Z","comments":true,"path":"2019/10/08/ Abdomen/","link":"","permalink":"http://yoursite.com/2019/10/08/ Abdomen/","excerpt":"","text":"​ 嘤嘤嘤… ​ 总是会认为腹部训练是附加于其他大肌群训练之后的小训练…可是这么久了还是原地踏步，看来要把腹部看做是一个大肌群了… 类仰卧起坐 KG 25 35 35 25 25 RM 25 15 15 20 20","categories":[{"name":"BODY","slug":"BODY","permalink":"http://yoursite.com/categories/BODY/"}],"tags":[{"name":"Abdomen","slug":"Abdomen","permalink":"http://yoursite.com/tags/Abdomen/"}]},{"title":"Chest","slug":"Chest","date":"2019-10-08T08:02:40.000Z","updated":"2019-10-09T08:13:33.137Z","comments":true,"path":"2019/10/08/ Chest/","link":"","permalink":"http://yoursite.com/2019/10/08/ Chest/","excerpt":"","text":"遇见大佬之二杠铃平板卧推 KG 5 5 10 10 10 RM 12 15 8 8 2 嘤嘤嘤…绝对不是因为我连续三天都训练上半身的原因 我终于会使用表格了 哑铃半卧推 KG 10 10 15 15 10 RM 12 12 8 4 8 坐姿推下胸 KG 10 10 15 10 RM 12 12 12 12 推不动了=-=真不行了 蝴蝶机夹胸 KG 19 24 14 14 14 RM 12 12 12 12 10","categories":[],"tags":[{"name":"Chest","slug":"Chest","permalink":"http://yoursite.com/tags/Chest/"}]},{"title":"Back","slug":"Back-1","date":"2019-10-07T14:04:27.000Z","updated":"2019-10-07T14:26:17.092Z","comments":true,"path":"2019/10/07/ Back-1/","link":"","permalink":"http://yoursite.com/2019/10/07/ Back-1/","excerpt":"","text":"背部训练LowRow​ 15KG 20RM- ​ 15KG 20RM- （应该以20KG为起始重量） ​ 25KG 10RM ​ 25KG 20RM ​ 25KG 15RM 中下拉​ 15KG 10RM- （应该以20KG为起始重量） ​ 25KG 12RM ​ 25KG 12RM ​ 25KG 15RM 龙门架划船​ 25KG 12RM（不碰肚脐） ​ 25KG 12RM （不碰肚脐） ​ 20KG 20RM（很舒服的一组） ​ 25KG 10RM ​ 20KG 20RM！！！ 吹爆龙门架划船，也许是个人原因吧。 高位下拉​ 35KG 20RM ​ 25KG 10RM（单侧各） ​ 25KG 40RM（交换单侧） ​ 20KG 40RM（交换单侧） ​ 20KG 40RM+++++++++ 宽距引体向上​ 不知道为什么感觉比高中的引体向上要累了许多=-=","categories":[{"name":"Body","slug":"Body","permalink":"http://yoursite.com/categories/Body/"}],"tags":[{"name":"Back","slug":"Back","permalink":"http://yoursite.com/tags/Back/"}]},{"title":"KMP","slug":"KMP","date":"2019-10-01T06:25:53.000Z","updated":"2019-10-07T15:42:20.369Z","comments":true,"path":"2019/10/01/ KMP/","link":"","permalink":"http://yoursite.com/2019/10/01/ KMP/","excerpt":"","text":"名字由来​ 由Knuth，Morris,Pratt三人所设计的线性时间字符串匹配算法 时间复杂度​ 设有长度为n的文本串S和长度为m的匹配串P，求匹配串成功匹配文本串字串的首地址 ​ O(n+m) 原理引出​ 对匹配串预处理生成一种失配的映射（或者称为函数，其实称为函数会更加恰当），我们姑且把这个函数成为Next函数。当匹配串对文本串进行匹配时，不妨想象一下，我们在失配的时候对应的失配位置i，都会有相同的移动位移，这样就会产生一个关于i的函数，我们姑且把这样的函数称之为Next(i)，那么这个函数的返回值是什么呢？在不同的博客上它的返回值是不一样的，比如，有些直接返回P下一个需要比较的位置，有些是返回P需要移动的距离（自行脑补一下），有些是返回最大该位置的最大的前后缀一样的字串的字符数，有些的Next函数是经过优化过的，自然返回值和原来的有些不一样。不过它们的使用方法都大同小异。 ​ 我们以返回值为P下一个需要匹配的位置为例 Next函数的产生​ 先挖坑 1234567891011121314151617181920inline void GetNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; Next[j]=k; &#125; else &#123; k=Next[k]; &#125; &#125;&#125; NextPro数组的产生12345678910111213141516171819202122inline void GetProNext(int Next[],char P[])&#123; int pLen=strlen(P); int k=-1; int j=0; Next[0]=-1; while(j&lt;pLen-1) &#123; if(k==-1||P[k]==P[j]) &#123; k++; j++; //只是比Next数组多了一个判断罢了 if(P[j]!=P[k]) Next[j]=k; else Next[j]=Next[k]; &#125; else k=Next[k]; &#125;&#125; KMPSearch代码12345678910111213141516171819202122232425262728const int MAX=10010;char P[MAX];char S[MAX];int Next[MAX];int KmpSearch()&#123; GetProNext();//只需要在这里预处理P的Next数组即可 int sLen=strlen(S); int pLen=strlen(P); int i=0; int j=0; while(i&lt;sLen&amp;&amp;j&lt;pLen) &#123; if(j==-1||S[i]==P[j]) &#123; i++; j++; &#125; else &#123; j=Next[j]; &#125; &#125; if(j==pLen) return i-j; else return -1;&#125; 这个讲解很棒https://blog.csdn.net/v_JULY_v/article/details/7041827","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/categories/algorithm/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://yoursite.com/tags/KMP/"}]},{"title":"Back","slug":"Back","date":"2019-09-23T05:55:21.000Z","updated":"2019-10-09T15:49:42.394Z","comments":true,"path":"2019/09/23/ Back/","link":"","permalink":"http://yoursite.com/2019/09/23/ Back/","excerpt":"","text":"​ 这是一篇虚假的背部的训练计划 体重：65 身高：173 体脂：未知 ​ 无论是身体的哪一部分训练都可以遵循以下原则： ​ 感受身体对应的部位，了解它的肌肉线条，从而得到它拉伸的方向，拉到最远距离，缩到最近距离。接下来的每一个动作都可以依据这样的原则来进行训练 坐式低拉背​ 10KG 12RM ​ 10KG 12RM ​ 15KG 12RM ​ 20KG 12RM ​ 20KG 12RM 龙门架划船​ 25KG 12RM ​ 25KG 12RM ​ 35KG 8RM ​ 35KG 8RM ​ 25KG 8RM 坐式中拉背​ 10KG 12RM ​ 10KG 12RM ​ 15KG 12RM ​ 20KG 12RM ​ 20KG 12RM 高位下拉最喜欢的动作之一​ 30KG 16RM ​ 40KG 12RM ​ 40KG 12RM ​ 50KG 12RM ​ 50KG 5RM 正手引体向上​ 随缘力竭5组","categories":[{"name":"BODY","slug":"BODY","permalink":"http://yoursite.com/categories/BODY/"}],"tags":[]},{"title":"划水日记","slug":"index","date":"2019-09-22T15:19:49.000Z","updated":"2019-10-07T14:27:11.110Z","comments":true,"path":"2019/09/22/ index/","link":"","permalink":"http://yoursite.com/2019/09/22/ index/","excerpt":"","text":"今日观影报告：罪恶之城 今日游戏报告：星际神族训练，还是找不准timing啊 我什么时候才能开始真正些blog啊…=-= 明天要开始冲了啊，不能再这样放纵自己下去了啊！！","categories":[{"name":"DIARY","slug":"DIARY","permalink":"http://yoursite.com/categories/DIARY/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T08:49:53.178Z","updated":"2019-08-30T08:49:53.178Z","comments":true,"path":"2019/08/30/ hello-world/","link":"","permalink":"http://yoursite.com/2019/08/30/ hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}